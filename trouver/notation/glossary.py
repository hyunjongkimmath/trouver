"""Functions for viewing definitions and notations at once"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/06_notation_15.glossary.ipynb.

# %% auto 0
__all__ = ['generate_glossary_markdown', 'create_glossary_for_index_note']

# %% ../../nbs/06_notation_15.glossary.ipynb 2
from typing import List, Any
from bs4.element import Tag

from ..helper.html import remove_html_tags_in_text
from ..obsidian.vault import VaultNote
from .in_standard_info_note import notation_notes_linked_in_see_also_section
from .parse import parse_notation_note 

from trouver.personal_vault.notes import (
    notes_linked_in_note, 
    notes_linked_in_notes_linked_in_note
)
from ..personal_vault.note_type import note_is_of_type, PersonalNoteTypeEnum

# %% ../../nbs/06_notation_15.glossary.ipynb 3
from typing import List, Any
from bs4.element import Tag

# --- Assumed Imports from Your Library ---
# from trouver.obsidian.vault import VaultNote
# from trouver.helper.html import remove_html_tags_in_text
# from trouver.obsidian.links import notation_notes_linked_in_see_also_section
# from trouver.notation.parse import parse_notation_note 

#| export
def generate_glossary_markdown(info_notes: List[VaultNote]) -> str:
    """
    Generates a Markdown-formatted glossary from a list of info notes,
    only including notes that contain at least one definition or notation.

    Args:
        info_notes: A list of VaultNote objects to process.
        
    Returns:
        A single string containing the formatted Markdown glossary.
    """
    glossary_lines = []
    
    for note in info_notes:
        # Temporary list to hold items for the current note
        note_items = []
        
        # 1. Extract Definitions from HTML tags
        _, tags_and_locs = remove_html_tags_in_text(note.text())
        
        for tag, _, _ in tags_and_locs:
            if isinstance(tag, Tag) and tag.has_attr('definition'):
                definition_name = tag['definition']
                if definition_name:
                    note_items.append(f"    - {definition_name}")
        
        # 2. Extract Notations from linked notation notes
        linked_notation_notes = notation_notes_linked_in_see_also_section(note, note.vault)
        
        for notation_note in linked_notation_notes:
            parsed_data = parse_notation_note(notation_note)
            
            latex_str = None
            latex_str = parsed_data.notation_str.strip('$')
            
            if latex_str:
                note_items.append(f"    - ${latex_str}$")
                
        # 3. CRITICAL CHANGE: Only add the note to the glossary if it has items.
        if note_items:
            # Add the note's header first
            glossary_lines.append(f"- [[{note.name}]]")
            # Then add all the collected items
            glossary_lines.extend(note_items)
                
    return "\n".join(glossary_lines)


# def generate_glossary_markdown(info_notes: List[VaultNote]) -> str:
#     """
#     Generates a Markdown-formatted glossary from a list of info notes.

#     For each note, it lists:
#     - Definitions extracted from `definition` attributes in HTML tags.
#     - Notations from associated notation notes, parsed using the existing library function.
    
#     Args:
#         info_notes: A list of VaultNote objects to process.
        
#     Returns:
#         A single string containing the formatted Markdown glossary.
#     """
#     markdown_lines = []
    
#     for note in info_notes:
#         # Add the main info note link as a top-level list item
#         markdown_lines.append(f"- [[{note.name}]]")
        
#         # 1. Extract Definitions from HTML tags
#         _, tags_and_locs = remove_html_tags_in_text(note.text())
        
#         for tag, _, _ in tags_and_locs:
#             if isinstance(tag, Tag) and tag.has_attr('definition'):
#                 definition_name = tag['definition']
#                 if definition_name:
#                     markdown_lines.append(f"    - {definition_name}")
        
#         # 2. Extract Notations from linked notation notes
#         linked_notation_notes = notation_notes_linked_in_see_also_section(
#             note, note.vault)
        
#         for notation_note in linked_notation_notes:
#             # Call the existing parser. 
#             # This returns a structured object (dict or class), NOT a string.
#             parsed_data = parse_notation_note(notation_note)
            
#             # Extract the LaTeX string from the parsed data.
#             # ADJUST THIS KEY based on your actual return structure.
#             # Based on previous context, it might be 'notation', 'latex_in_original', or similar.
#             latex_str = None
            
#             # Example: if the parser returns a dict with a 'notation' key
#             latex_str = parsed_data.notation_str.strip('$')
            
#             # Fallback: if it uses 'latex_in_original' (list or str)
#             # if not latex_str
#             #     val = parsed_data.yaml_frontmatter['latex_in_original']
#             #     latex_str = val[0] if isinstance(val, list) and val else str(val)
            
#             # If parse_notation_note returns an object, access the attribute:
#             # elif hasattr(parsed_data, 'notation'):
#             #     latex_str = parsed_data.notation

#             if latex_str:
#                 markdown_lines.append(f"    - ${latex_str}$")
                        
#     return "\n".join(markdown_lines)


# %% ../../nbs/06_notation_15.glossary.ipynb 6
from typing import List, Optional
from pathlib import Path

# --- Assumed Imports from Your Library ---
# from trouver.obsidian.vault import VaultNote
# from trouver.obsidian.personal.notes import (
#     notes_linked_in_note, 
#     notes_linked_in_notes_linked_in_note
# )
# from trouver.obsidian.personal.note_type import is_info_note
# from .glossary import generate_glossary_markdown

def _resolve_info_notes_for_index(index_note: VaultNote) -> List[VaultNote]:
    """
    Determines the list of info notes associated with an index note.
    """
    # One-hop check
    direct_links = notes_linked_in_note(index_note, as_dict=False)
    if direct_links and all(
            note_is_of_type(n, PersonalNoteTypeEnum.STANDARD_INFORMATION_NOTE) for n in direct_links):
        return direct_links

    # Two-hop check
    two_hop_links = notes_linked_in_notes_linked_in_note(
        index_note, as_dict=False)
    if two_hop_links:
        return [n for n in two_hop_links 
                if note_is_of_type(n, PersonalNoteTypeEnum.STANDARD_INFORMATION_NOTE)]

    return []

#| export
def create_glossary_for_index_note(
    index_note: VaultNote,
    info_notes: Optional[List[VaultNote]] = None
) -> None:
    """
    Generates and saves a glossary file for a given index note.

    This function aggregates definitions and notations from a list of associated
    info notes and creates a new `VaultNote` named `_glossary_<name>`
    in the same directory as the index note.

    Args:
        index_note: The `VaultNote` object for the index note.
        info_notes: An optional list of `VaultNote` objects to be included in the
            glossary. If not provided, this function will automatically resolve
            the relevant notes based on the project's linking conventions.
    """
    # 1. Determine the list of info notes to process.
    if info_notes is None:
        info_notes_to_process = _resolve_info_notes_for_index(index_note)
    else:
        info_notes_to_process = info_notes

    if not info_notes_to_process:
        print(f"Warning: No info notes found or provided for index note '{index_note.name}'. No glossary will be generated.")
        return

    # 2. Generate the glossary markdown.
    print(f"Generating glossary for {len(info_notes_to_process)} info note(s)...")
    glossary_content = generate_glossary_markdown(info_notes_to_process)

    # 3. Determine the new note's name and path.
    # Parse the "actually interesting name" using the prefix "_index_"
    prefix = "_index_"
    if index_note.name.startswith(prefix):
        interesting_name = index_note.name[len(prefix):]
    else:
        interesting_name = index_note.name
    
    glossary_name = f"_glossary_{interesting_name}"
    
    # Determine the relative path for the new note.
    # We assume index_note.rel_path is available and is a Path object (or string).
    # The glossary should reside in the same directory.
    parent_dir = Path(index_note.rel_path).parent
    glossary_rel_path = parent_dir / f"{glossary_name}.md"

    # 4. Create the VaultNote object.
    # We assume the VaultNote constructor takes the vault instance and the relative path.
    glossary_note = VaultNote(index_note.vault, rel_path=str(glossary_rel_path))

    # 5. Create the file and write content using VaultNote methods.
    # This ensures proper cache management.
    if not glossary_note.exists():
        glossary_note.create()
    
    # Write the content
    glossary_note.write(glossary_content)
    print(f"Glossary successfully generated: {glossary_note.name}")

