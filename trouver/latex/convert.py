# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/16_latex.convert.ipynb.

# %% auto 0
__all__ = ['DEFAULT_NUMBERED_ENVIRONMENTS', 'divide_preamble', 'NoDocumentNodeError', 'find_document_node',
           'environment_names_used', 'counters_for_environments', 'divide_latex_text']

# %% ../../nbs/16_latex.convert.ipynb 3
from collections import OrderedDict
import os
from os import PathLike
from pathlib import Path
from pylatexenc import latexwalker, latex2text
from pylatexenc.latexwalker import (
    LatexWalker, LatexEnvironmentNode, get_default_latex_context_db,
    LatexNode, LatexSpecialsNode, LatexMathNode, LatexMacroNode, LatexCharsNode,
    LatexGroupNode, LatexCommentNode
)
from pylatexenc.latex2text import (
    MacroTextSpec, EnvironmentTextSpec)
from pylatexenc.macrospec import (
    MacroSpec, LatexContextDb, EnvironmentSpec
)
import re
from typing import Union
from trouver.helper import (
    find_regex_in_text, dict_with_keys_topologically_sorted,
    containing_string_priority, replace_string_by_indices, text_from_file
)
from trouver.markdown.markdown.file import (
    MarkdownFile, MarkdownLineEnum
)

from ..markdown.obsidian.vault import VaultNote
from trouver.markdown.obsidian.personal.index_notes import (
    correspond_headings_with_folder, convert_title_to_folder_name
)
from ..markdown.obsidian.personal.reference import setup_folder_for_new_reference
from ..markdown.obsidian.vault import VaultNote
import warnings

# %% ../../nbs/16_latex.convert.ipynb 4
DEFAULT_NUMBERED_ENVIRONMENTS = ['theorem', 'corollary', 'lemma', 'proposition',
                                 'definition', 'conjecture', 'remark', 'example',
                                 'question']

# %% ../../nbs/16_latex.convert.ipynb 20
def divide_preamble(
        text: str, # LaTeX document
        document_environment_name: str = "document"
        ) -> tuple[str, str]:
    """Divide the preamble from the rest of a LaTeX document.
    """
    begin_environment_str = rf'\begin{{{document_environment_name}}}'
    pattern = re.compile(re.escape(begin_environment_str))
    match = re.search(pattern, text) 
    start_match, end_match = match.span()
    return text[:start_match], text[start_match:]

    

# %% ../../nbs/16_latex.convert.ipynb 23
class NoDocumentNodeError(Exception):
    """Exception raised when a LatexEnvironmentNode corresponding to the document 
    environment is expected in a LaTeX string, but no such node exists.
    
    **Attributes**
    - text - str
        - The text in which the document environment is not found.
    """
    
    def __init__(self, text):
        self.text = text
        super().__init__(
            f"The following text does not contain a document environment:\n{text}")



# %% ../../nbs/16_latex.convert.ipynb 24
def find_document_node(
        text: str, # LaTeX str
        document_environment_name: str = "document" # The name of the document environment.
        ) -> LatexEnvironmentNode:
    """Find the `LatexNode` object for the main document in `text`.
    
    **Raises**
    - NoDocumentNodeError
        - If document environment node is not detected.
    """
    w = LatexWalker(text)
    nodelist, _, _ = w.get_latex_nodes(pos=0)
    for node in nodelist:
        if node.isNodeType(LatexEnvironmentNode)\
                and node.environmentname == document_environment_name:
            return node
    raise NoDocumentNodeError(text)

# %% ../../nbs/16_latex.convert.ipynb 35
def environment_names_used(
        text: str # LaTeX document
        ) -> set[str]: # The set of all environment names used in the main document.
    """Return the set of all environment names used in the main document
    of the latex code.
    """
    document_node = find_document_node(text)
    return {node.environmentname for node in document_node.nodelist
            if node.isNodeType(LatexEnvironmentNode)}        

# %% ../../nbs/16_latex.convert.ipynb 45
def counters_for_environments(
        text: str # The LaTeX document
        ) -> dict:  
    r"""Return the dict specifying the counters for each theorem-like environment.

    This function uses two separate regex patterns, one to detect the invocations of `\newtheorem`
    in which the optional parameter is the second parameter and one to detect those in which
    the optional parameter is the third parameter.

    Assumes that
    - invocations of the `\newtheorem` command are exclusively in the
    preamble of the LaTeX document.
    - theorem-like environments are defined using the `\newtheorem` command.
    - no environments of the same name are defined twice.

    """
    preamble, _ = divide_preamble(text)
    second_parameter_pattern = re.compile(
        # r'\\newtheorem\s*\{\s*(\w+)\s*\}\s*(\[\s*(\w+)\s*\])?\s*\{\s*(.*)\s*\}')
        # In this case, the optional parameter (if any) should not follow the newtheorem.
        r'\\newtheorem\s*\{\s*(\w+)\s*\}\s*(\[\s*(\w+)\s*\])?\s*\{\s*(.*)\s*\}(?!\s*\[\s*(\w+)\s*\])')
    third_parameter_pattern = re.compile(
        r'\\newtheorem\s*\{\s*(\w+)\s*\}\s*\{\s*(.*)\s*\}\s*(\[\s*(\w+)\s*\])?')
    second_results = _search_counters_by_pattern(preamble, second_parameter_pattern, 3)
    third_results = _search_counters_by_pattern(preamble, third_parameter_pattern, 4)
    return second_results | third_results
    

def _search_counters_by_pattern(
        preamble: str,
        newtheorem_regex: re.Pattern,
        counter_group: int # This depends on which `newtheorem_regex` is used, and is either 3 or 4. 
        ) -> dict:
    """
    Capture the newly defined theorem-like environment names as well as the
    counters that they belong to"""
    counters = {}
    for match in newtheorem_regex.finditer(preamble):
        env_name = match.group(1)
        counter = match.group(counter_group)
        # If no counter was specified, use the environment name as the counter
        if counter is None:
            counter = env_name
        counters[env_name] = counter
    return counters

# %% ../../nbs/16_latex.convert.ipynb 50
def divide_latex_text(
        text: str, # The text of a LaTeX document
        environments_to_divide_along: list[str], # A list of the names of environments that warrant a new note
        numbered_environments: list[str], # A list of the names of environments that do not warrant a new note
        numbering_convention: str,
        section_name: str = 'section', # The command name for sections
        subsection_name: str= 'subsection', # The command name for subsections
        proof_name: str = 'proof', # The environment name for proofs
        ) -> list[tuple[str, str]]: 
    """Divide LaTeX text to convert into Obsidian.md notes.
    

    """
    return

# %% ../../nbs/16_latex.convert.ipynb 51
# TODO: numbering convention could be theorems separate (e.g. theorem 1, 2, ...)
# and subsections separate.
def divide_latex_text(
        text, # The text of a latex document.
        numbered_environments: list[str] = DEFAULT_NUMBERED_ENVIRONMENTS, # A list of the names of environments which are numbered in the latex code. 
        numbering_convention: str = 'separate', # One of <br><br> - 'separate': Subsections of a section have separate numberings, e.g. 'Lemma 1.2.1, Proposition 1.2.2, Figure 1.2.3, Theorem 1.3.1' <br> - 'shared': Subsections of a section share numberings, e.g.  'Lemma 1.1, Proposition 1.2, Figure 1.3, Theorem 1.4'
        section_name: str = 'section', # The command name for sections. For example, SGA has chapters and sections. For the purposes of this function, it is appropriate to regard them as sections and subsections, respectively.
        subsection_name: str = 'subsection', # The commmand name for subsections
        proof_name: str = 'proof' # The environment name for proofs
        ) -> list[tuple[str, str]]: # Each tuple corresponds to an Obsidian note to be constructed.  Such a tuple is of the form `[<node_type & numbering>, <text>]` where `node_type & numbering` is a string which serves as a title for the text making up the note, and `text` is the content of the note.
    """Divides latex text to convert into Obsidian notes.
    
    """
    document_node = find_document_node(text)
    section_num = 0
    subsection_num = 0
    environment_num = 0
    outside_num = 1  # Since not everything is in a nice environment, many 
                     # notes will need their own numbers.
    parts = []
    accumulation = ''
    for node in document_node.nodelist:
        (section_num, subsection_num, environment_num, outside_num,
         accumulation)\
            = _process_node(
                section_num, subsection_num, environment_num, outside_num,
                accumulation, parts, node, section_name, subsection_name,
                proof_name, numbered_environments, numbering_convention)
            
    outside_num += 1
    parts.append([str(outside_num), accumulation])
    return parts
            
def _process_node(
        section_num: int, subsection_num: int, environment_num: int,
        outside_num: int, accumulation: str, parts: list, node: LatexNode,
        section_name: str, subsection_name: str, proof_name: str,
        numbered_environments: list[str], numbering_convention: str) -> tuple:
    """
    Choose the node-processing method, if the node is a section/subsection or environment
    and

    """
    process_method_to_run = None
    if node.isNodeType(LatexMacroNode) and node.macroname == section_name:
        process_method_to_run = _process_section
    elif node.isNodeType(LatexMacroNode) and node.macroname == subsection_name:
        process_method_to_run = _process_subsection
    elif (node.isNodeType(LatexEnvironmentNode)
          and node.environmentname in numbered_environments):
        process_method_to_run = _process_environment_node
    if process_method_to_run:
        (section_num, subsection_num, environment_num, outside_num,
        accumulation)\
            = process_method_to_run(
            section_num, subsection_num, environment_num, outside_num,
            accumulation, parts, node, section_name, subsection_name,
            numbering_convention)
    elif (node.isNodeType(LatexEnvironmentNode)
          and node.environmentname == proof_name):
          # TODO: if the environment is a proof, and if it starts a section/subsection,
          # Then the proof is appended into the title of the section/subsection, see
          # landesman_litt_ipwc, around line 1858-1863 for example.
        parts[-1][1] += f'\n{node.latex_verbatim()}'
    else:
        accumulation += node.latex_verbatim()
    return (section_num, subsection_num, environment_num, outside_num,
            accumulation)


def _process_section(
        section_num: int, subsection_num: int, environment_num: int,
        outside_num: int, accumulation: str, parts: list[list],
        node: LatexMacroNode, section_name: str, subsection_name: str,
        numbering_convention: str) -> tuple:
    """Do stuff when the node is a section node. Return updated
    section_num, subsection_num, environment_num
    """
    numbered, title  = _section_title(
        node.latex_verbatim(), section_name, subsection_name)
    section_num += 1 if numbered else 0
    subsection_num = 0
    environment_num = 0
    if accumulation.strip() != '':
        parts.append([str(outside_num), accumulation])
        outside_num += 1
        accumulation = ''
    parts.append([f'{section_name} {section_num}', title])
    return (section_num, subsection_num, environment_num, outside_num,
            accumulation)
    

def _process_subsection(
        section_num: int, subsection_num: int, environment_num: int,
        outside_num: int, accumulation: str, parts: list[list],
        node: LatexMacroNode, section_name: str, subsection_name: str,
        numbering_convention: str) -> tuple:
    """Do stuff when the node is a subsection node.
    """
    numbered, title  = _section_title(
        node.latex_verbatim(), section_name, subsection_name)
    subsection_num += 1 if numbered else 0
    if numbering_convention == 'separate':
        environment_num = 0
    if accumulation.strip() != '':
        parts.append([str(outside_num), accumulation])
        outside_num += 1
        accumulation = ''
    parts.append([f'{subsection_name} {section_num}.{subsection_num}', title])
    return (section_num, subsection_num, environment_num, outside_num,
            accumulation)


def _process_environment_node(
        section_num: int, subsection_num: int, environment_num: int,
        outside_num: int, accumulation: str, parts: list[list],
        node: LatexMacroNode, section_name: str, subsection_name: str,
        numbering_convention: str) -> tuple:
    """
    """
    environment_num += 1
    if accumulation.strip() != '':
        parts.append([str(outside_num), accumulation])
        outside_num += 1
        accumulation = ''
    if numbering_convention == 'separate':
        pointed_numbering = f'{section_num}.{subsection_num}.{environment_num}'
        numbering = f'{node.environmentname} {pointed_numbering}'
    elif numbering_convention == 'shared':
        numbering = f'{node.environmentname} {section_num}.{environment_num}'
    parts.append([numbering, node.latex_verbatim()])
    return (section_num, subsection_num, environment_num, outside_num,
            accumulation)


def _section_title(text: str, section_name, subsection_name) -> str:
    """Returns the title of a section or subsection from a latex str
    and whether or not the section/subsection is numbered.
    
    **Parameters**
    - text - str
    - section_name - str
    - subsection_name - str
    
    **Returns**
    - str, bool
    """
    # TODO: test things like `\\section {Generating series of special divisors}`
    # See qiu_amsd for example.
    # TODO: deal with the possibility of multi-line sections/subsections,
    # e.g. \subsection{Arithmetic intersrection\n pairing},
    # see qiu_amsd for example
    regex_search = re.search(r'\\' + fr'(?:{section_name}|{subsection_name}) *?'
                             + r'(?:\[.*\])?(\*)?\{(.*)\}', text)
    # regex_search = re.search(r'\\' + fr'(?:{section_name}|{subsection_name})'
    #                          + r'(?:\[.*\])?(\*)?\{(.*)\}', text)
    # print(text)
    # print(section_name, subsection_name)
    if regex_search is None:
        print(text, section_name, subsection_name)
    return not bool(regex_search.group(1)), regex_search.group(2)


