"""Functions for gathering and processing data to train and for using  ML models to link notation notes with one another."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/07_machine_learning_45.notation_linking.ipynb.

# %% auto 0
__all__ = ['NotationNoteInitData', 'notat_linking_data_from_notation_notes', 'data_points_for_reference', 'text_from_note_data',
           'text_from_data_point', 'augment_notation_linking_data', 'prediction_by_model',
           'rank_notat_notes_to_potentially_link_to', 'add_links_to_notation_note_via_data_point',
           'count_notat_note_links', 'sieve_then_add_links_to_notation_notes']

# %% ../../nbs/07_machine_learning_45.notation_linking.ipynb 5
import ast
from os import PathLike
from pathlib import Path
import random
import re
import sys
from typing import Literal, NamedTuple, Optional, TypedDict, Union

from scipy.spatial.distance import cosine
from sentence_transformers import SentenceTransformer
import transformers
from transformers.pipelines.text_classification import TextClassificationPipeline



from ..helper import get_top_counted_items
from trouver.helper.latex.augment import (
    dollar_sign_manipulation, random_char_modification, remove_math_keywords, random_word_removal, random_latex_command_removal, augment_text, change_font_styles_at_random, remove_font_styles_at_random, change_greek_letters_at_random, choose_modification_methods_at_random
    )
from ..markdown.file import MarkdownFile, MarkdownLineEnum
from ..obsidian.links import MARKDOWNLINK_CAPTURE_PATTERN, LinkFormatError, ObsidianLink, link_ranges_in_text
from ..personal_vault.information_notes import reference_of_information_note, index_note_of_note
from .notation import notat_note_data_from_parsed_and_main_note_processed
from ..notation.in_standard_info_note import notation_notes_linked_in_see_also_section
from ..notation.parse import NotationNoteParsed, parse_notation_note, _notat_str
from ..personal_vault.note_processing import process_standard_information_note
from ..personal_vault.note_type import note_is_of_type, type_of_note, PersonalNoteTypeEnum
from ..personal_vault.notes import notes_linked_in_notes_linked_in_note, notes_linked_in_note
from .notation import (
    NotationNoteData, NotationLinkingDataPoint, data_point_to_notation_note_data_pair, 
    notation_note_data_pair_to_data_point)
from .notation_summarization import _notation_note_has_auto_summary_tag
from ..obsidian.vault import VaultNote, NotePathIsNotIdentifiedError

# %% ../../nbs/07_machine_learning_45.notation_linking.ipynb 9
class NotationNoteInitData(NamedTuple):
    """
    A type of cached data for datapoints involving a notation note.
    """
    notation_note: VaultNote # The notation note
    parsed: Union[NotationNoteParsed, None] # The output of `parse_notation_note` applied to `notation_note`
    main_note_content: Union[str, None] # The content of the main note of `notation_note`, i.e. the output of `process_standard_information_note`(MarkdownFile.from_vault_note(main_of_notation_note))`. If `None`, then this needs to be computed "on-the-fly".`
    linked_notat_notes: set[str] # The names of the notation notes that `notation_note` links to.


# %% ../../nbs/07_machine_learning_45.notation_linking.ipynb 10
def _linked_note_names_from_content(
        content: str) -> list[str]:
    linked_note_names = []
    for match in re.findall(MARKDOWNLINK_CAPTURE_PATTERN, content):
        link_name = match[1]
        if link_name.endswith('.md'):
            link_name = link_name[:-3]
        linked_note_names.append(link_name)
    return linked_note_names
        


# %% ../../nbs/07_machine_learning_45.notation_linking.ipynb 12
def _linked_notat_note_names_from_content(
        content: str, vault: PathLike) -> list[str]:
    linked_note_names = _linked_note_names_from_content(content)
    linked_notation_note_names = []
    for linked_note_name in linked_note_names:
        note = VaultNote(vault, name=linked_note_name, update_cache=False)
        if note_is_of_type(note, PersonalNoteTypeEnum.NOTATION_NOTE):
            linked_notation_note_names.append(note.name)
    return linked_notation_note_names



# %% ../../nbs/07_machine_learning_45.notation_linking.ipynb 14
def _linked_notat_note_names_from_parsed(
        notat_note_parsed: NotationNoteParsed,
        vault: PathLike
        ) -> set[str]:
    """
    Helper function to `_init_args_for_data_from_notation_notes`

    Since some notation note links are within the content of a notation note
    rather than at the end as an unordered list, we need to obtain them
    separately.

    """
    # TODO: use this function for initializing notation note linking data in the `data_for_reference` function.
    linked_notat_note_names = []
    for _, notat_note in notat_note_parsed.linked_notation_notes:
        if notat_note.endswith('.md'):
            notat_note = notat_note[:-3]
        linked_notat_note_names.append(notat_note)
    
    linked_notat_note_names = set(linked_notat_note_names)
    linked_notat_note_names.update(
        _linked_notat_note_names_from_content(
            str(notat_note_parsed.main_content_markdown_file), vault))
    return linked_notat_note_names

# %% ../../nbs/07_machine_learning_45.notation_linking.ipynb 15
# TODO: test
def _init_args_for_data_from_notation_notes(
        vault: PathLike,
        origin_init_data: NotationNoteInitData, # The cached data for the notation note which potentially uses the notation introduced by the `relied_notation_note`. In particular, there potentially ought to be a link to `relied_notation_note` in `origin_notation_note`.
        relied_init_data: NotationNoteInitData, # The cached data for the notation note `relied_notation_note`. 
        reference_name: Optional[str] = None, # The name of the reference folder in the vault from which the two notation notes comes from. If `None`, this is computed "on-the-fly" based on the reference of the main note of main_of_origin, see `reference_of_information_note`
        information_notes_of_reference: Optional[list[VaultNote]] = None, # The standard information notes for the reference folder in order (as arranged in the index notes of the reference folder)
    ) -> tuple[NotationNoteParsed, NotationNoteParsed, str, str, str, set[str], list[VaultNote]]:
    origin_notation_note, origin_parsed, main_of_origin_content, linked_notat_notes_in_origin = origin_init_data
    relied_notation_note, relied_parsed, main_of_relied_content, linked_notat_notes_in_relied = relied_init_data

    if origin_parsed is None:
        origin_parsed: NotationNoteParsed = parse_notation_note(origin_init_data.notation_note)
    if relied_parsed is None:
        relied_parsed: NotationNoteParsed = parse_notation_note(relied_init_data.notation_note)

    main_of_origin, main_of_relied = origin_parsed.name_of_main_note, relied_parsed.name_of_main_note
    if reference_name is None and main_of_origin is not None:
        reference_name = reference_of_information_note(main_of_origin)

    if main_of_origin_content is None and main_of_origin is not None:
        main_of_origin_content = process_standard_information_note(
            MarkdownFile.from_vault_note(main_of_origin))
    if main_of_relied_content is None and main_of_relied is not None:
        main_of_relied_content = process_standard_information_note(
            MarkdownFile.from_vault_note(main_of_relied))

    if linked_notat_notes_in_origin is None:
        linked_notat_notes_in_origin = _linked_notat_note_names_from_parsed(origin_parsed, vault)

    if information_notes_of_reference is None:
        # TODO Implement the initialization of `information_notes_of_reference`.
        information_notes_of_reference = information_notes_of_reference
    return (
        origin_parsed, relied_parsed, reference_name, main_of_origin_content,
        main_of_relied_content,
        linked_notat_notes_in_origin,
        information_notes_of_reference)



# %% ../../nbs/07_machine_learning_45.notation_linking.ipynb 16
# TODO: test
def _origin_links_to_relied(
        linked_notat_notes: list[tuple], # One of the outputs of `parse_notation_note`
        origin_content: MarkdownFile,  # One of the outputs of `parse_notation_note`
        relied_notation_note: VaultNote
        ) -> bool:
    r"""Returns `True` if the origin notation note links to `relied_notation_note`.

    Helper function to `notat_linking_data_from_notation_notes`.
    
    This function checks both the trailing list of links as well as any links within
    the content of the origin notation note.
    """

    linked_note_names = []
    for _, notat_note_name in linked_notat_notes:
        if notat_note_name.endswith('.md'):
            notat_note_name = notat_note_name[:-3]
        linked_note_names.append(notat_note_name)
        # if notat_note_name == relied_notation_note.name:
        #     return True
    linked_note_names.extend(
        _linked_note_names_from_content(str(origin_content)))
        
    for note_name in linked_note_names:
        if note_name == relied_notation_note.name:
            return True
    return False


def _adjust_content(
        include_content: bool, 
        content: str,
        meta: Union[dict, None],
        ) -> str:
    r"""
    Helper function to `notat_linking_data_from_notation_notes`.

    Sometimes, the content of a notation note is autogenerated by an ML model
    and hence can be unreliable. This function is used to exclude
    autogenerated content.
    """
    if not include_content or (
            meta is not None and 'tags' in meta and '_auto/notation_summary' in meta['tags']):
        return ""
    return content



# %% ../../nbs/07_machine_learning_45.notation_linking.ipynb 18
# TODO: test

def notat_linking_data_from_notation_notes(
        origin_notation_note_data: NotationNoteInitData,
        relied_notation_note_data: NotationNoteInitData,
        include_origin_content: bool, # If `True`, include the content of `origin_notation_note`, i.e. a summary of what the notation introduced by this note means.
        include_relied_content: bool, # If `True`, include the content of `relied_notation_note`, i.e. a summary of what the notation introduced by this note means.
        reference_name: Optional[str] = None, # The name of the reference folder in the vault from which the two notation notes comes from. If `None`, this is computed "on-the-fly" based on the reference of the main note of main_of_origin, see `reference_of_information_note`
        information_notes_of_reference: Optional[list[VaultNote]] = None, # The standard information notes for the reference folder in order (as arranged in the index notes of the reference folder)
        vault: PathLike = None, # If `None`, the vault of `origin_notation_note_data` is used.
    ) -> NotationLinkingDataPoint:
    """
    Obtain data for a single pair of notation notes.

    Assumes that

    - `origin_notation_note` and `relied_notation_note` have the same `vault`
      attribute.
    - `origin_parsed` and `relied_parsed` are respectively the outputs of
      `parse_notation_note` applied to `reference_name` if specified.
    - `reference_name` is the correct output of `reference_of_information_note`
      applied to `main_of_origin` and that this output is the same as that when
      applied to `main_of_relied`.
    - `main_of_origin_content` and `main_of_relied_content` are the outputs of
      `process_standard_information_note(MarkdownFile.from_vault_note(main_of_origin))`
      and
      `process_standard_information_note(MarkdownFile.from_vault_note(main_of_relied))`
      respectively if they are specified.
    - `information_notes_of_reference` correctly lists the standard information
      notes from the reference in the vault of name `reference_name`.
    """
    if not vault:
        vault = origin_notation_note_data.notation_note.vault

    (origin_parsed, relied_parsed, reference_name, main_of_origin_content,
     main_of_relied_content, linked_notat_notes_in_origin, information_notes_of_reference
     ) = _init_args_for_data_from_notation_notes(
         vault,
         origin_notation_note_data,
         relied_notation_note_data,
         reference_name,
         information_notes_of_reference)
     
    (origin_meta, origin_notat_str, main_of_origin_name,
     origin_content, linked_notat_notes
     ) = origin_parsed
    (relied_meta, relied_notat_str, main_of_relied_name, relied_content, _
     ) = relied_parsed

    origin_content, relied_content = str(origin_content), str(relied_content)
    origin_content = _adjust_content(include_origin_content, origin_content, origin_meta)
    relied_content = _adjust_content(include_relied_content, relied_content, relied_meta)

    origin_notation_note_name=origin_notation_note_data.notation_note.name
    relied_notation_note_name=relied_notation_note_data.notation_note.name
    return NotationLinkingDataPoint(
        # origin_notation_note_name=origin_notation_note.name,
        origin_notation_note_name=origin_notation_note_name,
        main_of_origin_notation_note_name=main_of_origin_name,
        origin_notation_note_content=origin_content,
        processed_main_of_origin_content=main_of_origin_content,
        latex_in_original_or_summarized_in_origin=_notat_str(origin_meta, origin_notat_str),
        summarized_in_origin=origin_notat_str,
        reference_of_origin=reference_name,

        # relied_notation_note_name=relied_notation_note.name,
        relied_notation_note_name=relied_notation_note_name,
        main_of_relied_notation_note_name=main_of_relied_name,
        relied_notation_note_content=relied_content,
        processed_main_of_relied_content=main_of_relied_content,
        latex_in_original_or_summarized_in_relied=_notat_str(relied_meta, relied_notat_str),
        summarized_in_relied=relied_notat_str,
        reference_of_relied=reference_name,

        origin_links_to_relied=relied_notation_note_name in linked_notat_notes_in_origin
        # origin_links_to_relied=_origin_links_to_relied(linked_notat_notes, origin_content, relied_notation_note)
        )



# %% ../../nbs/07_machine_learning_45.notation_linking.ipynb 19
def _positive_pairs_of_notation_notes(
        confirmed_summary_notat_note_names: list[str],
        notat_notes_and_linked_notat_notes: dict[str, set[str]],
        # notat_notes_and_parsed: dict[str, NotationNoteParsed],
        vault: PathLike
        ) -> list[tuple[str, str]]:
    r"""Return the pairs `(<origin_notat_note_name>, <linked_notat_note_name>)`
    where `origin_notat_note_name` is the name of a notation note whose notation
    summary is "confirmed" (i.e. written and not autogenerated) and where
    `linked_notat_note_name` is the name of a notation note linked by the
    notation note with name `origin_notat_note_name`.
    """
    positive_linked_notat_note_pairs = []
    
    for notat_note_name in confirmed_summary_notat_note_names:
        if not notat_note_name in notat_notes_and_linked_notat_notes:
            continue
        for linked_notat_note_name in notat_notes_and_linked_notat_notes[notat_note_name]:
            positive_linked_notat_note_pairs.append((notat_note_name, linked_notat_note_name))

    return positive_linked_notat_note_pairs
    


# %% ../../nbs/07_machine_learning_45.notation_linking.ipynb 20
def _positive_data_points(
        reference_index_note: VaultNote,
        positive_linked_notat_note_pairs: list[tuple[str, str]],
        notat_notes_and_parsed: dict[str, NotationNoteParsed],
        notat_notes_and_linked_notat_notes: dict[str, set[str]],
        info_notes_and_processed_content: dict[str, str]
        # ) -> list[tuple]:
        ) -> list[NotationLinkingDataPoint]:
    r"""Gather data points for the pairs `(<origin_notat_note_name>, <linked_notat_note_name>)`
    where `origin_notat_note_name` is the name of a notation note whose notation
    summary is "confirmed" (i.e. written and not autogenerated) and where
    `linked_notat_note_name` is the name of a notation note linked by the
    notation note with name `origin_notat_note_name`.
    """
    vault = reference_index_note.vault
    data_points: list[NotationLinkingDataPoint] = []

    # for name, _ in notat_notes_and_parsed.items():
    #     print(name)
    
    for origin_notat_note_name, linked_notat_note_name in positive_linked_notat_note_pairs:
        try:
            origin_notat_note = VaultNote(vault, name=origin_notat_note_name, update_cache=False)
            linked_notat_note = VaultNote(vault, name=linked_notat_note_name, update_cache=False)
            main_of_origin_name = notat_notes_and_parsed[origin_notat_note_name].name_of_main_note
            main_of_linked_name = notat_notes_and_parsed[linked_notat_note_name].name_of_main_note
            if (main_of_origin_name is None or main_of_linked_name is None
                    or main_of_origin_name not in info_notes_and_processed_content
                    or main_of_linked_name not in info_notes_and_processed_content):
                continue

            for include_origin_content, include_linked_content in [(True, True), (True, False), (False, True), (False, False)]:
                data_points.append(notat_linking_data_from_notation_notes(
                    # TODO: modify these NotationNoteInitData constructions to 
                    # include `linked_notat_notes`
                    NotationNoteInitData(
                        origin_notat_note,
                        notat_notes_and_parsed[origin_notat_note_name],
                        info_notes_and_processed_content[main_of_origin_name],
                        notat_notes_and_linked_notat_notes.get(origin_notat_note_name, set()),
                        ),
                    NotationNoteInitData(
                        linked_notat_note,
                        notat_notes_and_parsed[linked_notat_note_name],
                        info_notes_and_processed_content[main_of_linked_name],
                        notat_notes_and_linked_notat_notes.get(linked_notat_note_name, set()),
                        ),
                    include_origin_content,
                    include_linked_content, 
                    reference_index_note.name[7:], # name starts with '_index_',
                    None # TODO: Pass proper argument for information_notes_of_reference
                    ))
        except Exception as e:
            print('An error has occurred while gathering data:')
            print(e)
    return data_points



# %% ../../nbs/07_machine_learning_45.notation_linking.ipynb 21
def _sample_data_points(
        reference_index_note: VaultNote,
        num_samples: int, 
        # info_notes: list[VaultNote],
        notat_notes: list[VaultNote],
        confirmed_summary_notat_note_names: list[VaultNote],
        notat_notes_and_parsed: dict[str, NotationNoteParsed],
        notat_notes_and_linked_notat_notes: dict[str, set[str]],
        info_notes_and_processed_content: dict[str, str]
        # ) -> list[tuple]:
        ) -> list[NotationLinkingDataPoint]:
    r"""Randomly sample pairs `(<origin_notat_note_name>, <relied_notat_note_name>)`
    """
    # num_samples = min(num_samples, len(confirmed_summary_notat_note_names))
    origins = random.choices(confirmed_summary_notat_note_names, k=num_samples)
    origins = [VaultNote(reference_index_note.vault, name=name, update_cache=False) for name in origins]
    relieds = random.choices(notat_notes, k=num_samples)
    data_points: list[NotationLinkingDataPoint] = []
    for origin, relied in zip(origins, relieds):
        main_of_origin_name = notat_notes_and_parsed[origin.name].name_of_main_note
        main_of_relied_name = notat_notes_and_parsed[relied.name].name_of_main_note
        if (main_of_origin_name is None or main_of_relied_name is None
                or main_of_origin_name not in info_notes_and_processed_content
                or main_of_relied_name not in info_notes_and_processed_content):
            continue
        for include_origin_content, include_relied_content in [(True, True), (True, False), (False, True), (False, False)]:
            data_points.append(notat_linking_data_from_notation_notes(
                # TODO: modify these NotationNoteInitData constructions to 
                # include `linked_notat_notes`
                NotationNoteInitData(
                    origin,
                    notat_notes_and_parsed[origin.name],
                    info_notes_and_processed_content[main_of_origin_name],
                    notat_notes_and_linked_notat_notes.get(origin.name, set()),
                    ),
                NotationNoteInitData(
                    relied,
                    notat_notes_and_parsed[relied.name],
                    info_notes_and_processed_content[main_of_relied_name],
                    notat_notes_and_linked_notat_notes.get(relied.name, set()),
                    ),
                include_origin_content,
                include_relied_content, 
                reference_index_note.name[7:], 
                None  # TODO: Pass proper argument for information_notes_of_reference
                ))
    return data_points

# %% ../../nbs/07_machine_learning_45.notation_linking.ipynb 22
def data_points_for_reference(
        reference_index_note: VaultNote, # The index note for the reference from which to draw the data.
        return_notation_note_parsings: bool = False, # If `True`, return the outputs of `parse_notation_note` applied to the notation notes in the reference folder 
        ) -> Union[list[NotationLinkingDataPoint], tuple[list[NotationLinkingDataPoint], dict[str, NotationNoteParsed]]]:
        # ) -> Union[list[tuple], tuple[list[tuple], dict[str, NotationNoteParsed]]]:
    r"""Compile data points for notation note linking based on the information
    notes and notation notes in a reference folder.

    "Positive" linking data points are relatively rare in comparison to "Negative"
    data points, so "Negative" data points are randomly sampled (although the random
    samples will redundantly include "Positive" data as well).

    Note that it makes sense to draw data exclusively within each "reference" ---
    notations tend to have dependencies within the same mathematical text.

    **Returns**
    - `Union[list[tuple], tuple[list[tuple], dict[str, tuple]]]`
        - Either 1. a list of tuples --- in this case, each tuple is a
          "data point" and is an output of `notat_linking_data_from_notation_notes` ---
          or 2. the list of tuples along with a dict whose keys are
          the names of the notation notes and whose values are the
          outputs of `parse_notation_note` applied to these notation notes.
    """
    # TODO: initialize the data of the notation notes that each notation note links to.
    info_notes = notes_linked_in_notes_linked_in_note(reference_index_note, as_dict=False)
    info_notes = [note for note in info_notes if note.exists() and note_is_of_type(note, PersonalNoteTypeEnum.STANDARD_INFORMATION_NOTE)]
    notat_notes: list[VaultNote] = []
    for info_note in info_notes:
        notat_notes.extend(notation_notes_linked_in_see_also_section(info_note, info_note.vault))

    vault = reference_index_note.vault
    info_notes_and_processed_content = {}
    for note in info_notes:
        try:
            info_notes_and_processed_content[note.name] = str(process_standard_information_note(MarkdownFile.from_vault_note(note), vault))
        except TypeError as e:
            print(f"An error occurred while trying to process the following note: {note.name}")
            print(e)
            info_notes_and_processed_content[note.name] = note.text()
        except LinkFormatError as e:
            print(r"A Link formatting error occurred while trying to process the following note: {note.name}")
            print(e)
            info_notes_and_processed_content[note.name] = note.text()

    notat_notes_and_parsed: dict[str, NotationNoteParsed] = {
        notat_note.name: parse_notation_note(notat_note, process_notation_note_content=True) for notat_note in notat_notes}
    notat_notes_and_parsed = _filter_notat_notes_with_auto_generated_notat_links(
        notat_notes_and_parsed)
    
    notat_notes_and_linked_notat_notes: dict[str, set[str]] = {
        notat_note.name: _linked_notat_note_names_from_parsed(
            notat_notes_and_parsed[notat_note.name], vault)
        for notat_note in notat_notes}

    # Notation notes whose summaries are written and not auto-generated
    confirmed_summary_notat_note_names = [
        notat_note for notat_note, parsed in notat_notes_and_parsed.items()
        if not _notation_note_has_auto_summary_tag(parsed[0])]

    # Get all positive pairs of notation notes
    positive_linked_notat_note_pairs = _positive_pairs_of_notation_notes(
        confirmed_summary_notat_note_names,
        notat_notes_and_linked_notat_notes,
        vault)
    data_points: list[NotationLinkingDataPoint] = _positive_data_points(
        reference_index_note, positive_linked_notat_note_pairs,
        notat_notes_and_parsed, notat_notes_and_linked_notat_notes,
        info_notes_and_processed_content)
    data_points.extend(_sample_data_points(
        reference_index_note, len(data_points)*4,
        notat_notes, confirmed_summary_notat_note_names,
        notat_notes_and_parsed, notat_notes_and_linked_notat_notes,
        info_notes_and_processed_content))
    if return_notation_note_parsings:
        return data_points, notat_notes_and_parsed
    else:
        return data_points


def _filter_notat_notes_with_auto_generated_notat_links(
        notat_notes_and_parsed: dict[str, NotationNoteParsed]
        ) -> dict[str, NotationNoteParsed]:
    return {
        name: parsed for name, parsed in notat_notes_and_parsed.items()
        if not parsed.yaml_frontmatter_meta or 'tags' not in parsed.yaml_frontmatter_meta or '_auto/notation_notes_linked' not in parsed.yaml_frontmatter_meta['tags']}




# %% ../../nbs/07_machine_learning_45.notation_linking.ipynb 23
def text_from_note_data(
        note_data: NotationNoteData,
        separation_token: str = '[SEP]',
        ) -> str:
    text = (
        f"latex_in_original_or_summarized: {note_data['latex_in_original_or_summarized']}\n\n{separation_token}\n\n"
        f"summarized: {note_data['summarized']}\n\n{separation_token}\n\n"
        f"main_note_content: {note_data['main_note_content']}\n\n{separation_token}\n\n"
        f"processed_content: {note_data['processed_content']}"
        )
    return text

def text_from_data_point(
        data_point: NotationLinkingDataPoint,  # An output of `notat_linking_data_from_notation_notes`.
        separation_token: str = '[SEP]',
        ) -> str:
    r"""
    Format a data point to present it as a str.
    """
    origin_data, relied_data = data_point_to_notation_note_data_pair(data_point)
    origin_text = text_from_note_data(origin_data, separation_token)
    relied_text = text_from_note_data(relied_data, separation_token)
    return f"origin_data:\n\n{separation_token}\n\n{origin_text}\n\n{separation_token}\n\nrelied_data:\n\n{separation_token}\n\n{relied_text}"

def _content_relied(
        main_of_origin_content: str,
        main_of_relied_content: str,
        ) -> str:
    if main_of_origin_content == main_of_relied_content:
        return f"Content for main note of relied_notation_note: same as that of main note of origin_notation_note" 
    else:
        return f"Content for main note of relied_notation_note: {main_of_relied_content}"

# %% ../../nbs/07_machine_learning_45.notation_linking.ipynb 25
def augment_notation_linking_data(
        datapoint: NotationLinkingDataPoint,
        num_augmentation_sets: int = 1, # Each augmentation set consists of an augmentation with low, medium, and high probability modifications.
        seed: Optional[int] = None
        ) -> list[NotationLinkingDataPoint]:
    r"""
    Augment a given datapoint for Notation Linking
    """
    augmented_datapoints: list[NotationLinkingDataPoint] = []
    if seed is not None:
        random.seed(seed)
    for _ in range(num_augmentation_sets):
        augmented_datapoints.append(
            _augment_notation_linking_data_once(datapoint, 'low'))
        augmented_datapoints.append(
            _augment_notation_linking_data_once(datapoint, 'mid'))
        augmented_datapoints.append(
            _augment_notation_linking_data_once(datapoint, 'high'))
    return augmented_datapoints


def _augment_notation_linking_data_once(
        datapoint: NotationLinkingDataPoint,
        modification: Literal['low', 'mid', 'high'],
        ) -> NotationLinkingDataPoint:
    methods = [
        # (push_dollar_signs,0.2),
        (remove_font_styles_at_random, 0.1), (change_font_styles_at_random, 0.2), (change_greek_letters_at_random, 0.1), 
        (remove_math_keywords,0.1), (random_latex_command_removal,0.2),
        (random_word_removal,0.1), (dollar_sign_manipulation,0.05),
        (random_char_modification,0.001)]
    if modification == 'low':
        method_inclusion_chance = 0.3
        scale = 0.5
    elif modification == 'mid':
        method_inclusion_chance = 0.5
        scale = 1.0
    else:
        method_inclusion_chance = 0.8
        scale = 1.5
    
    random_methods = choose_modification_methods_at_random(
        methods, method_inclusion_chance, scale)
    # random_methods = []
    # def create_method(method, p, scale):
    #     return lambda x: method(x, p=p*scale)
    # for method, p in methods:
    #     if random.random() < method_inclusion_chance:
    #         random_methods.append(create_method(method, p, scale))

    augmented_datapoint = datapoint.copy()
    for key in ['origin_notation_note_content', 'processed_main_of_origin_content', 'latex_in_original_or_summarized_in_origin', 'summarized_in_origin', 'processed_main_of_relied_content', 'relied_notation_note_content', 'latex_in_original_or_summarized_in_relied', 'summarized_in_relied']:
        augmented_datapoint[key] = augment_text(datapoint[key], random_methods)

    return augmented_datapoint
    

# %% ../../nbs/07_machine_learning_45.notation_linking.ipynb 27
def prediction_by_model(
        origin_data: NotationNoteData,
        relied_data: NotationNoteData,
        pipeline: Union[TextClassificationPipeline, SentenceTransformer],
        as_single_float: bool = True, # If `True`, return a float score of how likely it is that origin should link to relied.
        threshold: float = 0.5, # The threshold for determining whether origin should link to relied; should be a value between 0.0 and 1.0. A prediction exceeding this threshold should correspond to origin linking to relied. Ideally, this argument should be specified if `pipeline` is a `SentenceTransformer`
        ) -> Union[float, dict[Literal['label', 'score'], Union[bool, float]]]: # A float score between 0.0 and 1.0 of how likely it is that origin should link to relied (0.0 means unlikely, 1.0 means likely) or a dict consisting of whether origin should link to relied, given `threshold`, as well as the score of how likely the model thinks that origin should link to relied (0.0 means unlikely, 1.0 means likely).
    r"""
    Predict whether a notation note depends on the notation
    summarized by another notation note.

    See also `prediction_by_model_via_datapoint` for an alternative
    function for predictions.
    """
    if isinstance(pipeline, TextClassificationPipeline):
        data_point: NotationLinkingDataPoint = notation_note_data_pair_to_data_point(
            origin_data, relied_data)

        input = text_from_data_point(data_point)
        # Of the form {'label': 'LABEL_0' or 'LABEL_1', 'score': 0.5000}
        pred = pipeline(input)[0] 
        # LABEL_1 is for `True`, i.e. when the origin note ought to link to the relied note
        # and LABEL_0 is for `False`, i.e. when the origin note should not link to the relied note
        if pred['label'] == 'LABEL_1':
            pos_score = pred['score']
        else:
            pos_score = 1.0 - pred['score']

        if as_single_float:
            return pos_score
        else:
            # TODO: fix the following to account for threshold
            return {'label': pos_score >= threshold, 'score': pos_score}
    else:
        origin_text = text_from_note_data(origin_data)
        relied_text = text_from_note_data(relied_data)
        origin_embedding = pipeline.encode(origin_text)
        relied_embedding = pipeline.encode(relied_text)
        similarity = 1 - cosine(origin_embedding, relied_embedding)
        if as_single_float:
            return similarity
        else:
            return {'label': similarity >= threshold, 'score': similarity}


# %% ../../nbs/07_machine_learning_45.notation_linking.ipynb 29
# TODO: test
def rank_notat_notes_to_potentially_link_to(
        origin_data: NotationNoteData,
        relied_data_list: list[NotationNoteData],
        pipeline: Union[TextClassificationPipeline, SentenceTransformer],
        threshold: float = 0.5
        ) -> list[tuple[NotationNoteData, float]]:
    """
    Return a list of notation notes that the notation note represented by `origin_data` should
    link to in decreasing order of likelihood.
    """
    ranked_data_list: list[tuple[NotationNoteData, float]] = []
    for relied_data in relied_data_list:
        relevance_score = prediction_by_model(
            origin_data,
            relied_data,
            pipeline,
            as_single_float=True)
        if relevance_score >= threshold:
            ranked_data_list.append((relied_data, relevance_score))
    return sorted(ranked_data_list, key=lambda x: x[1], reverse=True)

# %% ../../nbs/07_machine_learning_45.notation_linking.ipynb 30
def _origin_notation_note_already_has_link_to_relied(
        relied_notation_note: VaultNote,
        origin_parsed: Union[tuple, None],
        ) -> bool:
    r"""
    Return `True` if `relied_notation_note is determined to be linked by
    `origin_notation_note` based on the contents of `origin_parsed`, which
    is the output of `parse_notation_note` appleid to `origin_notation_note`.

    This is a helper function to 
    `automatically_add_bulleted_link_to_other_notation_note`.
    """
    for _, linked_note_name in origin_parsed[4]:
        if linked_note_name == relied_notation_note.name:
            return True
    return False


def _add_notation_link(
        origin_notation_note: VaultNote,
        relied_notation_note: VaultNote,
        relied_parsed: tuple,
        ) -> None:
    r"""
    Add a link in `origin_notation_note` to `relied_notation_note`
    and add the tag `_auto/notation_notes_linked` to `origin_notation_note`.
    """
    if not relied_parsed:
        relied_parsed = parse_notation_note(
            relied_notation_note, relied_notation_note.vault)
    mf = MarkdownFile.from_vault_note(origin_notation_note)
    mf.add_tags('_auto/notation_notes_linked',
                enquote_entries_in_metadata_fields=['latex_in_original'])
    bullet = f'- [{relied_parsed[1]}]({relied_notation_note.name}.md)'
    mf.add_line_to_end(
        {'line': bullet,
         'type': MarkdownLineEnum.UNORDERED_LIST})
    mf.write(origin_notation_note)

# %% ../../nbs/07_machine_learning_45.notation_linking.ipynb 31
def _add_link_to_notation_note_in_mf(
        mf: MarkdownFile,
        relied_data: NotationNoteData,
        vault: Path,
        only_add_links_to_notation_notes_with_confirmed_summaries: bool,
        origin_name: str,
        ) -> bool: # `True` if the link to the relied note is added; `False` otherwise.
    # relied_parsed = parse_notation_note(relied_note)
    """Helper function to `add_links_to_notation_note_via_data_point`"""
    if only_add_links_to_notation_notes_with_confirmed_summaries: 
        relied_note = VaultNote(vault, name=relied_data['notation_note_name'])
        relied_mf = MarkdownFile.from_vault_note(relied_note)
        meta = relied_mf.metadata()
        parsed = parse_notation_note(relied_note)
        summary_is_auto_generated = 'tags' in meta and ['_auto/notation_summary'] in meta['tags']
        summary_is_empty = not bool(str(parsed.main_content_markdown_file).strip())
        if summary_is_auto_generated or summary_is_empty:
            print(f'The notation linking pipeline predicts that the notation note named {origin_name} should link to {relied_data["notation_note_name"]}, which either has an auto-generated summary or an empty summary. The link will not be added.')
            return False

    bullet = f'- [{relied_data["summarized"]}]({relied_data["notation_note_name"]}.md)'
    mf.add_line_to_end(
        {'line': bullet,
        'type': MarkdownLineEnum.UNORDERED_LIST})
    return True

# %% ../../nbs/07_machine_learning_45.notation_linking.ipynb 32
def add_links_to_notation_note_via_data_point(
        origin_data: NotationNoteData,
        relied_data_list: list[NotationNoteData],
        pipeline: Union[TextClassificationPipeline, SentenceTransformer],
        # pipeline: transformers.pipelines.text_classification.TextClassificationPipeline,
        vault: Path, # The vault in which the notes are.
        threshold: float = 0.5, # The threshold for `pipeline`'s prediction of how likely it is that a relied notation note should be linked in order for the linking to actually happen.
        only_add_links_to_notation_notes_with_confirmed_summaries: bool = True # If `True`, and if `pipeline` determines that the origina note should link to a notation note with an autogenerated summary or no summary, then print a messaage about this, but do not add the link.
    ) -> list[str]: # The names of the notation notes added; the names of notation notes that are not added for one reason or another are not included in this list.
    """
    Add links for the notation notes in `relied_data_list` into the notation note represented
    by `origin_data` if `pipeline` predicts that thoes notation notes should be linked.
    """
    relied_data_to_be_linked: list[tuple[NotationNoteData, float]] = rank_notat_notes_to_potentially_link_to(
        origin_data, relied_data_list, pipeline, threshold)
    origin_notat_note = VaultNote(vault, name=origin_data['notation_note_name'])
    if not relied_data_to_be_linked:
        return []
    mf = MarkdownFile.from_vault_note(origin_notat_note)
    mf.add_tags('_auto/notation_notes_linked',
                enquote_entries_in_metadata_fields=['latex_in_original'])
    names_of_notation_notes_added: list[str] = []
    for relied_data, _ in relied_data_to_be_linked:
        if relied_data['notation_note_name'] == origin_data['notation_note_name']:
            continue
        added = _add_link_to_notation_note_in_mf(
            mf, relied_data, vault,
            only_add_links_to_notation_notes_with_confirmed_summaries,
            origin_data['notation_note_name'])
        if added:
            names_of_notation_notes_added.append(relied_data['notation_note_name'])
    mf.write(origin_notat_note)
    return names_of_notation_notes_added

# %% ../../nbs/07_machine_learning_45.notation_linking.ipynb 39
def _identify_note_type_and_setup(
        vault: PathLike,
        current_note: VaultNote
        ) -> tuple[VaultNote, bool]: # The main information note along with whether `current_note` is an information note.
    # Some tweaking to make sure that `current_note` exists
    rel_path = current_note.rel_path
    current_note = VaultNote(vault, rel_path)
    if not current_note.exists():
        print(fr'''
Note was determined not to exist.
The vault was {vault}.
The note name was {current_note.name}.
The note path was {rel_path}.''')
        sys.exit(0)

    if note_is_of_type(current_note, PersonalNoteTypeEnum.STANDARD_INFORMATION_NOTE):
        main_note = current_note
        current_note_is_info_note = True
        return main_note, current_note_is_info_note
    elif note_is_of_type(current_note, PersonalNoteTypeEnum.NOTATION_NOTE):
        notation_note = current_note 
        notat_note_parsed: NotationNoteParsed = parse_notation_note(notation_note)
        main_note = VaultNote(vault, name=notat_note_parsed.name_of_main_note)
        current_note_is_info_note = False
        return main_note, current_note_is_info_note
    else:
        print('note was neither an info note nor a notation note. The note path was {rel_path}.')
        sys.exit(0)



# %% ../../nbs/07_machine_learning_45.notation_linking.ipynb 40
def _info_notes_for_reference(
        reference_index_note: VaultNote,
        vault: PathLike) -> list[VaultNote]:
    info_notes: list[VaultNote] = notes_linked_in_notes_linked_in_note(
        reference_index_note, as_dict=False)
    info_notes = [
        note for note in info_notes if note.exists() and note_is_of_type(note, PersonalNoteTypeEnum.STANDARD_INFORMATION_NOTE)]
    return info_notes

def _notat_notes_introduced_by_info_notes(
        info_notes: list[VaultNote]) -> list[VaultNote]:
    notat_notes: list[VaultNote] = []
    for info_note in info_notes:
        notat_notes.extend(
            notation_notes_linked_in_see_also_section(
                info_note, info_note.vault))
    return notat_notes

# %% ../../nbs/07_machine_learning_45.notation_linking.ipynb 42
def _get_processed_content_of_info_notes(
        info_notes: list[VaultNote],
        vault: PathLike,
        ) -> dict[str, str]:
    info_notes_and_processed_content: dict[str, str] = {}
    for note in info_notes:
        try:
            info_notes_and_processed_content[note.name] = str(
                process_standard_information_note(MarkdownFile.from_vault_note(note), vault))
        except TypeError as e:
            print(f"An error occurred while trying to process the following note: {note.name}")
            print(e)
            info_notes_and_processed_content[note.name] = note.text()
    return info_notes_and_processed_content

def _get_notation_note_data(
        info_notes_and_processed_content: dict[str, str],
        notation_notes_and_parsed: dict[str, NotationNoteParsed],
        vault: PathLike,
        reference: str,
        ) -> dict[str, NotationNoteData]:

    notation_note_data: dict[str, NotationNoteData] = {}
    for notat_note_name, parsed in notation_notes_and_parsed.items():
        try:
            notation_note_data[notat_note_name] = notat_note_data_from_parsed_and_main_note_processed(
                notat_note_name,
                parsed,
                info_notes_and_processed_content[parsed.name_of_main_note],
                vault,
                reference)
        except Exception as e:
            print(f"An error occurred while trying to parse and process the following note: {notat_note_name}")
            print(e)
    return notation_note_data


# %% ../../nbs/07_machine_learning_45.notation_linking.ipynb 43
def count_notat_note_links(
        notation_notes_and_parsed: dict[str, NotationNoteData]
        ) -> dict[str, int]:
    link_counts: dict[str, int] = {} # Keys: names of notation notes, values: the number of times the notation note is linked to by another notation note.
    for _, parsed in notation_notes_and_parsed.items():
        for _, linked_notat_note_name in parsed.linked_notation_notes:
            if linked_notat_note_name.endswith('.md'):
                linked_notat_note_name = linked_notat_note_name[:-3]
            if linked_notat_note_name not in link_counts:
                link_counts[linked_notat_note_name] = 1
            else:
                link_counts[linked_notat_note_name] += 1
    return link_counts

# %% ../../nbs/07_machine_learning_45.notation_linking.ipynb 44
def _notat_note_names_linked_by_notat_notes_in_info_note(
        info_note: VaultNote,
        notation_notes_and_parsed: dict[str, NotationNoteParsed],
        ) -> list[str]:
    notat_notes_in_info_note: list[VaultNote] = notation_notes_linked_in_see_also_section(
        info_note, info_note.vault)
    notat_notes_linked_by_notat_notes_in_info_notes: set[str] = set()
    for notat_note in notat_notes_in_info_note:
        linked_data = notation_notes_and_parsed[notat_note.name].linked_notation_notes
        print(linked_data)
        for _, linked_notat_note_name in linked_data:
            if linked_notat_note_name.endswith('.md'):
                linked_notat_note_name = linked_notat_note_name[:-3]
            notat_notes_linked_by_notat_notes_in_info_notes.add(linked_notat_note_name)
    return list(notat_notes_linked_by_notat_notes_in_info_notes)

# %% ../../nbs/07_machine_learning_45.notation_linking.ipynb 46
def _get_preceding_info_notes_in_section(
        index_note_for_section: VaultNote,
        info_note_name: str, # The name of the info note for which the preceding info notes in `index_note_for_section` should be found,
        vault: PathLike,
        ) -> list[VaultNote]:
    info_notes: list[VaultNote] = notes_linked_in_note(index_note_for_section, as_dict=False)
    preceding_info_notes: list[VaultNote] = []

    for other_info_note in info_notes:
        if other_info_note.name == info_note_name:
            break
        try:
            mf = MarkdownFile.from_vault_note(other_info_note)
        except NotePathIsNotIdentifiedError as e:
            # other_info_note = VaultNote(other_info_note.vault, name=other_info_note.name, update_cache=True)
            other_info_note = VaultNote(vault, name=other_info_note.name, update_cache=True)
            mf = MarkdownFile.from_vault_note(other_info_note)
        except Exception as e:
            continue
        meta = mf.metadata()
        if meta is not None and 'tags' in meta and (
            '_meta/definition' in meta['tags'] or
            '_meta/notation' in meta['tags'] or
            '_auto/_meta/definition' in meta['tags'] or
            '_auto/_meta/notation' in meta['tags']):
                preceding_info_notes.append(other_info_note)
    return preceding_info_notes

# %% ../../nbs/07_machine_learning_45.notation_linking.ipynb 47
def _get_preceding_notation_note_names(
        preceding_info_notes: list[VaultNote],
        vault: PathLike,
        ) -> list[str]:
        # Get the most linked notation notes from all the preceding info notes except for the last three.
    preceding_notation_notes: list[str] = []
    for preceding_info_note in preceding_info_notes[:-3]:
        try:
            notat_notes_in_info_note = notation_notes_linked_in_see_also_section(
                preceding_info_note, preceding_info_note.vault)
            preceding_notation_notes.extend([note.name for note in notat_notes_in_info_note])
        except NotePathIsNotIdentifiedError as e:
            preceding_info_note = VaultNote(vault, name=preceding_info_note.name, update_cache=True)
            notat_notes_in_info_note = notation_notes_linked_in_see_also_section(
                preceding_info_note, preceding_info_note.vault)
            preceding_notation_notes.extend([note.name for note in notat_notes_in_info_note])
    return preceding_notation_notes

# %% ../../nbs/07_machine_learning_45.notation_linking.ipynb 48
def _filter_preceding_notation_notes(
        preceding_notation_notes: list[str],
        notation_notes_and_parsed: dict[str, NotationNoteParsed],
        ) -> list[str]:
    preceding_notation_note_link_counts: dict[str, int] = {
        name: 0 for name in preceding_notation_notes}

    for _, parsed in notation_notes_and_parsed.items():
        for _, linked_notat_note_name in parsed.linked_notation_notes:
            if linked_notat_note_name.endswith('.md'):
                linked_notat_note_name = linked_notat_note_name[:-3]
            if linked_notat_note_name in preceding_notation_note_link_counts:
                preceding_notation_note_link_counts[linked_notat_note_name] += 1

    return get_top_counted_items(preceding_notation_note_link_counts, 0.2)

# %% ../../nbs/07_machine_learning_45.notation_linking.ipynb 49
def _get_most_recent_preceding_notation_notes(
        preceding_info_notes: list[VaultNote]
        ) -> list[str]:
    most_recent_preceding_notation_notes: list[str] = []
    for preceding_info_note in preceding_info_notes[-3:]:
        notat_notes_in_info_note = notation_notes_linked_in_see_also_section(
            preceding_info_note, preceding_info_note.vault)
        most_recent_preceding_notation_notes.extend([note.name for note in notat_notes_in_info_note])
    return most_recent_preceding_notation_notes

# %% ../../nbs/07_machine_learning_45.notation_linking.ipynb 51
def _get_notat_notes_embedded_in_info_note(
        info_note: VaultNote,
        notation_note_data: dict[str, NotationNoteData],
        ) -> list[str]: 
    # Get notation notes embedded in info note
    info_note_text = info_note.text()
    link_ranges = link_ranges_in_text(info_note_text)
    notation_notes_embedded_in_info_note: list[str] = []
    for start, end in link_ranges:
        link = ObsidianLink.from_text(info_note_text[start:end])
        if link.is_embedded:
            if link.file_name in notation_note_data:
                notation_notes_embedded_in_info_note.append(link.file_name)
    return notation_notes_embedded_in_info_note

# %% ../../nbs/07_machine_learning_45.notation_linking.ipynb 52
def _get_relied_data_to_consider(
        vault: PathLike,
        reference: str,
        all_notes_to_consider_to_link: set[str],
        notation_note_data: dict[str, NotationNoteData],
        notation_notes_and_parsed: dict[str, NotationNoteParsed],
        info_notes_and_processed_content: dict[str, str],
        ) -> list[NotationNoteData]:
    relied_data_to_consider: list[NotationNoteData] = []
    for note_name in all_notes_to_consider_to_link:
        # If the following happenes, then it may be the case that we are working in a vault inside a vault, and notation_notes_and_parsed and notation_note_data do not contain the data for notation notes in other subvaults.
        # Try to add the data for note_name to notation_notes_and_parsed and notation_note_data:
        if note_name in notation_note_data:
            relied_data_to_consider.append(notation_note_data[note_name])
            continue
        notat_note = VaultNote(vault, name=note_name)
        if not notat_note.exists():
            continue
        parsed = parse_notation_note(notat_note)
        notation_notes_and_parsed[note_name] = parsed
        notation_note_data[note_name] = notat_note_data_from_parsed_and_main_note_processed(
            note_name,
            parsed,
            info_notes_and_processed_content[parsed.name_of_main_note],
            vault,
            reference)
        relied_data_to_consider.append(notation_note_data[note_name])
    return relied_data_to_consider

# %% ../../nbs/07_machine_learning_45.notation_linking.ipynb 53
def _get_notat_note_names_to_add_links_to(
        current_note: VaultNote,
        current_note_is_info_note: bool,
        notat_notes_in_info_note: list[str],
        notation_notes_and_parsed: dict[str, NotationNoteParsed],
        # notation_note: Optional[VaultNote], # The current/notation note if `current_note_is_info_note` is `True`
        ) -> list[str]:

    if current_note_is_info_note:
        notat_note_names_to_add_links_to: list[str] = [] 
        for name in notat_notes_in_info_note:
            parsed_data: NotationNoteParsed = notation_notes_and_parsed[name]
            has_auto_tag = (
                parsed_data.yaml_frontmatter_meta is not None
                and 'tags' in parsed_data.yaml_frontmatter_meta
                and '_auto/notation_notes_linked' in parsed_data.yaml_frontmatter_meta['tags'])
            has_linked_notation_notes = bool(parsed_data.linked_notation_notes)
            if has_auto_tag or not has_linked_notation_notes:
                notat_note_names_to_add_links_to.append(name)
        # filter out things from notat note names to add links to if they do not contain the _auto tag and they already have some linked notation notes.
    else:
        notat_note_names_to_add_links_to: list[str] = [current_note.name]
    return notat_note_names_to_add_links_to

# %% ../../nbs/07_machine_learning_45.notation_linking.ipynb 54
def _add_links_to_sieved_notat_notes(
        vault: PathLike,
        notat_note_names_to_add_links_to: list[str],
        notation_note_data: dict[str, NotationNoteData],
        notation_notes_and_parsed: dict[str, NotationNoteParsed],
        relied_data_to_consider: list[NotationNoteData],
        other_data: list[NotationNoteData],
        notation_linking_rag_sentence_transformer,
        notation_linking_rag_classifier,
        ):
    for notat_note_name in notat_note_names_to_add_links_to:
        if notat_note_name not in notation_notes_and_parsed:
            # print(notation_notes_and_parsed)
            print(notat_note_name)
            continue
        try:
            # print(notat_note_name)
            already_linked_in_notat_notes: list[str] = [
                name for _, name in notation_notes_and_parsed[notat_note_name].linked_notation_notes]
            already_linked_in_notat_notes: list[str] = [
                name if not name.endswith('.md') else name[:-3] for name in already_linked_in_notat_notes]
            relied_data_to_consider_for_notat_note: list[NotationNoteData] = [
                relied_data for relied_data in relied_data_to_consider if relied_data['notation_note_name'] not in already_linked_in_notat_notes
                ]

            # First use the sentence transformers to quickly determine
            # which links the sentence transformers is confident
            # about adding which links to add filter out  

            # 1. among `relied_data_to_consider_for_notat_note`, add
            # the link if sentence transformers has at least .9
            # amount of confidence.

            added_links_1: list[str] = add_links_to_notation_note_via_data_point(
                notation_note_data[notat_note_name],
                relied_data_to_consider_for_notat_note,
                notation_linking_rag_sentence_transformer,
                vault,
                threshold = 0.9)

            # 2. consider other_data, also using sentence transformers
            # which is much higher confidence threshold
            added_links_2: list[str] = add_links_to_notation_note_via_data_point(
                notation_note_data[notat_note_name],
                other_data,
                notation_linking_rag_sentence_transformer,
                vault,
                threshold = 0.99)

            added_links: set[str] = set(added_links_1)
            added_links.update(added_links_2)

            # 3. Use the classifier model to properly add others
            # sift out the candidates among the ones that were
            # added as links by the sentence transformers
            relied_data_to_consider_for_notat_note = [
                relied_data for relied_data in relied_data_to_consider if relied_data['notation_note_name'] not in added_links
                ]
            add_links_to_notation_note_via_data_point(
                notation_note_data[notat_note_name],
                relied_data_to_consider_for_notat_note,
                notation_linking_rag_classifier,
                vault)



        except Exception as e:
            print(f'{notat_note_name} raised an exception')
            print(e)
            raise(e)

# %% ../../nbs/07_machine_learning_45.notation_linking.ipynb 55
def sieve_then_add_links_to_notation_notes(
        vault: PathLike,
        current_note: VaultNote, # Either an info note that introduces the notation notes in which to add links to other notation notes or a notation note in which to add links to.
        reference_name: str, 
        notation_linking_rag_sentence_transformer,
        notation_linking_rag_classifier,
        ) -> None:

    main_note, current_note_is_info_note = _identify_note_type_and_setup(
        vault, current_note)
    info_note_name = main_note.name
    index_note_for_section = index_note_of_note(main_note)
    index_note = index_note_of_note(index_note_for_section)
    reference_index_note = VaultNote(vault, name=index_note.name)
    reference = reference_index_note.name[7:]
    vault = reference_index_note.vault

    info_notes: list[VaultNote] = _info_notes_for_reference(
        reference_index_note, vault)
    notat_notes: list[VaultNote] = _notat_notes_introduced_by_info_notes(info_notes)
    notation_notes_and_parsed: dict[str, NotationNoteParsed] = {
    notat_note.name: parse_notation_note(notat_note) for notat_note in notat_notes}
    info_notes_and_processed_content = _get_processed_content_of_info_notes(
        info_notes, vault)




        
    notation_note_data: dict[str, NotationNoteData] = _get_notation_note_data(
        info_notes_and_processed_content, notation_notes_and_parsed, vault,
        reference)

    link_counts = count_notat_note_links(notation_notes_and_parsed)
    top_linked_note_names = get_top_counted_items(link_counts, 0.05, 5)
    preceding_info_notes: list[VaultNote] = _get_preceding_info_notes_in_section(
        index_note_for_section, info_note_name, vault)
    preceding_notation_notes = _get_preceding_notation_note_names(
        preceding_info_notes, vault)
    top_linked_notat_note_names_in_preceding_info_notes = _filter_preceding_notation_notes(
        preceding_notation_notes, notation_notes_and_parsed)
    most_recent_preceding_notation_notes = _get_most_recent_preceding_notation_notes(
        preceding_info_notes)

    # Get the other notation notes linked in the same info note.
    info_note = VaultNote(vault, name=info_note_name)
    notat_notes_in_info_note: list[VaultNote] = notation_notes_linked_in_see_also_section(info_note, info_note.vault)
    notat_notes_in_info_note: list[str] = [note.name for note in notat_notes_in_info_note] 
    notation_notes_embedded_in_info_note = _get_notat_notes_embedded_in_info_note(
        info_note, notation_note_data)

    all_notes_to_consider_to_link: set[str] = set()
    all_notes_to_consider_to_link.update(top_linked_note_names)
    all_notes_to_consider_to_link.update(top_linked_notat_note_names_in_preceding_info_notes)
    all_notes_to_consider_to_link.update(notat_notes_in_info_note)
    all_notes_to_consider_to_link.update(most_recent_preceding_notation_notes)
    all_notes_to_consider_to_link.update(notation_notes_embedded_in_info_note)

    relied_data_to_consider = _get_relied_data_to_consider(
        vault, reference, all_notes_to_consider_to_link, notation_note_data,
        notation_notes_and_parsed, info_notes_and_processed_content)
    note_names_for_relied_data_to_consider: set[str] = set(
        [relied_data['notation_note_name'] for relied_data in relied_data_to_consider])
    # other_data consists the data for notation notes essentially outside
    # of relied_data_to_consider; the sentence transformer will consider
    # whether to link these data, which is fast; the threshold for whether
    # to link these data is much higher.
    other_data: list[NotationNoteData] = [
        data for note_name, data in notation_note_data.items() if note_name not in note_names_for_relied_data_to_consider]
    notat_note_names_to_add_links_to: list[str] = _get_notat_note_names_to_add_links_to(
        current_note, current_note_is_info_note,
        notat_notes_in_info_note, notation_notes_and_parsed)
        
    _add_links_to_sieved_notat_notes(
        vault, notat_note_names_to_add_links_to, notation_note_data, notation_notes_and_parsed,
        relied_data_to_consider, other_data, notation_linking_rag_sentence_transformer,
        notation_linking_rag_classifier)

