# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/46_helper.files_and_folders.ipynb.

# %% auto 0
__all__ = ['existing_path', 'file_existence_test', 'path_name_no_ext', 'path_no_ext', 'text_from_file', 'files_of_format_sorted',
           'file_is_compressed', 'uncompress_file']

# %% ../../nbs/46_helper.files_and_folders.ipynb 1
import errno
import gzip
import lzma
import os
from os import PathLike
from pathlib import Path
import platform
import tarfile
from typing import Optional
import zipfile
import bz2

from deprecated import deprecated
import glob
from natsort import natsorted

# %% ../../nbs/46_helper.files_and_folders.ipynb 5
def existing_path(
        path: PathLike,  # A file or directory path. Either absolute or relative to `relative_to`.
        relative_to: Optional[PathLike] = None  # Path to the directory that `file` is relative to.  If `None`, then `path` is an absolute path.
        ) -> Path: # The path formed by `relative_to` adjoined with `path`.  Defaults to `None`
    """Returns a path relative to a specified path as an absolute path
    that exists.

    **Raises**

    - `FileNotFoundError`
        - If `relative_to` is not `None` but does not exist, or if
        `file` does not exist.
    - `ValueError`
        - If `relative_to` is not `None` and yet not an absolute path, or
        if `relative_to` is `None` at yet `path` is not an absolute path.
    
    **Notes**
    - This function may add the string `'\\\\?\\'` in front, which identifies
    very long paths.
    """
    if relative_to is not None:
        if not os.path.isabs(relative_to):
            raise ValueError(
                f'The parameter `relative_to` is expected to be an'
                f' absolute path, but it is not: {relative_to}')
        if not os.path.exists(relative_to):
            raise FileNotFoundError(
                errno.ENOENT, os.strerror(errno.ENOENT), relative_to)
        path = Path(relative_to) / path
    elif not os.path.isabs(path):
        raise ValueError(
            f'The parameter `path` is expected to be an absolute path,'
            f' but it is not: {path}')
    if not os.path.exists(path) and platform.system() == 'Windows':
        path = f'\\\\?\\{str(path)}'  # For long file names
    if not os.path.exists(path):
        raise FileNotFoundError(
            errno.ENOENT, os.strerror(errno.ENOENT), path)
    return Path(path)


@deprecated(reason="The function has been renamed to `existing_path`")
def file_existence_test(
        path: PathLike,  # A file or directory path. Either absolute or relative to `relative_to`.
        relative_to: Optional[PathLike] = None  # Path to the directory that `file` is relative to.  If `None`, then `path` is an absolute path.
        ) -> Path: # The path formed by `relative_to` adjoined with `path`.  Defaults to `None`
    """
    **Deprecated. Use `existing_path` instead.**
    
    Returns a path relative to a specified path as an absolute path
    that exists.

    **Raises**
    - `FileNotFoundError`
        - If `relative_to` is not `None` but does not exist, or if
        `file` does not exist.
    
    **Notes**
    - This function may add the string `'\\\\?\\'` in front, which identifies
    very long paths.
    """
    if relative_to is not None:
        if not os.path.isabs(relative_to):
            raise ValueError(
                f'The parameter `relative_to` is expected to be an'
                f' absolute path, but it is not: {relative_to}')
        if not os.path.exists(relative_to):
            raise FileNotFoundError(
                errno.ENOENT, os.strerror(errno.ENOENT), relative_to)
        path = Path(relative_to) / path
    elif not os.path.isabs(path):
        raise ValueError(
            f'The parmaeter `path` is expected to be an absolute path,'
            f' but it is not: {path}')
    if not os.path.exists(path) and platform.system() == 'Windows':
        path = f'\\\\?\\{str(path)}'  # For long file names
    if not os.path.exists(path):
        raise FileNotFoundError(
            errno.ENOENT, os.strerror(errno.ENOENT), path)
    return Path(path)

# %% ../../nbs/46_helper.files_and_folders.ipynb 18
def path_name_no_ext(
        path: PathLike # The path of the file or directory. This may be absolute or relative to any directory.
        ) -> str: # The name of the file or directory without the extension.
    """Return the name of a file or directory from its path without the
    extension.
    
    The file or directory does not have to exist.
    """
    name_with_extension = os.path.basename(path)
    return os.path.splitext(name_with_extension)[0]

# %% ../../nbs/46_helper.files_and_folders.ipynb 25
def path_no_ext(
    path: PathLike # The path of the file or directory. This may be absolute or relative to any directory.
    ) -> str: # The path of the file or directory without the extension. If `path` is a path to a directory, then the output should be essentially the same as `path`.
    """Returns the path of a file or directory without the extension.
    
    The file or directory does not have to exist.
    """
    return os.path.splitext(str(path))[0]

# %% ../../nbs/46_helper.files_and_folders.ipynb 29
def text_from_file(
        path: PathLike, # The absolute path of the file.
        encoding: str = 'utf8' # The encoding of the file to be read. Defaults to `'utf8'`.
        ) -> str: # The entire text from a file
    """Return the entire text from a file.

    Assuems that the file can be encoded in the specified `encoding`
    """
    with open(path, 'r', encoding=encoding) as file:
        text = file.read()
        file.close()
    return text

# %% ../../nbs/46_helper.files_and_folders.ipynb 32
def files_of_format_sorted(
        directory: PathLike, # The directory in which to find the files
        extension: str = 'txt' # Extension of the files to find. Defaults to 'txt'.
        ) -> list[str]:
    """Return a list of path str of files in the directory (but not subdirectories)
    sorted via `natsort`.
    """
    return natsorted(glob.glob(str(Path(directory) / f'*.{extension}')))

# %% ../../nbs/46_helper.files_and_folders.ipynb 36
def file_is_compressed(
        filename: str
        ):
    # Define a set of common compressed file extensions
    compressed_extensions = {
        '.zip',
        '.gz',
        '.tar',
        '.tar.gz',
        '.tgz',
        '.bz2',
        '.xz',
        '.7z',
        '.rar',
        '.z',
    }

    # Get the file extension
    _, file_extension = os.path.splitext(filename)

    # Check if the file extension is in the set of compressed extensions
    return file_extension.lower() in compressed_extensions

# %% ../../nbs/46_helper.files_and_folders.ipynb 38
def uncompress_file(file_path):
    # Check the file extension
    file_path = str(file_path)
    _, file_extension = os.path.splitext(file_path)
    uncompressed_files = []

    try:
        if file_extension == '.zip':
            with zipfile.ZipFile(file_path, 'r') as zip_ref:
                zip_ref.extractall(os.path.dirname(file_path))
                uncompressed_files = [os.path.join(os.path.dirname(file_path), name) for name in zip_ref.namelist()]
            print(f"Uncompressed {file_path} into {os.path.dirname(file_path)}")

        elif file_extension in ['.tar', '.tar.gz', '.tgz', '.tar.bz2', '.tbz']:
            with tarfile.open(file_path, 'r:*') as tar_ref:
                tar_ref.extractall(os.path.dirname(file_path))
                uncompressed_files = [os.path.join(os.path.dirname(file_path), name) for name in tar_ref.getnames()]
            print(f"Uncompressed {file_path} into {os.path.dirname(file_path)}")

        elif file_extension == '.gz':
            output_file_path = file_path[:-3]  # Remove the .gz extension
            with gzip.open(file_path, 'rb') as gz_file:
                with open(output_file_path, 'wb') as out_file:
                    out_file.write(gz_file.read())
            uncompressed_files.append(output_file_path)
            print(f"Uncompressed {file_path} into {output_file_path}")

        elif file_extension == '.bz2':
            output_file_path = file_path[:-4]  # Remove the .bz2 extension
            with bz2.open(file_path, 'rb') as bz2_file:
                with open(output_file_path, 'wb') as out_file:
                    out_file.write(bz2_file.read())
            uncompressed_files.append(output_file_path)
            print(f"Uncompressed {file_path} into {output_file_path}")

        elif file_extension == '.xz':
            output_file_path = file_path[:-3]  # Remove the .xz extension
            with lzma.open(file_path, 'rb') as xz_file:
                with open(output_file_path, 'wb') as out_file:
                    out_file.write(xz_file.read())
            uncompressed_files.append(output_file_path)
            print(f"Uncompressed {file_path} into {output_file_path}")

        else:
            print(f"Unsupported file format: {file_extension}")

    except Exception as e:
        print(f"An error occurred while uncompressing {file_path}: {e}")

    return uncompressed_files
