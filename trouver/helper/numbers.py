# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/40_helper.numbers.ipynb.

# %% auto 0
__all__ = ['is_number', 'modify_int_by_at_most_at_most_offset', 'modify_int_by_at_most_at_most_value']

# %% ../../nbs/40_helper.numbers.ipynb 2
import random
from typing import Optional, Union

# %% ../../nbs/40_helper.numbers.ipynb 5
def is_number(
        x: Union[float, int, complex, str]
        ) -> bool:
    """Return `True` if the input `x` represents a number.
    
    This function is different from Python's built-in `is_numeric`
    function, which returns `True` when all characters of a string
    are digits.
    """
    if isinstance(x, (float, int, complex)):
        return True
    #For the case where string is None
    if x is None:
        return False
    if x and x[0] == '-': x = x[1:]
    return x.replace(".", "1", 1).isdigit()

# %% ../../nbs/40_helper.numbers.ipynb 7
def modify_int_by_at_most_at_most_offset(
        n: int,
        offset: float, # 1.0 means 100%
        upper_bound: Optional[int] = None, # inclusive upper bound; if the new number exceeds this value, then it is set to this value.
        lower_bound: Optional[int] = None, # inclusive lower bound; if the new number is less than this value, then it is set to this value.
        ) -> int:
    random_offset = random.uniform(-offset, offset)  # Random value in [-20%, +20%]
    new_value = int(n + random_offset)
    if upper_bound is not None:
        new_value = min(upper_bound, new_value)
    if lower_bound is not None:
        new_value = max(lower_bound, new_value)
    return new_value

# %% ../../nbs/40_helper.numbers.ipynb 9
def modify_int_by_at_most_at_most_value(
        n: int,
        value: int, 
        upper_bound: Optional[int] = None, # inclusive upper bound; if the new number exceeds this value, then it is set to this value.
        lower_bound: Optional[int] = None, # inclusive lower bound; if the new number is less than this value, then it is set to this value.
        ) -> int:
    random_offset = random.randint(-value, value)
    new_value = n + random_offset
    if upper_bound is not None:
        new_value = min(upper_bound, new_value)
    if lower_bound is not None:
        new_value = max(lower_bound, new_value)
    return new_value
