"""Latex functions for modifying latex text, mainly for data augmentation"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../../nbs/01_helper_28.latex.augment.ipynb.

# %% auto 0
__all__ = ['FONT_STYLE_COMMANDS', 'UNCOMMON_FONT_STYLE_COMMANDS', 'GREEK_LETTERS', 'modify_at_random',
           'remove_font_styles_at_random', 'change_font_styles_at_random', 'change_greek_letters_at_random',
           'random_char_modification', 'dollar_sign_manipulation', 'remove_math_keywords', 'random_word_removal',
           'random_latex_command_removal', 'push_dollar_signs', 'push_dollar_sign', 'remove_split_commands',
           'augment_text', 'choose_modification_methods_at_random']

# %% ../../../nbs/01_helper_28.latex.augment.ipynb 2
import random
import re
import string
from typing import Callable, List, Optional, Union


# %% ../../../nbs/01_helper_28.latex.augment.ipynb 7
FONT_STYLE_COMMANDS = [
    "mathscr",
    "mathcal",
    "mathfrak",
    "mathbb",
    "mathbf",
    "mathrm",
    "operatorname",
    "text",
    ]
UNCOMMON_FONT_STYLE_COMMANDS = [
    "mathit",
    "mathsf",
    "mathtt",
]
# COMMON_FONT_STYLE_TYPOS = {
#     "mathscr": {"mathcal", "mathfrak"},
#     "mathcal": {"mathscr"},
#     "mathrm": {"operatorname"},
#     "mathrmfrak": {"mathcal", "mathbf"}
# }


def modify_at_random(
        latex_string: str, # A latex str, surrounded by dollar signs (either single or double) as necessary.
        pattern: Union[str,re.Pattern],
        chance: float, # The chance that each change is performed
        replace_func: Callable[[re.Match, float], str],
        seed: Optional[int] = None
    ) -> str:
    # Set the random seed if provided
    if seed is not None:
        random.seed(seed)
    result = re.sub(pattern, lambda x: replace_func(x, chance), latex_string)
    return result



# %% ../../../nbs/01_helper_28.latex.augment.ipynb 9
def remove_font_styles_at_random(
        latex_string: str, # A latex str, surrounded by dollar signs (either single or double) as necessary.
        p: float = 0.05, # The chance that each font styling comand is removed
        seed: Optional[int] = None
        ) -> str: 
    """Randomly remove font style commands at random from `latex_string`.
    """
    # Combine all font style commands
    all_commands = FONT_STYLE_COMMANDS # + UNCOMMON_FONT_STYLE_COMMANDS
    # Create a regex pattern to match all font style commands
    pattern = r'\\(' + '|'.join(all_commands) + r')\s*\{([^{}]*(?:\{[^{}]*\}[^{}]*)*)\}'
    def replace_func(match, p: float):
        # Randomly decide whether to remove the command
        if random.random() < p:
            # If removed, return only the content inside the braces
            return match.group(2)
        else:
            # If not removed, return the original match
            return match.group(0)
    return modify_at_random(latex_string, pattern, p, replace_func, seed)

# %% ../../../nbs/01_helper_28.latex.augment.ipynb 12
def change_font_styles_at_random(
        latex_string: str,
        p: float = 0.1,
        seed: Optional[int] = None
        ) -> str:
    """Randomly change font style commands in `latex_string`."""
    all_commands = FONT_STYLE_COMMANDS # + UNCOMMON_FONT_STYLE_COMMANDS
    pattern = r'\\(' + '|'.join(all_commands) + r')\s*\{([^{}]*(?:\{[^{}]*\}[^{}]*)*)\}'
    def replace_func(match, p: float):
            if random.random() < p:
                current_command = match.group(1)
                new_command = random.choice([cmd for cmd in all_commands if cmd != current_command])
                return f"\\{new_command}{{{match.group(2)}}}"
            return match.group(0)
    return modify_at_random(latex_string, pattern, p, replace_func, seed)

# %% ../../../nbs/01_helper_28.latex.augment.ipynb 14
# List of Greek letters in LaTeX
GREEK_LETTERS = [
    'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 
    'nu', 'xi', 'omicron', 'pi', 'rho', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega',
    'Gamma', 'Delta', 'Theta', 'Lambda', 'Xi', 'Pi', 'Sigma', 'Upsilon', 'Phi', 'Psi', 'Omega'
]

def change_greek_letters_at_random(
        latex_string: str,
        p: float = 0.05
) -> str:
    """Randomly change Greek letters in `latex_string`."""
    def replace_func(match, p: float):
        if random.random() < p:
            current_letter = match.group(1)
            new_letter = random.choice([l for l in GREEK_LETTERS if l != current_letter])
            return f"\\{new_letter}"
        return match.group(0)
    # Pattern to match Greek letters
    pattern = r'\\(' + '|'.join(GREEK_LETTERS) + r')\b'
    # Apply the replacement
    result = re.sub(pattern, lambda x: replace_func(x, p), latex_string)
    return result


# %% ../../../nbs/01_helper_28.latex.augment.ipynb 16
# def push_dollar_signs_surrounding_latex(
#         latex_string: str, # A latex str, surrounded by dollar signs (either single or double) as necessary.
#         remove_pushed_out_font_style_command: bool = True
#         ) -> str:
#     """
#     Modify `latex_string` so that in effect, dollar signs are 
#     """
#     return ""

# %% ../../../nbs/01_helper_28.latex.augment.ipynb 18
def random_char_modification(text, p=0.05):
    """
    Randomly change characters in `text`.
    """
    chars = list(text)
    all_chars = string.ascii_letters + string.digits + string.punctuation + ' '
    for i in range(len(chars)):
        if random.random() < p:
            action = random.choice(['delete', 'add', 'modify'])
            if action == 'delete':
                chars[i] = ''
            elif action == 'add':
                chars.insert(i, random.choice(all_chars))
            else:
                chars[i] = random.choice(all_chars)
    return ''.join(chars)

# %% ../../../nbs/01_helper_28.latex.augment.ipynb 20
# def dollar_sign_manipulation(text, p=0.05):
#     """
#     Either delete or move dollar signs (which are usually there for latex math mode) from `text`,
#     while preserving all whitespace characters.
#     """
#     # Split the text into tokens, preserving whitespace
#     tokens = re.split(r'(\s+)', text)
    
#     # Find indices of non-whitespace tokens containing '$'
#     dollar_indices = [i for i, token in enumerate(tokens) if '$' in token and not token.isspace()]
    
#     for i in dollar_indices:
#         if random.random() < p:
#             action = random.choice(['delete', 'move'])
#             if action == 'delete':
#                 tokens[i] = tokens[i].replace('$', '')
#             else:
#                 if len(dollar_indices) > 1:
#                     # Find a new position for the dollar sign
#                     possible_positions = [pos for pos in dollar_indices if pos != i]
#                     new_pos = random.choice(possible_positions)
                    
#                     # Move the dollar sign
#                     tokens[new_pos] += '$'
#                     tokens[i] = tokens[i].replace('$', '')
#                 else:
#                     # If there's only one dollar sign, we can't move it, so we'll delete it instead
#                     tokens[i] = tokens[i].replace('$', '')

#     return ''.join(tokens)


# %% ../../../nbs/01_helper_28.latex.augment.ipynb 21
def dollar_sign_manipulation(text, p=0.05):
    """
    Either delete or move dollar signs from `text` while preserving whitespace.
    """
    tokens = re.split(r'(\s+)', text)
    # Tokens with '$' are inherently not whitespace, so we can skip the .isspace() check
    d_idxs = [i for i, t in enumerate(tokens) if '$' in t]
    
    for i in d_idxs:
        if random.random() < p:
            # Step 1: Always remove '$' from the current token (happens in both 'delete' and 'move')
            tokens[i] = tokens[i].replace('$', '')
            
            # Step 2: If we are "moving" (50% chance) and have a valid target, append '$' there
            # This replicates the original logic: Move = Remove from A + Add to B
            if len(d_idxs) > 1 and random.choice([True, False]):
                target = random.choice([j for j in d_idxs if j != i])
                tokens[target] += '$'

    return ''.join(tokens)


# %% ../../../nbs/01_helper_28.latex.augment.ipynb 23
def remove_math_keywords(text, p=0.05):
    """
    Remove all mentions of Definition/Theorem/Remark, etc.
    """
    keywords = r"(Definition|Remark|Proposition|Exercise|Example|Theorem|Lemma|Corollary)\s+\w+(\.\w+){1,3}"
    def random_remove(match):
        if random.random() < p:
            return ''
        else:
            return match.group(0)
    return re.sub(keywords, random_remove, text)


# %% ../../../nbs/01_helper_28.latex.augment.ipynb 24
def random_word_removal(text, p=0.05):
    """
    Randomly remove words while preserving all whitespace characters.
    """
    # Split the text into tokens, preserving whitespace
    tokens = re.split(r'(\s+)', text)
    
    # Process non-whitespace tokens
    result = []
    for token in tokens:
        if token.strip():  # If the token is not just whitespace
            if random.random() > p:
                result.append(token)
        else:
            result.append(token)  # Always keep whitespace tokens
    
    return ''.join(result)


# %% ../../../nbs/01_helper_28.latex.augment.ipynb 25
def random_latex_command_removal(text, p=0.1):
    """
    Randomly remove latex commands
    """
    return re.sub(r'\\[a-zA-Z]+(\{[^}]*\})?', lambda m: m.group(0) if random.random() > p else '', text)

# %% ../../../nbs/01_helper_28.latex.augment.ipynb 26
# TODO: this function, as implemented, is very buggy
def push_dollar_signs(
        latex: str,
        p: float = 0.1, # Push probability
        seed: int = None,
        return_indices_of_math_mode_content: bool = False # If `True`, additionally return a `list[tuple[int, int]]` of indices within the outputted `str` signifiying the location of what was essentially the content of the original math mode.
        ) -> tuple[str, list[tuple[int, int]]]:
    """
    Push dollar signs delimiting math mode into each other at random within a text.
    """
    
    if seed is not None:
        random.seed(seed)

    font_commands = FONT_STYLE_COMMANDS + UNCOMMON_FONT_STYLE_COMMANDS 
    font_commands = [rf'\{font_command}' for font_command in font_commands]
    
    # Find all single and double dollar sign positions
    dollar_positions = [(m.start(), m.end()) for m in re.finditer(r'\${1,2}', latex)]
    
    # Ensure we have an even number of dollar sign groups
    if len(dollar_positions) % 2 != 0:
        dollar_positions = dollar_positions[:-1]

    new_indices_of_math_mode_content: list[tuple[int, int]] = []
    for i in range(0, len(dollar_positions), 2):
        start, end = dollar_positions[i], dollar_positions[i+1]
        if random.random() >= p:
            continue
        # if random.random() < push_probability:
            # Decide which dollar sign group to push
        push_start = random.choice([True, False])
        
        if push_start:
            new_start = push_dollar_sign(latex, start[1], direction='right')
            dollar_length = start[1] - start[0]
            new_starting_part = latex[:start[0]]
            pushed_out_math_mode_part = remove_split_commands(latex[start[1]:new_start], font_commands).rstrip() + ' ' + '$'*dollar_length
            new_ending_part = latex[new_start:].lstrip()
            latex = new_starting_part + pushed_out_math_mode_part + new_ending_part 
            # latex = latex[:start[0]] + pushed_out_math_mode_part + latex[new_start:].lstrip()
            new_indices_of_math_mode_content.append(
                (start[0], start[0] + len(pushed_out_math_mode_part) + new_ending_part.index('$'*dollar_length) + dollar_length))
        else:
            new_end = push_dollar_sign(latex, end[0], direction='left')
            dollar_length = end[1] - end[0]
            new_starting_part = latex[:new_end].rstrip()
            pushed_out_math_mode_part = '$'*dollar_length + ' ' + remove_split_commands(latex[new_end:end[0]], font_commands).lstrip()
            new_ending_part = latex[end[1]:]
            latex = new_starting_part + pushed_out_math_mode_part + new_ending_part
            last_dollar_in_new_starting_part = new_starting_part.rindex('$'*dollar_length)
            new_indices_of_math_mode_content.append(
                # (start[0], start[0] + len(pushed_out_math_mode_part))
                (last_dollar_in_new_starting_part, len(new_starting_part) + len(pushed_out_math_mode_part))
                )
    
        # Update dollar positions for the next pair
        dollar_positions = [(m.start(), m.end()) for m in re.finditer(r'\${1,2}', latex)]

    if return_indices_of_math_mode_content:
        return latex, new_indices_of_math_mode_content
    else:
        return latex

def push_dollar_sign(latex: str, pos: int, direction: str) -> int:
    """Push the dollar sign in the specified direction to the next word boundary."""
    if direction == 'right':
        next_space = latex.find(' ', pos)
        if next_space == -1:
            return len(latex)
        next_non_space = next_space
        while next_non_space < len(latex) and latex[next_non_space].isspace():
            next_non_space += 1
        return next_non_space
    else:  # left
        prev_space = latex.rfind(' ', 0, pos)
        if prev_space == -1:
            return 0
        prev_non_space = prev_space
        while prev_non_space > 0 and latex[prev_non_space-1].isspace():
            prev_non_space -= 1
        return prev_non_space

def remove_split_commands(latex: str, commands: List[str]) -> str:
    """Remove font style commands from the latex string."""
    for cmd in commands:
        pattern = re.escape(cmd) + r'\s*\{([^}]*)\}'
        latex = re.sub(pattern, r'\1', latex)
    return latex

# %% ../../../nbs/01_helper_28.latex.augment.ipynb 36
#| export

# %% ../../../nbs/01_helper_28.latex.augment.ipynb 38
def augment_text(
        text: str,
        methods: list[Callable[[str], str]],
        ) -> str:
    """
    Augment `text` by applying modification methods.
    """
    for method in methods:
        text = method(text)
    return text

# %% ../../../nbs/01_helper_28.latex.augment.ipynb 39
# def add_typos(
#         latex_string: str, # A latex str, surrounded by dollar signs (either single or double) as necessary.
#         seed: Optional[int] = None
#         ) -> str: # A new str that is a modification of `latex_string` with "typos".

#     return ""



# %% ../../../nbs/01_helper_28.latex.augment.ipynb 40
def _create_method(method, p, scale):
    """
    Helper function to `choose_modification_methods_at_random`
    """
    return lambda x: method(x, p=p*scale)

# %% ../../../nbs/01_helper_28.latex.augment.ipynb 41
def choose_modification_methods_at_random(
        methods: list[tuple[Callable, float]],
        method_inclusion_chance = float, # The chance to include each method
        scale = float, # The amount by which to "scale" the method's tendency to modify the text.
        ) -> list[Callable[[str], str]]:
    random_methods: list[Callable[[str], str]] = []
    for method, p in methods:
        if random.random() < method_inclusion_chance:
            random_methods.append(_create_method(method, p, scale))
    return random_methods
