/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
__export(exports, {
  default: () => FastLinkEdit
});
var import_obsidian2 = __toModule(require("obsidian"));

// navigate.ts
function positionInRange(pos, range, include_from = true, include_to = true) {
  return positionComesBefore(range.from, pos, include_from) && positionComesBefore(pos, range.to, include_to);
}
function positionPairToRange(from, to) {
  const range = {
    from,
    to
  };
  return range;
}
function locPairToRange(from, to) {
  let f = locToEditorPosition(from);
  let t = locToEditorPosition(to);
  return positionPairToRange(f, t);
}
function positionComesBefore(pos, other, allowEqual = false) {
  if (allowEqual) {
    return pos.line < other.line || pos.line == other.line && pos.ch <= other.ch;
  } else {
    return pos.line < other.line || pos.line == other.line && pos.ch < other.ch;
  }
}
function positionComesBeforeLoc(pos, loc, allowEqual = false) {
  return positionComesBefore(pos, locToEditorPosition(loc), allowEqual);
}
function locToEditorPosition(loc) {
  const pos = {
    line: loc.line,
    ch: loc.col
  };
  return pos;
}
function getNextLinkIndex(pos, links, by = "start", reverse = false) {
  if (!links) {
    return -1;
  }
  let i = 0;
  if (!reverse) {
    while (i < links.length && !positionComesBeforeLoc(pos, links[i].position[by], false)) {
      i++;
    }
  } else {
    i = links.length - 1;
    while (-1 < i && positionComesBeforeLoc(pos, links[i].position[by], true)) {
      i--;
    }
  }
  if (-1 < i && i < links.length) {
    return i;
  } else {
    return -1;
  }
}
function getCurrentLinkIndex(pos, links) {
  if (!links) {
    return -1;
  }
  let i = getNextLinkIndex(pos, links);
  if (i == -1) {
    i = links.length - 1;
  } else {
    i--;
  }
  let range = locPairToRange(links[i].position.start, links[i].position.end);
  if (positionInRange(pos, range)) {
    return i;
  }
  i++;
  if (i >= links.length) {
    return -1;
  }
  range = locPairToRange(links[i].position.start, links[i].position.end);
  if (positionInRange(pos, range)) {
    return i;
  } else {
    return -1;
  }
}

// links.ts
var wikilink_re = /!?\[\[([^#\|]*?)(#(.*?))?(\|(.*?))?\]\]/;
var markdown_re = /!?\[([^\]]*)\]\(([^)#]+)(#([^)]+))?\)/;
var LinkType;
(function(LinkType2) {
  LinkType2[LinkType2["Wikilink"] = 0] = "Wikilink";
  LinkType2[LinkType2["Markdown"] = 1] = "Markdown";
})(LinkType || (LinkType = {}));
var ObsidianLink = class {
  constructor(is_embedded, file_name, anchor, custom_text, link_type) {
    this.is_embedded = is_embedded;
    this.file_name = file_name;
    this.anchor = anchor;
    this.custom_text = custom_text;
    this.link_type = link_type;
  }
  static fromText(text) {
    let is_embedded = text.startsWith("!");
    let matches = text.match(wikilink_re);
    let file_name, anchor, custom_text, link_type;
    if (matches) {
      file_name = matches[1];
      anchor = matches[3];
      custom_text = matches[5];
      link_type = 0;
    } else {
      matches = text.match(markdown_re);
      if (!matches) {
      }
      file_name = matches[2].replace("%20", " ");
      anchor = matches[4];
      if (anchor) {
        anchor = anchor.replace("%20", " ");
        custom_text = matches[1];
        link_type = 1;
      }
    }
    if (anchor == void 0) {
      anchor = 0;
    }
    if (custom_text == void 0) {
      custom_text = 0;
    }
    return new ObsidianLink(is_embedded, file_name, anchor, custom_text, link_type);
  }
  displayText() {
    if (this.custom_text) {
      return String(this.custom_text);
    } else {
      return this.file_name;
    }
  }
};

// helper.ts
function pathAcceptedString(latex) {
  let toRemove = [
    ".",
    "'",
    "$",
    ")",
    "{",
    "}",
    ":",
    "?",
    "!",
    "#",
    "%",
    "&",
    "\\",
    "<",
    ">",
    "*",
    "?",
    "/",
    '"',
    "@",
    "+",
    "`",
    "|",
    "=",
    "[",
    "]",
    "mathscr",
    "mathbf",
    "mathrm",
    "mathfrak",
    "mathcal",
    "mathbb",
    "operatorname"
  ];
  let turnToUnderscore = [" ", "-", "^", "(", ","];
  latex = latex.trim();
  for (const char of toRemove) {
    latex = latex.split(char).join("");
  }
  for (const char of turnToUnderscore) {
    latex = latex.split(char).join("_");
  }
  return latex;
}
function getAllHeadingTitles(fileCache, remove_footnote_markers = true) {
  let headings = fileCache.headings.map((entry) => entry.heading);
  if (remove_footnote_markers) {
    headings = headings.map((heading) => textWithoutFootnoteMarket(heading));
  }
  return headings;
}
function textWithoutFootnoteMarket(text) {
  const regex = /(.+)\[\^([^\]]+)\]/g;
  if (text.match(regex)) {
    return text.replace(regex, "$1");
  } else {
    return text;
  }
}

// settings.ts
var import_obsidian = __toModule(require("obsidian"));
var FastLinkEditSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Reference name").setDesc("Name of reference; should have underscores instead of spaces.").addText((text) => text.setPlaceholder("").setValue(this.plugin.settings.referenceName).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.referenceName = value;
      yield this.plugin.saveSettings();
    })));
  }
};

// frontmatter.ts
function textHasMeta(text) {
  text = text.trim();
  if (!text.startsWith("---")) {
    return false;
  }
  return text.slice(4).indexOf("---") != -1;
}
function findAliasesMetaInText(text) {
  if (!textHasMeta(text)) {
    return -1;
  }
  const metaStart = text.indexOf("---");
  const textWithoutStartMeta = text.slice(metaStart + 3);
  const metaEnd = 3 + textWithoutStartMeta.indexOf("---");
  const tag = 3 + textWithoutStartMeta.indexOf("aliases: [");
  if (metaStart < tag && tag < metaEnd) {
    const end = tag + text.slice(tag).indexOf("\n");
    return { "start": tag, "end": end };
  } else {
    return -1;
  }
}
function updateMetaAliases(app, aliases) {
  return __async(this, null, function* () {
    const currentFile = app.workspace.getActiveFile();
    const fileCache = app.metadataCache.getFileCache(currentFile);
    let text = yield app.vault.read(currentFile);
    const aliasesIndices = findAliasesMetaInText(text);
    if (aliasesIndices == -1) {
      return;
    }
    const aliasesString = `aliases: [${aliases.join(", ")}]`;
    text = text.slice(0, aliasesIndices["start"]) + aliasesString + text.slice(aliasesIndices["end"]);
    yield this.app.vault.modify(currentFile, text);
  });
}

// main.ts
var DEFAULT_SETTINGS = {
  referenceName: ""
};
var FastLinkEdit = class extends import_obsidian2.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.addSettingTab(new FastLinkEditSettingTab(this.app, this));
      this.addCommand({
        id: "go-to-next-link",
        name: "Go to next link",
        hotkeys: [{ modifiers: ["Shift", "Alt"], key: "d" }],
        editorCallback: (editor) => {
          this.goToNextLink(editor);
        }
      });
      this.addCommand({
        id: "go-to-previous-link",
        name: "Go to previous link",
        hotkeys: [{ modifiers: ["Shift", "Alt"], key: "a" }],
        editorCallback: (editor) => {
          this.goToNextLink(editor, true);
        }
      });
      this.addCommand({
        id: "remove-link",
        name: "Remove link",
        hotkeys: [{ modifiers: ["Shift", "Alt"], key: "r" }],
        editorCallback: (editor) => {
          this.removeLink(editor);
        }
      });
      this.addCommand({
        id: "make-notation-note",
        name: "Make notation note",
        hotkeys: [{ modifiers: ["Mod", "Shift", "Alt"], key: "n" }],
        checkCallback: (checking) => {
          const view = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
          if (view) {
            if (!checking) {
              const selection = view.editor.getSelection();
              const currentFile = this.app.workspace.getActiveFile();
              this.createNotationNote(this.settings.referenceName, selection, currentFile);
            }
            return true;
          }
          return false;
        }
      });
      this.addCommand({
        id: "copy-file-name-of-current-pane",
        name: "Copy file name of current pane",
        hotkeys: [{ modifiers: ["Mod", "Shift"], key: "c" }],
        checkCallback: (checking) => {
          const file = this.app.workspace.getActiveFile();
          if (file) {
            if (!checking) {
              navigator.clipboard.writeText(file.basename);
              new import_obsidian2.Notice(`Copied '${file.basename}' to clipboard.`);
            }
            return true;
          }
          return false;
        }
      });
      this.addCommand({
        id: "make-alias-from-headers",
        name: "Make alias from headers",
        hotkeys: [{ modifiers: ["Shift", "Mod"], key: "a" }],
        editorCallback: (editor) => {
          const file = this.app.workspace.getActiveFile();
          const fileCache = this.app.metadataCache.getFileCache(file);
          let headings = getAllHeadingTitles(fileCache, true);
          headings = headings.map((heading) => heading);
          headings = headings.filter(function(heading) {
            return !["Topic", "See Also", "Meta", "References", "Citations and Footnotes", "Code"].includes(heading);
          });
          let aliases = headings.map((heading) => `${this.settings.referenceName}_${pathAcceptedString(heading)}`);
          aliases = aliases.filter(function(alias) {
            return !fileCache.frontmatter.aliases.includes(alias);
          });
          let all_aliases = fileCache.frontmatter.aliases.concat(aliases);
          updateMetaAliases(this.app, all_aliases);
        }
      });
      this.addCommand({
        id: "copy-reference-name-to-clipboard",
        name: "Copy reference name to clipboard",
        hotkeys: [{ modifiers: ["Alt", "Shift"], key: "c" }],
        callback: () => {
          navigator.clipboard.writeText(`${this.settings.referenceName}_`);
          new import_obsidian2.Notice(`Copied '${this.settings.referenceName}_' to clipboard.`);
        }
      });
      this.addCommand({
        id: "add-footnote",
        name: "Add footnote",
        hotkeys: [{ modifiers: ["Shift", "Alt"], key: "t" }],
        editorCallback: (editor) => {
        }
      });
    });
  }
  onunload() {
    return __async(this, null, function* () {
      console.log("test");
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
  goToNextLink(editor, reverse = false) {
    const cursor = editor.getCursor();
    const currentFile = this.app.workspace.getActiveFile();
    const fileCache = this.app.metadataCache.getFileCache(currentFile);
    let goTo = getNextLinkIndex(cursor, fileCache.links, "end", reverse);
    if (goTo == -1) {
      return;
    }
    let pos = locToEditorPosition(fileCache.links[goTo].position["end"]);
    editor.setCursor(pos);
  }
  removeLink(editor) {
    const cursor = editor.getCursor();
    const currentFile = this.app.workspace.getActiveFile();
    const fileCache = this.app.metadataCache.getFileCache(currentFile);
    let index = getCurrentLinkIndex(cursor, fileCache.links);
    if (index == -1) {
      return;
    }
    let sp = locToEditorPosition(fileCache.links[index].position.start);
    let ep = locToEditorPosition(fileCache.links[index].position.end);
    let ol = ObsidianLink.fromText(fileCache.links[index].original);
    editor.replaceRange(ol.displayText(), sp, ep);
  }
  createNotationNote(referenceName, notation, mainFile) {
    return __async(this, null, function* () {
      const notationForPath = pathAcceptedString(notation);
      const path = mainFile.parent.path;
      const fileName = `${path}/${referenceName}_notation_${notationForPath}`;
      let filePath;
      if (yield this.app.vault.adapter.exists(`${fileName}.md`)) {
        let num = 0;
        while (yield this.app.vault.adapter.exists(`${fileName}_${num}.md`)) {
          num++;
        }
        filePath = `${fileName}_${num}.md`;
      } else {
        filePath = `${fileName}.md`;
      }
      const file = yield this.app.vault.create(filePath, "");
      const text = `${notation} [[${mainFile.basename}|denotes]] `;
      yield this.app.vault.modify(file, text);
      const newLeaf = this.app.workspace.splitActiveLeaf();
      yield newLeaf.openFile(file);
      this.app.workspace.setActiveLeaf(newLeaf, true, true);
      const view = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
      const pos = {
        line: 0,
        ch: text.length
      };
      view.editor.setCursor(pos);
    });
  }
};
