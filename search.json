[
  {
    "objectID": "latex.folders.html",
    "href": "latex.folders.html",
    "title": "latex.folders",
    "section": "",
    "text": "import glob\nimport shutil\nimport tempfile\n\n\nfrom fastcore.test import ExceptionExpected, test_eq\nfrom pathvalidate import validate_filename\n\nfrom trouver.helper.files_and_folders import text_from_file\nfrom trouver.helper.tests import _test_directory\n\nfrom trouver.markdown.obsidian.personal.reference import (\n    delete_reference_folder\n)",
    "crumbs": [
      "latex.folders"
    ]
  },
  {
    "objectID": "latex.folders.html#identify-sections-and-subsections-to-make-folders-for-a-reference.",
    "href": "latex.folders.html#identify-sections-and-subsections-to-make-folders-for-a-reference.",
    "title": "latex.folders",
    "section": "Identify sections and subsections to make folders for a reference.",
    "text": "Identify sections and subsections to make folders for a reference.\n\nsource\n\nsection_and_subsection_titles_from_latex_parts\n\n section_and_subsection_titles_from_latex_parts\n                                                 (parts:list[tuple[str,str\n                                                 ]])\n\n*Return a list of lists of titles for the sections and subsections in parts\nUnnumbered sections get their own list. Unnumbered subsections are also included in lists. All the titles are striped (of leading and trailing whitespaces).*\n\n\n\n\nType\nDetails\n\n\n\n\nparts\nlist\nAn output of divide_latex_text\n\n\nReturns\nlist\nEach list corresponds to a section. The first entry of the list is the title of the section and the other entries are the titles of the subsections.\n\n\n\nIn the following example, the Environments are numbered Theorem 1, Corollary 2, Definition 3, etc. Also note that there is some content before the very first (explicitly defined) section, so there is a section given by the UNTITLED_SECTION_TITLE constant.\n\nparts = [\n    ['1', 'For this document, the `theorem` counter is not reset whenever a new section begins.\\n\\nA similar numbering scheme can be accomplished by importing \\\\verb|amsmath| and invoking the code \\\\verb|\\\\numberwithin{theorem}{part}| in the preamble.'],\n    ['1. Introduction', '\\\\section{Introduction}'],\n    ['Theorem 1.', '\\\\begin{theorem}\\nThis is Theorem 1.\\n\\\\end{theorem}'],\n    ['Corollary 2.', '\\\\begin{corollary}\\nThis is Corollary 2.\\n\\\\end{corollary}'],\n    ['Remark', '\\\\begin{remark*}\\nThis is a remark. It is unnumbered and it does not affect the numberings of other environments.\\n\\\\end{remark*}'],\n    ['Definition 3.', '\\\\begin{definition}\\nThis is Definition 3.\\n\\\\end{definition}'],\n    ['2. Another Section', '\\\\section{Another Section}'],\n    ['Theorem 4.', '\\\\begin{theorem}\\nThis is Theorem 4.\\n\\\\end{theorem}'], ['2', 'And we might get a corollary!'],\n    ['Corollary 5.', '\\\\begin{corollary}\\nThis is Corollary 5.\\n\\\\end{corollary}'],\n    ['Definition 6.', '\\\\begin{definition}\\nThis is Definition 6.\\n\\\\end{definition}']]\nsample_output = section_and_subsection_titles_from_latex_parts(parts)\ntest_eq(sample_output, [[UNTITLED_SECTION_TITLE], ['1. Introduction'], ['2. Another Section']])\n\nIn contrast, the following example has environments numbered by sections:\n\nparts = [\n    ['1', 'This document resets its `theorem` counter whenever a new section begins.'], \n    ['1. Introduction', '\\\\section{Introduction}'],\n    ['Theorem 1.1.', '\\\\begin{theorem}\\nThis is Theorem 1.1.\\n\\\\end{theorem}'],\n    ['Corollary 1.2.', '\\\\begin{corollary}\\nThis is Corollary 1.2.\\n\\\\end{corollary}'],\n    ['Remark', '\\\\begin{remark*}\\nThis is a remark. It is unnumbered and it does not affect the numberings of other environments.\\n\\\\end{remark*}'],\n    ['Definition 1.3.', '\\\\begin{definition}\\nThis is Definition 1.3.\\n\\\\end{definition}'],\n    ['2. Another Section', '\\\\section{Another Section}'],\n    ['Theorem 2.1.', '\\\\begin{theorem}\\nThis is Theorem 2.1.\\n\\\\end{theorem}'],\n    ['Corollary 2.2.', '\\\\begin{corollary}\\nThis is Corollary 2.2.\\n\\\\end{corollary}'],\n    ['Definition 2.3.', '\\\\begin{definition}\\nThis is Definition 2.3.\\n\\\\end{definition}']]\ntest_eq(sample_output, [[UNTITLED_SECTION_TITLE], ['1. Introduction'], ['2. Another Section']])\n\nThe below example is derived from a LaTeX document in which significant content is present before any particular sections. See the nbs\\_tests\\latex_examples\\latex_example_with_content_before_sections folder. Also see https://arxiv.org/abs/1111.3607 for an example of a paper with significant content priori to any explicitly defined sections.\n\nparts = [\n    ['abstract', \"\\\\begin{abstract}\\nI'm an abstract\\n\\\\end{abstract}\"],\n    ['1', '\\\\maketitle\\n\\nI want to talk about things but notice that this part does not belong to a section!'],\n    ['Theorem 1.', \"\\\\begin{theorem}\\\\label{th:some_theorem}\\nI'm a theorem.\\n\\\\end{theorem}\"],\n    ['2', 'Blah blah blah'],\n    ['Theorem 2.', '\\\\begin{theorem}\\\\label{th:some_other_theorem}\\nImpart me with mathematical knowledge!\\n\\\\end{theorem}'],\n    ['3', 'Maybe a corollary'],\n    ['Corollary 3.', '\\\\begin{corollary}\\\\label{cor:a_corollary}\\nI immediately follow from the above theorem.\\n\\\\end{corollary}'],\n    ['4', 'More stuff!'],\n    ['Corollary 4.', '\\\\begin{corollary}\\\\label{cor:another_corollary}\\nMore delicious mathematical knowledge.\\n\\\\end{corollary}'],\n    ['5', 'Maybe you could describe how we demonstrate this corollary.'],\n    ['1. Proof of Theorem~\\\\ref{th:main}', '\\\\section{Proof of Theorem~\\\\ref{th:main}}'],\n    ['6', 'Now this is finally in a section.'],\n    ['Lemma 5.', '\\\\begin{lemma}\\nSome lemma\\n\\\\end{lemma}\\\\begin{proof}\\nMaximum effort!\\n\\\\end{proof}'],\n    ['7', 'Blah blah blah.'],\n    ['1.1. This is a subsection', '\\\\subsection{This is a subsection}'],\n    ['8', \"I'm about one thing.\"],\n    ['1.2. This is another subsection', '\\\\subsection{This is another subsection}'],\n    ['9', \"I'm about another thing.\"]] \nsample_output = section_and_subsection_titles_from_latex_parts(parts)\ntest_eq(sample_output, [[UNTITLED_SECTION_TITLE], ['1. Proof of Theorem~\\\\ref{th:main}', '1.1. This is a subsection', '1.2. This is another subsection']])\n\nThe below example is derived from a LaTeX document with a \\numberwithin{equation}{subsection} in which the theorem-like environments are numbered with the equation counter. In particular, theorem-like environments and subsections are counted together.\nAlso, note that the below example starts with an explicitly defined section, so there is no section given by the UNTITLED_SECTION_TITLE constant.\n\nparts = [\n    ['1. This is section 1', '\\\\section{This is section 1}'],\n    ['1.1. Theorem.', '\\\\begin{thm}\\nThis is 1.1. Theorem. Note that the \\\\verb|\\\\swapnumbers| command is invoked in the preamble.\\n\\\\end{thm}'],\n    ['1.2. This is 1.2. subsection.', '\\\\subsection{This is 1.2. subsection.}'],\n    ['1', 'Note that the equation counter is numbered within the subsection counter and that the theorem-like environments are numbered with the equation counter.\\n\\n\\\\subsubsection{This is 1.2.1. Subsubsection}'],\n    ['1. Remark.', '\\\\begin{remark}\\nThis is an 1. Remark. Note that \\\\verb|\\\\remark| has a counter separate from those of many of the other theorem-like environments.\\n\\\\end{remark}'],\n    ['Remark', '\\\\begin{rem*}\\nThis is an unnumbered Remark.\\n\\\\end{rem*}'],\n    ['1.3. Proposition.', '\\\\begin{prop}\\nThis is 1.3. Proposition.\\n\\\\end{prop}'],\n    ['Unnumbered section', '\\\\section*{Unnumbered section}'],\n    ['1.1. Theorem.', '\\\\begin{thm}\\nThis is 1.4. Theorem.\\n\\\\end{thm}'],\n    ['2. This is Section 2', '\\\\section{This is Section 2}'],\n    ['2.1. Theorem.', '\\\\begin{thm}\\nThis is 2.1. Theorem\\n\\\\end{thm}']]\nsample_output = section_and_subsection_titles_from_latex_parts(parts)\ntest_eq(sample_output, [['1. This is section 1', '1.2. This is 1.2. subsection.'], ['Unnumbered section'], ['2. This is Section 2']])\n\nThe titles of the sections are stripped of their leading and trailing whitespaces (if available)\n\n# The below example makes sure that titles are stripped\nparts = [\n    ['   1. Section with an unnumbered subsection   ', '\\\\section{Section with an unnumbered subsection}'],\n    ['1', 'This is a section with an unnumbered subsection'],\n    ['1.1. ', '\\\\subsection{}']\n]\nsample_output = section_and_subsection_titles_from_latex_parts(parts)\ntest_eq(sample_output, [['1. Section with an unnumbered subsection', '1.1.']])\n\n\ndir = _test_directory() / 'latex_examples' / 'latex_example_with_plenty_of_sections_and_subsections'\nfile = dir / 'main.tex'\ntext = text_from_file(file)\nparts = divide_latex_text(text, dir) \nprint(parts)\nsample_output = section_and_subsection_titles_from_latex_parts(parts)\ntest_eq(sample_output,\n        [['1. This is section 1', '1.1. This is section 1.1', '1.2. This is section 1.2'],\n         ['2. This is section 2'],\n         ['3. This is section 3', '3.1. This is section 3.1', '3.2. This is section 3.2', '3.3. This is section 3.3', '3.4. This is section 3.4']])\n\n[['1. This is section 1', '\\\\section{This is section 1}\\n\\n'], ['1.1. This is section 1.1', '\\\\subsection{This is section 1.1}\\n\\n'], ['1.2. This is section 1.2', '\\\\subsection{This is section 1.2}\\n\\n\\n'], ['2. This is section 2', '\\\\section{This is section 2}\\n\\n\\n'], ['3. This is section 3', '\\\\section{This is section 3}\\n\\n'], ['3.1. This is section 3.1', '\\\\subsection{This is section 3.1}\\n\\n'], ['3.2. This is section 3.2', '\\\\subsection{This is section 3.2}\\n\\n'], ['3.3. This is section 3.3', '\\\\subsection{This is section 3.3}\\n\\n'], ['3.4. This is section 3.4', '\\\\subsection{This is section 3.4}\\n\\n']]",
    "crumbs": [
      "latex.folders"
    ]
  },
  {
    "objectID": "tutorial.concise_code.html#download-arxiv-source-code",
    "href": "tutorial.concise_code.html#download-arxiv-source-code",
    "title": "tutorial.concise_code",
    "section": "Download arXiv source code",
    "text": "Download arXiv source code\n\nurl = \"https://arxiv.org/abs/2106.10586\" # Replace this with the url \nresults = list(arxiv_search(arxiv_id(url)))\nlatex_dir = Path(get_download_path()) # Replace this with the path that you can to download the source file in; e.g. r'C:\\Users\\&lt;your user name&gt;' or r'/home/usr'\n\ndownloaded_path = download_from_results(results, latex_dir, source=True)[0]\nprint(downloaded_path)\nreference = downloaded_path.name\nauthor_full_names = [author.name for author in results[0].authors]\nauthor_names = extract_last_names(author_full_names)\n\nlatex_file = find_main_latex_file(downloaded_path)\nprint(latex_file)",
    "crumbs": [
      "tutorial.concise_code"
    ]
  },
  {
    "objectID": "tutorial.concise_code.html#divide-arxiv-source-document-into-parts-for-an-obsidian.md-subvault.",
    "href": "tutorial.concise_code.html#divide-arxiv-source-document-into-parts-for-an-obsidian.md-subvault.",
    "title": "tutorial.concise_code",
    "section": "Divide arXiv source document into parts for an Obsidian.md (sub)vault.",
    "text": "Divide arXiv source document into parts for an Obsidian.md (sub)vault.\n\n# Change this as desired.\n# The name of the reference as well as the name of the folder that contains\n# the latex file\nreference = reference\n# Change this as desired.\nlatex_file = latex_file \n# latex_file = Path(r'C:\\Users\\&lt;user&gt;') / reference / 'main.tex'\nlatex_text = text_from_file(latex_file)\npreamble, _ = divide_preamble(latex_text)\npreamble = replace_inclusion_of_style_file_with_code(preamble, latex_dir)\nparts = divide_latex_text(latex_text, downloaded_path)\ncust_comms = custom_commands(preamble)\n# Replace the below as needed;\n# The path to the Obsidian vault in which to setup the \"subvault\"\n# For convenience, we currently set this as the folder where the\n# arXiv source file got downloaded into,\n# But you may change this to wherever your Obsiidan.md vault\n# actually is located at.\nvault = Path(downloaded_path)\n# Replace the below as needed;\n# The path relative to the vault of the directory in which to make\n# the new folder containing the new notes.\nlocation = Path('.')  \n# Replace the below as needed\n# The (family) names of the authors;\nauthor_names = author_names \n\nsetup_reference_from_latex_parts(\n    parts, cust_comms, vault, location,\n    reference,\n    author_names,\n    # You may set this to `True` if you set up a `_references` folder\n    # in your Obsidian.md vault.\n    create_reference_file_in_references_folder=False,\n    # You may set this to `True` if you set up a `_templates` folder\n    # in your Obsidian.md vault.\n    create_template_file_in_templates_folder=False,\n    adjust_common_latex_syntax_to_markdown=True,\n    repeat_replacing_custom_commands=-1,\n    copy_obsidian_configs=None\n    )",
    "crumbs": [
      "tutorial.concise_code"
    ]
  },
  {
    "objectID": "tutorial.concise_code.html#load-ml-models",
    "href": "tutorial.concise_code.html#load-ml-models",
    "title": "tutorial.concise_code",
    "section": "Load ML models",
    "text": "Load ML models\n\n# Load the model that categorizes the type(s) of standard information notes\nrepo_id = 'hyunjongkimmath/information_note_type'\nif platform.system() == 'Windows':\n    temp = pathlib.PosixPath # See https://stackoverflow.com/questions/57286486/i-cant-load-my-model-because-i-cant-put-a-posixpath\n    pathlib.PosixPath = pathlib.WindowsPath\n    information_note_type_model = from_pretrained_fastai(repo_id)\n    pathlib.PosixPath = temp\nelse:\n    information_note_type_model = from_pretrained_fastai(repo_id)\n\n\n# Load the model the finds definitions and notations introduced in standard information notes\nmodel = AutoModelForTokenClassification.from_pretrained('hyunjongkimmath/def_and_notat_token_classification_model')\ntokenizer = AutoTokenizer.from_pretrained('hyunjongkimmath/def_and_notat_token_classification_model')\ndef_notat_classifier = pipeline('ner', model=model, tokenizer=tokenizer)\n\n# Load the models that names definitions and notations.\nmodel = AutoModelForSeq2SeqLM.from_pretrained('hyunjongkimmath/definition_naming_model')\ntokenizer = AutoTokenizer.from_pretrained('hyunjongkimmath/definition_naming_model')\ndefinition_naming_pipeline = pipeline('summarization', model=model, tokenizer=tokenizer)\n\nmodel = AutoModelForSeq2SeqLM.from_pretrained('hyunjongkimmath/notation_naming_model')\ntokenizer = AutoTokenizer.from_pretrained('hyunjongkimmath/notation_naming_model')\nnotation_naming_pipeline = pipeline('summarization', model=model, tokenizer=tokenizer)\n\n# Load the model the summarizes what notations denote\nmodel = AutoModelForSeq2SeqLM.from_pretrained('hyunjongkimmath/notation_summarizations_model')\ntokenizer = AutoTokenizer.from_pretrained('hyunjongkimmath/notation_summarizations_model')\nsummarizer = pipeline('summarization', model=model, tokenizer=tokenizer)",
    "crumbs": [
      "tutorial.concise_code"
    ]
  },
  {
    "objectID": "tutorial.concise_code.html#make-ml-predictions",
    "href": "tutorial.concise_code.html#make-ml-predictions",
    "title": "tutorial.concise_code",
    "section": "Make ML predictions",
    "text": "Make ML predictions\n\nTagging note types\n\n# Change `vault` and `reference` if necessary. These variables were defined in previous code.\n# vault = Path(r'C:\\Users\\&lt;user&gt;\\...')  # The path to the Obsidian vault\n# `reference` = 'kim_park_ga1dcmmc`\nindex_note = VaultNote(vault, name=f'_index_{reference}')\nnotes = notes_linked_in_notes_linked_in_note(index_note, as_dict=False)\n\nfor note in notes:\n    if not note.exists():\n        raise Exception(note.name)\n\nprint(\"Tagging notes\")\nautomatically_add_note_type_tags(information_note_type_model, vault, notes)\n\n\n\nLocating definitions and notations\n\nwarnings.filterwarnings(\"ignore\")\n\nindex_note = VaultNote(vault, name=f'_index_{reference}')\nnotes = notes_linked_in_notes_linked_in_note(index_note, as_dict=False)\n\nfor note in notes:\n    assert note.exists()\n\nprint(\"Finding notations\")\nnote_mfs = [MarkdownFile.from_vault_note(note) for note in notes]\nnotation_notes = [\n    note for note, mf in zip(notes, note_mfs)\n    if mf.has_tag('_auto/_meta/definition') or mf.has_tag('_auto/_meta/notation')\n       or mf.has_tag('_meta/definition') or mf.has_tag('_meta/notation')]\nfor note in notation_notes:\n    auto_mark_def_and_notats(note, def_notat_classifier, excessive_space_threshold=2)\n    # automatically_mark_notations(note, notation_identification_model, reference_name=reference)\n\n\n\nNaming definitions and notations\n\nindex_note = VaultNote(vault, name=f'_index_{reference}')\nnotes = notes_linked_in_notes_linked_in_note(index_note, as_dict=False)\n\nfor note in notes:\n    try:\n        mf = MarkdownFile.from_vault_note(note)\n        add_names_to_html_tags_in_info_note(\n            note, def_pipeline=definition_naming_pipeline,\n            notat_pipeline=notation_naming_pipeline, overwrite=False) \n    except Exception as e:\n        print(f'{note.name} raised an exception')\n        print(e)\n\n\n\nCreating notation notes\n\nindex_note = VaultNote(vault, name=f'_index_{reference}')\nnotes = notes_linked_in_notes_linked_in_note(index_note, as_dict=False)\n\nfor note in notes:\n    try:\n        new_notes = make_notation_notes_from_HTML_tags(note, vault, reference_name=reference)\n    except Exception as e:\n        print(note.name)\n        raise(e)\n    # assert len(new_notes) == 0\n\n\n\nSummarizing notations\n\nindex_note = VaultNote(vault, name=f'_index_{reference}')\nnotes = notes_linked_in_notes_linked_in_note(index_note, as_dict=False)\n\nfor note in notes:\n    if not note.exists():\n        print(f\"note does not exist: {note.name}\")\n        raise Exception()\n\nprint(\"Summarizing notations\")\nfor note in notes:\n    notation_notes_linked_in_note = notation_notes_linked_in_see_also_section(note, vault)\n    for notation_note in notation_notes_linked_in_note:\n        append_summary_to_notation_note(notation_note, vault, summarizer)",
    "crumbs": [
      "tutorial.concise_code"
    ]
  },
  {
    "objectID": "latex.divide.html",
    "href": "latex.divide.html",
    "title": "latex.divide",
    "section": "",
    "text": "from fastcore.test import ExceptionExpected, test_eq\n\nfrom trouver.helper.tests import _test_directory# , non_utf8_chars_in_file",
    "crumbs": [
      "latex.divide"
    ]
  },
  {
    "objectID": "latex.divide.html#divide-latex-file-into-parts",
    "href": "latex.divide.html#divide-latex-file-into-parts",
    "title": "latex.divide",
    "section": "Divide LaTeX file into parts",
    "text": "Divide LaTeX file into parts\nTo make Obsidian notes from a LaTeX file, I use sections/subsections, and environments as places to make new notes.\nThings to think about: Sections/subsections environments, including theorems, corollaries, propositions, lemmas, definitions, notations citations Macros defined in the preamble?\nLatexMacroNodes include: sections/subsections, citations, references, and labels, e.g.\n&gt; \\section{Introduction}\n\\cite{ellenberg2nilpotent}\n\\subsection{The section conjecture}\n\\'e\n\\ref{fundamental-exact-sequence}\n\\cite{stix2010period}\n\\ref{fundamental-exact-sequence}\n\\cite{stix2012rational}\n\\cite[Appendix C]{stix2010period}\n\\subsection{The tropical section conjecture}\n\\label{subsec:tropical-section-conjecture}\n\nGet the Document Node\n\nsource\n\n\nNoDocumentNodeError\n\n NoDocumentNodeError (text)\n\n*Exception raised when a LatexEnvironmentNode corresponding to the document environment is expected in a LaTeX string, but no such node exists.\nAttributes - text - str - The text in which the document environment is not found.*\n\nsource\n\n\nfind_document_node\n\n find_document_node (text:str, document_environment_name:str='document')\n\n*Find the LatexNode object for the main document in text.\nRaises - NoDocumentNodeError - If document environment node is not detected.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ntext\nstr\n\nLaTeX str\n\n\ndocument_environment_name\nstr\ndocument\nThe name of the document environment.\n\n\nReturns\nLatexEnvironmentNode\n\n\n\n\n\nThe main content of virtually all LaTeX math articles belongs to a document environment, which pylatexenc can often detect. The find_document_node function returns this LatexEnvironmentNode object:\n\nlatex_file_path = _test_directory() / 'latex_examples' / 'latex_example_1' / 'main.tex'\ntext = text_from_file(latex_file_path)\ndocument_node = find_document_node(text)\n\nIf the LaTeX file has no document environment, then a NoDocumentNodeError is raised:\n\n# This latex document has its `document` environment commented out.\nlatex_file_path = _test_directory() / 'latex_examples' / 'latex_example_2' / 'main.tex'\ntext = text_from_file(latex_file_path)\nwith ExceptionExpected(NoDocumentNodeError):\n    document_node = find_document_node(text)\n\nAt the time of this writinga NoDocumentNodeError may be raised even if the LaTeX file has a proper document environment\n\nlatex_file_path = _test_directory() / 'latex_examples' / 'example_with_a_command_with_begin.tex'\ntext = text_from_file(latex_file_path)\n\n# Perhaps in the future, pylatexenc will be able to find the document node for this file.\n# When that time comes, delete this example.\nwith ExceptionExpected(NoDocumentNodeError):\n    find_document_node(text)\n\nThe divide_preamble function can be used to circumvent this problem:\n\npreamble, document = divide_preamble(text)\ndocument_node = find_document_node(document)\ntest_eq(document_node.environmentname, 'document')\nassert document_node.isNodeType(LatexEnvironmentNode)\n\n\n# hide\n# Find no document node error causes\n\n# latex_file_path = r'_tests\\latex_full\\litt_cfag\\main.tex'\n# text = text_from_file(latex_file_path)\n# document_node = find_document_node(text)\n\n\n\nDetect environment names used in a file\n\nsource\n\n\nenvironment_names_used\n\n environment_names_used (text:str)\n\nReturn the set of all environment names used in the main document of the latex code.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ntext\nstr\nLaTeX document\n\n\nReturns\nset\nThe set of all environment names used in the main document.\n\n\n\nWriters often use different environment names. For examples, writers often use theorem, thm, or theo for theorem environments or lemma or lem for lemma environments. The environment_names_used function returns the environment names actually used in the tex file.\nIn the example below, note that only the environments that are actually used are returned. For instance, the preamble of the document defines the theorem environments problem, and lemma (among other things), but these are not actually used in the document itself.\n\nlatex_file_path = _test_directory() / 'latex_examples' / 'has_fully_written_out_environment_names.tex'\nsample_text_1 = text_from_file(latex_file_path)\nsample_output_1 = environment_names_used(sample_text_1)\ntest_eq({'corollary', 'proof', 'maincorollary', 'abstract', 'proposition'}, sample_output_1)\n\nThe document in the example below uses shorter names for theorem environments:\n\nlatex_file_path = _test_directory() / 'latex_examples' / 'has_shorter_environment_names.tex'\nsample_text_2 = text_from_file(latex_file_path)\nsample_output_2 = environment_names_used(sample_text_2)\ntest_eq({'conj', 'notation', 'corollary', 'defn'}, sample_output_2)\n\n\nIdentify the numbering convention of a LaTeX document\nLaTeX documents have various number conventions. Here are some examples of papers on the arXiv and notes on their numbering schemes. Note that the source code to these articles are publicly available on the arXiv.\n\nEllenberg, Venkatesh, and Westerland, Homological stability for Hurwitz spaces and the Cohen-Lenstra conjecture over function fields,\n\nThe subsections and theorem-like environments of each section share a numbering scheme, e.g. section 1 has subsection 1.1 The Cohen-Lenstra heuristics, 1.2 Theorem, 1.3 Hurwitz spaces. This is accomplished by defining theorem-like environments using the subsection counter, e.g.\n\\theoremstyle{plain}\n\\newtheorem{thm}[subsection]{Theorem}\n\\newtheorem{prop}[subsection]{Proposition}\n\\newtheorem{cor}[subsection]{Corollary}\n\\newtheorem{remark}{Remark}\n\\newtheorem{conj}[subsection]{Conjecture}\n\\newtheorem*{conj*}{Conjecture}\ndefines the thm, prop, cor, and conj environments to be numbered using the subsection counter, the remark environmment to be defiend as an unnumbered environment, and the conj* environment to be defined as an unnumbered environment with a different name than the conj environment.\nThe \\swapnumbers command is included in the preamble to change the way that theorems are numbered in the document, e.g. the article has 1.2 Theorem as opposed to Theorem 1.2.\nThe equations are numbered along the subsections - this is accomplished by the lines\n\\numberwithin{equation}{subsection}\n\\renewcommand{\\theequation}{\\thesubsection.\\arabic{equation}}\nin the preamble.\n\nHoyois, A quadratic refinement of the Grothendieck-Lefschetz-Verdier Trace Formula\n\nThe theorem-like environments are numbered Theorem 1.1, Theorem 1.3, Corollary 1.4, Theorem 1.5, etc.\n\nThe theorem-like environments that are numbered are assigned the equation counter. In particular, the equation environments share their numberings with the theorem-like environments. For example, section 1 has Equation (1.2)\nThis equation counter is reset at the beginning of each section and the section number is included in the numbering via\n\n\\numberwithin{equation}{section}\n\n\n\n# TODO: consider different arxiv articles to see how they are numbered\n\n\nsource\n\n\n\nnumbered_newtheorems_counters_in_preamble\n\n numbered_newtheorems_counters_in_preamble (document:str,\n                                            add_equation_counter:Optional[\n                                            bool]=None)\n\n*Return the dict specifying the numbered \\newtheorem command invocations\nAssumes that\n\ninvocations of the \\newtheorem command are exclusively in the preamble of the LaTeX document.\ntheorem-like environments are defined using the \\newtheorem command.\nno environments of the same name are defined twice.\nThere is at most one invocation of \\theoremstyle or \\newtheorem in each line.\n\nThis function does not take into account \\numberwithins being used. The numberwithins_in_preamble function accounts for invocations of the \\numberwithins command instead.\nThe equation environment (and other related environments, such as eqnarray) seems to be included in documents of the class amsart or article (i.e. documents which invoke \\documentclass{amsart} or \\documentclass{article}, possibly with some optional arguments). The equation environment (and other related environments) is accordingly included in the output of this function if the document is of the class amsart and add_equation_counter is not specified, set to None.\nThis function uses two separate regex patterns, one to detect the invocations of \\newtheorem in which the optional parameter is the second parameter and one to detect those in which the optional parameter is the third parameter.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndocument\nstr\n\nThe LaTeX document\n\n\nadd_equation_counter\nOptional\nNone\nDetermines whether or not the equation environment will have a counter added when a newthoerem command for the equation environment is not explicitly invoked in the preamble. If None, then the counter is added if the article is of class amsart or article. If True, then the counter is added. If False, then the counter is not added.\n\n\nReturns\ndict\n\nThe keys are the command names of the environments. The value a key is a tuple (&lt;counter&gt;, &lt;reset_by_counter&gt;), where &lt;counter&gt; is the counter that the environment belongs to, which can be custom defined or predefined in LaTeX, and &lt;reset_by_counter&gt; is a counter whose incrementation resets the # counter of the environment, if available.\n\n\n\n\ntext = r\"\"\"\\theoremstyle{definition}                 \\newtheorem{conj}{Conjecture}\n\\newtheorem*{example}{Example}            \\newtheorem{defn}{Definition}\n\\newtheorem{remark}{Remark} \\newtheorem*{notation}{Notation}\n\\begin{document}\n\\end{document}\"\"\"\nnumbered_newtheorems_counters_in_preamble(text)\n\n{'conj': ('conj', None), 'defn': ('defn', None), 'remark': ('remark', None)}\n\n\nThe numbered_newtheorems_counter_in_preamble function parses the preamble of a LaTeX document for invocations of the \\newtheorem command and returns what counters each theorem-like environment command belongs to.\n\ntext = text_from_file(_test_directory() / 'latex_examples' / 'newtheorem_example.tex') \nprint(text)\n\ncounters = numbered_newtheorems_counters_in_preamble(text)\ntest_eq(counters,\n   {'theorem': ('theorem', None), 'lemma': ('theorem', None), 'definition': ('theorem', None), 'corollary': ('corollary', None), 'remark': ('remark', 'theorem'), 'equation': ('equation', None), 'eqnarray': ('equation', None)}\n)\n\n\\documentclass{article}\n\\usepackage{amsthm}\n\n\\newtheorem{theorem}{Theorem}\n\\newtheorem{lemma}[theorem]{Lemma}\n\\newtheorem{definition}[theorem]{Definition} % Note that `theorem`, `lemma`, and `definition` all have `theorem` as their counter.\n\\newtheorem{corollary}{Corollary} % Note that `corollary` has its own counter.\n\\newtheorem{remark}{Remark}[theorem] % `remark` has `theorem` as its counter\n\\newtheorem*{conjecture*}{Conjecture} % `conjecture*` has no counter\n\n\\begin{document}\n\n\\section{Introduction}\n\n\\begin{theorem}\nThis is Theorem 1.\n\\end{theorem}\n\n\\begin{lemma}\nThis is Lemma 2.\n\\end{lemma}\n\n\\begin{definition}\nThis is Definition 3.\n\\end{definition}\n\n\\end{document}\n\n\n\ntext = r\"\"\"\n\\theoremstyle{plain}\n\\newtheorem{thm}[subsection]{Theorem}\n\\newtheorem{prop}[subsection]{Proposition}\n\\newtheorem{cor}[subsection]{Corollary}\n\\newtheorem{remark}{Remark}\n\\newtheorem{conj}[subsection]{Conjecture}\n\\newtheorem*{conj*}{Conjecture}\n\\begin{document}\n\\end{document}\n\"\"\"\ncounters = numbered_newtheorems_counters_in_preamble(text)\ntest_eq(\n    counters,\n    {'thm': ('subsection', None), 'prop': ('subsection', None), 'cor': ('subsection', None), 'remark': ('remark', None), 'conj': ('subsection', None)})\n\nnumbered_newtheorems_counters_in_preamble ignores commented out text:\n\ntext = r\"\"\"\n\\theoremstyle{plain}\n\\newtheorem{thm}[subsection]{Theorem}\n\\newtheorem{prop}[subsection]{Proposition}\n\\newtheorem{cor}[subsection]{Corollary}\n\n\\newtheorem{conj}[subsection]{Conjecture}\n\\newtheorem*{conj*}{Conjecture} %\\newtheorem{fakeenv}{This won't be picked up!}\n\\begin{document}\n\\end{document}\n\"\"\"\ncounters = numbered_newtheorems_counters_in_preamble(text)\ntest_eq(\n    counters,\n    {'thm': ('subsection', None), 'prop': ('subsection', None), 'cor': ('subsection', None), 'conj': ('subsection', None)})\n\nnumbered_newtheorems_counters_in_preamble does not account for \\numberwithin command invocations. The numberwithins_in_preamble function accounts for invocations of \\numberwithin instead.\n\ntext = text_from_file(_test_directory() / 'latex_examples' / 'numbering_example_3_theorem_like_environments_share_counter_with_equation_and_reset_at_each_section' / 'main.tex')\nprint(text)\n# So `numbered_newtheorems_counters_in_preamble` only considers\n# the theorem-like environemnts as being counted by 'equation'.\n# Note that the command  `\\numberwithin{equation}{section}`\n# resets the equation counter\n# every time the `section` counter is incremented.\ntest_eq(numbered_newtheorems_counters_in_preamble(text), \n       {'theorem': ('equation', None), 'proposition': ('equation', None), 'lemma': ('equation', None), 'corollary': ('equation', None), 'definition': ('equation', None), 'example': ('equation', None), 'remark': ('equation', None), 'equation': ('equation', None), 'eqnarray': ('equation', None)}\n        )\n\n\\documentclass{amsart}\n\\usepackage[utf8]{inputenc}\n\\usepackage{amsmath, amsfonts, amssymb, amsthm, amsopn}\n\n\\numberwithin{equation}{section}\n\n\\theoremstyle{plain}\n\\newtheorem*{theorem*}{Theorem}\n\\newtheorem*{theoremA}{Theorem A}\n\\newtheorem*{theoremB}{Theorem B}\n\\newtheorem{theorem}[equation]{Theorem}\n\\newtheorem{proposition}[equation]{Proposition}\n\\newtheorem{lemma}[equation]{Lemma}\n\\newtheorem{corollary}[equation]{Corollary}\n\n\\theoremstyle{definition}\n\\newtheorem{definition}[equation]{Definition}\n\\newtheorem{example}[equation]{Example}\n\\newtheorem*{acknowledgements}{Acknowledgements}\n\\newtheorem*{conventions}{Conventions}\n\n\\theoremstyle{remark}\n\\newtheorem{remark}[equation]{Remark}\n\n\\begin{document}\n\n\\section{Introduction}\n\n\\begin{theorem}\nThis is Theorem 1.1. This is because the \\verb|\\numberwithin{equation}{section}| makes the section number included in the equation counter and because the \\\\\n\\verb|\\newtheorem{theorem}[equation]{Theorem}| command makes the environment \\verb|theorem| be counted by the equation counter.\n\\end{theorem}\n\nThe following makes an equation labeled 1.2; \n\\begin{equation}\n5 + 7 = 12\n\\end{equation}\n\n\\begin{theorem*}\nThis Theorem is unnumbered\n\\end{theorem*}\n\n\\begin{corollary}\nThis is Corollary 1.3.\n\\end{corollary}\n\n\\section{Another section}\n\\begin{theorem}\nThis is theorem 2.1\n\\end{theorem}\n\nThe following is labeled 2.2:\n\\begin{equation}\n3+5 = 8.\n\\end{equation}\n\n\\end{document}\n\n\nThe \\newtheorem command can be used to specify the counter of the newly defined theorem-like environment to be reset upon another counter’s incrementation; for example \\newtheorem{theorem}{Theorem}[section] specifies for a new environment named theorem (with display text Theorem) that is reset whenever the section counter is incremented.\n\ntext = text_from_file(_test_directory() / 'latex_examples' / 'numbering_example_7_newtheorem_command_restarts_counter_by_section' / 'main.tex') \nprint(text)\n# So `numbered_newtheorems_counters_in_preamble` only considers the theorem-like\n#  environemnts as being counted by 'equation'.\n# Note that the command  `\\numberwithin{equation}{section}` resets the equation counter\n# every time the `section` counter is incremented.\n\ntest_eq(numbered_newtheorems_counters_in_preamble(text), \n        {'lemma': ('theorem', None), 'theorem': ('theorem', 'section'), 'corollary': ('corollary', 'theorem'), 'proposition': ('proposition', 'section'), 'equation': ('equation', None), 'eqnarray': ('equation', None)}\n\n        )\n\n\n% Based on an example from https://www.overleaf.com/learn/latex/Theorems_and_proofs#Numbered_theorems.2C_definitions.2C_corollaries_and_lemmas\n\n\\documentclass[12 pt]{amsart}\n\n\\newtheorem{theorem}{Theorem}[section]\n\\newtheorem{corollary}{Corollary}[theorem]\n\\newtheorem{lemma}[theorem]{Lemma}\n% Note that the below invocation of \\newtheorem is invalid:\n% \\newtheorem{proposition}[theorem]{Proposition}[section]\n\\newtheorem{proposition}{Proposition}[section]\n\n\\begin{document}\n\\section{Introduction}\nTheorems can easily be defined:\n\n\\begin{theorem}\nLet \\(f\\) be a function whose derivative exists in every point, then \\(f\\) is \na continuous function.\n\\end{theorem}\n\n\\begin{theorem}[Pythagorean theorem]\n\\label{pythagorean}\nThis is a theorem about right triangles and can be summarised in the next \nequation \n\\[ x^2 + y^2 = z^2 \\]\n\\end{theorem}\n\nAnd a consequence of theorem \\ref{pythagorean} is the statement in the next \ncorollary.\n\n\\begin{corollary}\nThere's no right rectangle whose sides measure 3cm, 4cm, and 6cm.\n\\end{corollary}\n\nYou can reference theorems such as \\ref{pythagorean} when a label is assigned.\n\n\\begin{lemma}\nGiven two line segments whose lengths are \\(a\\) and \\(b\\) respectively there is a \nreal number \\(r\\) such that \\(b=ra\\).\n\\end{lemma}\n\n\\end{document}\n\n\n\n\nFor the following test, we have multiple theorems defined in the same line:\n\ntext = r\"\"\"\\theoremstyle{definition}                 \\newtheorem{conj}{Conjecture}\n\\newtheorem*{example}{Example}            \\newtheorem{defn}{Definition}\n\\newtheorem{remark}{Remark} \\newtheorem*{notation}{Notation}\n\\begin{document}\n\\end{document}\"\"\"\nnumbered_newtheorems_counters_in_preamble(text)\n\n{'conj': ('conj', None), 'defn': ('defn', None), 'remark': ('remark', None)}\n\n\n\nsource\n\n\nnumberwithins_in_preamble\n\n numberwithins_in_preamble (document:str)\n\n*Return the dict describing \\numberwithin commands invoked in the preamble of document.\nAssumes that \\numberwithin commands are invoked exclusively in the preamble.\nSee also the numbered_newtheorems_counter_in_preamble function, which parses invocations of the \\newtheorem command.*\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ndocument\nstr\nThe LaTeX document\n\n\nReturns\ndict\nThe keys are the first arguments of numberwithin invocations and the values ar ethe second arguments of numberwithin invocations.\n\n\n\nThe numberwithins_in_preamble function returns a dict describing invocations of the \\numberwithin commands. See also the numbered_newtheorems_counter_in_preamble function, which parses invocations of the \\newtheorem command.\nIn the following example, there is an invocation of the \\numberwithin command; for the LaTeX document in the example below, the equation counter is reset every time the section counter is incremented.\nThe numberwithins_in_preamble function returns a dict that is used by the divide_latex_text function to account for this fact.\n\ntext = text_from_file(_test_directory() / 'latex_examples' / 'numbering_example_3_theorem_like_environments_share_counter_with_equation_and_reset_at_each_section' / 'main.tex')\nprint(text)\ntest_eq(numberwithins_in_preamble(text), {'equation': 'section'})\n\n\\documentclass{amsart}\n\\usepackage[utf8]{inputenc}\n\\usepackage{amsmath, amsfonts, amssymb, amsthm, amsopn}\n\n\\numberwithin{equation}{section}\n\n\\theoremstyle{plain}\n\\newtheorem*{theorem*}{Theorem}\n\\newtheorem*{theoremA}{Theorem A}\n\\newtheorem*{theoremB}{Theorem B}\n\\newtheorem{theorem}[equation]{Theorem}\n\\newtheorem{proposition}[equation]{Proposition}\n\\newtheorem{lemma}[equation]{Lemma}\n\\newtheorem{corollary}[equation]{Corollary}\n\n\\theoremstyle{definition}\n\\newtheorem{definition}[equation]{Definition}\n\\newtheorem{example}[equation]{Example}\n\\newtheorem*{acknowledgements}{Acknowledgements}\n\\newtheorem*{conventions}{Conventions}\n\n\\theoremstyle{remark}\n\\newtheorem{remark}[equation]{Remark}\n\n\\begin{document}\n\n\\section{Introduction}\n\n\\begin{theorem}\nThis is Theorem 1.1. This is because the \\verb|\\numberwithin{equation}{section}| makes the section number included in the equation counter and because the \\\\\n\\verb|\\newtheorem{theorem}[equation]{Theorem}| command makes the environment \\verb|theorem| be counted by the equation counter.\n\\end{theorem}\n\nThe following makes an equation labeled 1.2; \n\\begin{equation}\n5 + 7 = 12\n\\end{equation}\n\n\\begin{theorem*}\nThis Theorem is unnumbered\n\\end{theorem*}\n\n\\begin{corollary}\nThis is Corollary 1.3.\n\\end{corollary}\n\n\\section{Another section}\n\\begin{theorem}\nThis is theorem 2.1\n\\end{theorem}\n\nThe following is labeled 2.2:\n\\begin{equation}\n3+5 = 8.\n\\end{equation}\n\n\\end{document}\n\n\n\nGetting the display names of environment\nFor example, \\newtheorem{theorem}{Theorem} defines a theorem-like environment called theorem whose display name is Theorem.\n\nsource\n\n\n\ndisplay_names_of_environments\n\n display_names_of_environments (document:str)\n\n*Return the dict specifying the display names for each theorem-like environment.\nThis function uses two separate regex patterns, one to detect the invocations of \\newtheorem in which the optional parameter is the second parameter and one to detect those in which the optional parameter is the third parameter.\nAssumes that - invocations of the \\newtheorem command are exclusively in the preamble of the LaTeX document. - theorem-like environments are defined using the \\newtheorem command. - no environments of the same name are defined twice.*\n\n\n\n\nType\nDetails\n\n\n\n\ndocument\nstr\nThe LaTeX document\n\n\nReturns\ndict\n\n\n\n\nBasic examples:\n\ntext = text_from_file(_test_directory() / 'latex_examples' / 'newtheorem_example.tex') \nprint(text)\ndisplay_names = display_names_of_environments(text)\ntest_eq(display_names,{'theorem': 'Theorem', 'lemma': 'Lemma', 'definition': 'Definition', 'corollary': 'Corollary', 'conjecture*': 'Conjecture', 'remark': 'Remark'})\n\n\\documentclass{article}\n\\usepackage{amsthm}\n\n\\newtheorem{theorem}{Theorem}\n\\newtheorem{lemma}[theorem]{Lemma}\n\\newtheorem{definition}[theorem]{Definition} % Note that `theorem`, `lemma`, and `definition` all have `theorem` as their counter.\n\\newtheorem{corollary}{Corollary} % Note that `corollary` has its own counter.\n\\newtheorem{remark}{Remark}[theorem] % `remark` has `theorem` as its counter\n\\newtheorem*{conjecture*}{Conjecture} % `conjecture*` has no counter\n\n\\begin{document}\n\n\\section{Introduction}\n\n\\begin{theorem}\nThis is Theorem 1.\n\\end{theorem}\n\n\\begin{lemma}\nThis is Lemma 2.\n\\end{lemma}\n\n\\begin{definition}\nThis is Definition 3.\n\\end{definition}\n\n\\end{document}\n\n\n\nfile = _test_directory() / 'latex_examples' / 'numbering_example_1_consecutive_numbering_scheme' / 'main.tex'\nprint(text)\ndisplay_names = display_names_of_environments(text)\nprint(display_names)\n\n\\documentclass{article}\n\\usepackage{amsthm}\n\n\\newtheorem{theorem}{Theorem}\n\\newtheorem{lemma}[theorem]{Lemma}\n\\newtheorem{definition}[theorem]{Definition} % Note that `theorem`, `lemma`, and `definition` all have `theorem` as their counter.\n\\newtheorem{corollary}{Corollary} % Note that `corollary` has its own counter.\n\\newtheorem{remark}{Remark}[theorem] % `remark` has `theorem` as its counter\n\\newtheorem*{conjecture*}{Conjecture} % `conjecture*` has no counter\n\n\\begin{document}\n\n\\section{Introduction}\n\n\\begin{theorem}\nThis is Theorem 1.\n\\end{theorem}\n\n\\begin{lemma}\nThis is Lemma 2.\n\\end{lemma}\n\n\\begin{definition}\nThis is Definition 3.\n\\end{definition}\n\n\\end{document}\n{'theorem': 'Theorem', 'lemma': 'Lemma', 'definition': 'Definition', 'corollary': 'Corollary', 'conjecture*': 'Conjecture', 'remark': 'Remark'}\n\n\n\ntext = text_from_file(_test_directory() / 'latex_examples' / 'numbering_example_7_newtheorem_command_restarts_counter_by_section' / 'main.tex') \nprint(text)\ndisplay_names = display_names_of_environments(text)\ntest_eq(display_names,\n{'theorem': 'Theorem',\n 'corollary': 'Corollary',\n 'lemma': 'Lemma',\n 'proposition': 'Proposition',})\n\n\n% Based on an example from https://www.overleaf.com/learn/latex/Theorems_and_proofs#Numbered_theorems.2C_definitions.2C_corollaries_and_lemmas\n\n\\documentclass[12 pt]{amsart}\n\n\\newtheorem{theorem}{Theorem}[section]\n\\newtheorem{corollary}{Corollary}[theorem]\n\\newtheorem{lemma}[theorem]{Lemma}\n% Note that the below invocation of \\newtheorem is invalid:\n% \\newtheorem{proposition}[theorem]{Proposition}[section]\n\\newtheorem{proposition}{Proposition}[section]\n\n\\begin{document}\n\\section{Introduction}\nTheorems can easily be defined:\n\n\\begin{theorem}\nLet \\(f\\) be a function whose derivative exists in every point, then \\(f\\) is \na continuous function.\n\\end{theorem}\n\n\\begin{theorem}[Pythagorean theorem]\n\\label{pythagorean}\nThis is a theorem about right triangles and can be summarised in the next \nequation \n\\[ x^2 + y^2 = z^2 \\]\n\\end{theorem}\n\nAnd a consequence of theorem \\ref{pythagorean} is the statement in the next \ncorollary.\n\n\\begin{corollary}\nThere's no right rectangle whose sides measure 3cm, 4cm, and 6cm.\n\\end{corollary}\n\nYou can reference theorems such as \\ref{pythagorean} when a label is assigned.\n\n\\begin{lemma}\nGiven two line segments whose lengths are \\(a\\) and \\(b\\) respectively there is a \nreal number \\(r\\) such that \\(b=ra\\).\n\\end{lemma}\n\n\\end{document}\n\n\n\n\nIn the following example, there are multiple \\newtheorem commands defined in a single line.\n\ntext = r\"\"\"\\theoremstyle{definition}                 \\newtheorem{conj}{Conjecture}\n\\newtheorem*{example}{Example}            \\newtheorem{defn}{Definition}\n\\newtheorem{remark}{Remark} \\newtheorem*{notation}{Notation}\n\\begin{document}\n\\end{document}\"\"\"\ntest_eq(display_names_of_environments(text), {'conj': 'Conjecture', 'example': 'Example', 'defn': 'Definition', 'remark': 'Remark', 'notation': 'Notation'})\n\n\n\nDivide latex text into parts\n\nsource\n\n\ntext_from_node\n\n text_from_node (node:pylatexenc.latexwalker.LatexNode)\n\nReturn the str representing node.\n\nsource\n\n\nget_node_from_simple_text\n\n get_node_from_simple_text (text:str)\n\nReturn the (first) LatexNode object from a str.\n\nnode = get_node_from_simple_text(\n    r\"\"\"\\begin{theorem}\nlalalala\n\\begin{equation}\n\\end{equation}\n\\end{theorem}\"\"\"\n)\ntext_from_node(node)\n\n'\\\\begin{theorem}\\nlalalala\\n\\\\begin{equation}\\n\\\\end{equation}\\n\\\\end{theorem}'\n\n\n\ntext = r\"\"\"\\begin{thm}This is a theorem. \\end{thm}\"\"\"\nnode = get_node_from_simple_text(text)\nassert isinstance(node, LatexEnvironmentNode)\ntest_eq(node.environmentname, 'thm')\n\n\ntext = r\"\"\"\\begin{thm}This is a theorem. \\end{thm} \\begin{proof} This is a proof. It is not captured by the `get_node_from_simple_text` function \\end{proof}\"\"\"\nnode = get_node_from_simple_text(text)\nassert isinstance(node, LatexEnvironmentNode)\ntest_eq(node.environmentname, 'thm')\n\n\ntext = r\"\"\"\\begin{thm}This is a theorem. \\end{thm}\"\"\"\nnode = get_node_from_simple_text(text)\n# Test a theoreem being counted by its own counter.\nnumbertheorem_counters = {'thm': ('thm', None)}\nnumberwithins = {}\ncounters = {'thm': 1}\nsample_numbering = _node_numbering(\n    node, numbertheorem_counters, numberwithins, counters)\ntest_eq(sample_numbering, '1')\n# Test a theorem being countered by the equation counter.\nnumbertheorem_counters = {'thm': ('equation', None)}\nnumberwithins = {}\ncounters = {'equation': 2}\nsample_numbering = _node_numbering(\n    node, numbertheorem_counters, numberwithins, counters)\ntest_eq(sample_numbering, '2')\n# Test a theorem being countered by the equation counter.\nnumbertheorem_counters = {'thm': ('equation', None)}\nnumberwithins = {}\ncounters = {'equation': 2}\nsample_numbering = _node_numbering(\n    node, numbertheorem_counters, numberwithins, counters)\ntest_eq(sample_numbering, '2')\n\ntext = r\"\"\"\\begin{corollary}This is a corollary. \\end{orollary}\"\"\"\nnode = get_node_from_simple_text(text)\n# Test a theorem-like environment being counted by the counter of\n# another theorem-like environment\nnumbertheorem_counters = {'corollary': ('theorem', None), 'theorem': ('theorem', None)}\nnumberwithins = {}\ncounters = {'theorem': 0}\nsample_numbering = _node_numbering(\n    node, numbertheorem_counters, numberwithins, counters)\ntest_eq(sample_numbering, '0')\n\n# Test a theorem-like environment whose counter is numbered within\n# The section counter.\n# First, see what happens when a theorem is called\ntext = r\"\"\"\\begin{theorem}This is a theorem. \\end{theorem}\"\"\"\nnode = get_node_from_simple_text(text)\nnumbertheorem_counters = {'theorem': ('theorem', None)}\nnumberwithins = {'theorem': 'section'}\ncounters = {'section': 1, 'theorem': 0}\nsample_numbering = _node_numbering(\n    node, numbertheorem_counters, numberwithins, counters)\ntest_eq(sample_numbering, '1.0')\n\n# Next, see what happens when a new section is invoked:\ntext = r\"\"\"\\section{New section! The theorem counter should be reset}\"\"\"\nnode = get_node_from_simple_text(text)\nsample_numbering = _node_numbering(\n    node, numbertheorem_counters, numberwithins, counters)\ntest_eq(sample_numbering, '1')\n\n# Test a theorem-like environment sharing a counter with equation\n# and in turn equation is numbered within section.\ntext = r\"\"\"\\begin{theorem}This is a theorem. \\end{theorem}\"\"\"\nnode = get_node_from_simple_text(text)\nnumbertheorem_counters = {'theorem': ('equation', None)}\nnumberwithins = {'equation': 'section'}\ncounters = {'section': 1, 'equation': 0}\nsample_numbering = _node_numbering(\n    node, numbertheorem_counters, numberwithins, counters)\ntest_eq(sample_numbering, '1.0')\n# Next, see what happens when a new section is invoked:\ntext = r\"\"\"\\section{New section! The theorem counter should be reset}\"\"\"\nnode = get_node_from_simple_text(text)\nsample_numbering = _node_numbering(\n    node, numbertheorem_counters, numberwithins, counters)\ntest_eq(sample_numbering, '1')\n\n\nsource\n\n\nswap_numbers_invoked\n\n swap_numbers_invoked (preamble:str)\n\n*Returns True if \\swapnumbers is in the preamble.\nAssume that a mention of \\swapnumbers is an actual invocation.*\n\n\n\n\nType\nDetails\n\n\n\n\npreamble\nstr\n\n\n\nReturns\nbool\n\n\n\n\n\nassert swap_numbers_invoked(r'\\swapnumbers')\nassert not swap_numbers_invoked(r'''\n\\documentclass{article}\n\\usepackage{amsthm}\n\n\n\\newtheorem{theorem}{Theorem} % \\swapnumbers\n\\newtheorem{corollary}[theorem]{Corollary}\n\\newtheorem{definition}[theorem]{Definition}\n\\newtheorem*{remark*}{Remark}''')\n\n\nsource\n\n\ndivide_latex_text\n\n divide_latex_text (document:str, dir:Optional[os.PathLike],\n                    environments_to_not_divide_along:list[str]=['align',\n                    'align*', 'diagram', 'displaymath', 'displaymath*',\n                    'enumerate', 'eqnarray', 'eqnarray*', 'equation',\n                    'equation*', 'gather', 'gather*', 'itemize', 'label',\n                    'multiline', 'multiline*', 'multline', 'multline*',\n                    'proof', 'quote', 'tabular', 'table'],\n                    replace_commands_in_document_first:bool=True,\n                    repeat_replacing_commands:int=-1)\n\n*Divide LaTeX text to convert into Obsidian.md notes.\nAssumes that the counters in the LaTeX document are either the predefined ones or specified by the \\newtheorem command.\nProof environments are assigned to the same parts their prcededing theorem-like environments, if available.\nTODO: Implement counters specified by \\newcounter, cf.  https://www.overleaf.com/learn/latex/Counters#LaTeX_commands_for_working_with_counters.*\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndocument\nstr\n\n\n\n\ndir\nOptional\n\nThe directory where the included files and style files are to be found.\n\n\nenvironments_to_not_divide_along\nlist\n[‘align’, ‘align’, ’diagram’, ’displaymath’, ’displaymath’, ‘enumerate’, ‘eqnarray’, ‘eqnarray’, ’equation’, ’equation’, ‘gather’, ‘gather’, ’itemize’, ’label’, ’multiline’, ’multiline’, ‘multline’, ’multline*‘, ’proof’, ‘quote’, ‘tabular’, ‘table’]\nA list of the names of the environemts along which to not make a new note, unless the environment starts a section (or the entire document).\n\n\nreplace_commands_in_document_first\nbool\nTrue\nIf True, invoke replace_commands_in_latex_document on document to first replace custom commands (in the document minus the preamble) before starting to divide the document.\n\n\nrepeat_replacing_commands\nint\n-1\nIf replace_commands_in_document_first is True, then this is passed as the repeat argument into the invocation of replace_commands_in_latex_document.\n\n\nReturns\nlist\n\nEach tuple is of the form (note_title, text), where note_title often encapsulates the note type (i.e. section/subsection/display text of a theorem-like environment) along with the numbering and text is the text of the part. Sometimes title is just a number, which means that text is not of a \\section or \\subsection command and not of a theorem-like environment.\n\n\n\n\ndir = _test_directory() / 'latex_examples' / 'divide_latex_example_text_with_gather_environment'\nfile =  dir / 'main.tex'\nsample_latex_text = text_from_file(file)\n# print(sample_latex_text)\npreamble, document = divide_preamble(sample_latex_text)\nparts = divide_latex_text(sample_latex_text, dir)\nprint(parts)\n\n[['1. Introduction', '\\\\section{Introduction}\\n\\nThere is an equation\\n\\\\begin{align*}\\nasdf\\n\\\\end{align*}\\nbut this equation should not get to start its own part.\\n\\n']]\n\n\n\nExamples for the divide_latex_text function\nIn the following example, we take a basic LaTeX file and divide it into parts:\n\ndir = _test_directory() / 'latex_examples' / 'divide_latex_example_proof_preceded_by_theorem'\nfile = dir / 'main.tex'\nsample_latex_text = text_from_file(file)\nprint(sample_latex_text)\n\n\n\\documentclass[10pt]{article}\n\n\\theoremstyle{plain}\n\\newtheorem*{theorem*}{Theorem}\n\\newtheorem*{theoremA}{Theorem A}\n\\newtheorem*{theoremB}{Theorem B}\n\\newtheorem{theorem}[equation]{Theorem}\n\\newtheorem{proposition}[equation]{Proposition}\n\\newtheorem{lemma}[equation]{Lemma}\n\\newtheorem{corollary}[equation]{Corollary}\n\n\\theoremstyle{definition}\n\\newtheorem{definition}[equation]{Definition}\n\\newtheorem{example}[equation]{Example}\n\\newtheorem*{acknowledgements}{Acknowledgements}\n\\newtheorem*{conventions}{Conventions}\n\n\\theoremstyle{remark}\n\\newtheorem{remark}[equation]{Remark}\n\n\n\n\\begin{document}\n\\section{Some section}\n\n\\begin{theorem}\nThis is a theorem.\n\\end{theorem}\n\n\\begin{proof}\nThis is a proof\n\\end{proof}\n\n\\end{document}\n\n\nThe divide_preamble function recognizes where the preamble ends and where the document begins.\n\npreamble, document = divide_preamble(sample_latex_text)\n\n\nprint(preamble)\n\n\n\\documentclass[10pt]{article}\n\n\\theoremstyle{plain}\n\\newtheorem*{theorem*}{Theorem}\n\\newtheorem*{theoremA}{Theorem A}\n\\newtheorem*{theoremB}{Theorem B}\n\\newtheorem{theorem}[equation]{Theorem}\n\\newtheorem{proposition}[equation]{Proposition}\n\\newtheorem{lemma}[equation]{Lemma}\n\\newtheorem{corollary}[equation]{Corollary}\n\n\\theoremstyle{definition}\n\\newtheorem{definition}[equation]{Definition}\n\\newtheorem{example}[equation]{Example}\n\\newtheorem*{acknowledgements}{Acknowledgements}\n\\newtheorem*{conventions}{Conventions}\n\n\\theoremstyle{remark}\n\\newtheorem{remark}[equation]{Remark}\n\n\n\n\n\n\n\nprint(document)\n\n\\begin{document}\n\\section{Some section}\n\n\\begin{theorem}\nThis is a theorem.\n\\end{theorem}\n\n\\begin{proof}\nThis is a proof\n\\end{proof}\n\n\\end{document}\n\n\nThe divide_latex_text function divides the LaTeX document into parts, generally based on setions and theorem-like environments:\n\nparts = divide_latex_text(sample_latex_text, dir)\nprint(parts)\ntest_eq(len(parts), 2)\n\n[['1. Some section', '\\\\section{Some section}\\n\\n'], ['Theorem 1.', '\\\\begin{theorem}\\nThis is a theorem.\\n\\\\end{theorem}\\\\begin{proof}\\nThis is a proof\\n\\\\end{proof}']]\n\n\nIn the next example, we have some enumerate environments to list out some things. The divide_latex_text does not create a new part of the enumerate environment.\n\ndir = _test_directory() / 'latex_examples' / 'divide_latex_example_text_preceded_by_undivided_environment' /_test_directory() / 'latex_examples' / 'divide_latex_example_text_preceded_by_undivided_environment'\nfile = dir / 'main.tex'\nsample_latex_text = text_from_file(file)\nprint(sample_latex_text)\n\n% In this example, there are enumerate environments, which should not get their\n% own `part`, cf. `divide_latex_text` in `16_latex.convert.ipynb`.\n\\documentclass[10pt]{article}\n\\usepackage{amsmath}\n\\usepackage{amsfonts}\n\\begin{document}\n\n\\section{Introduction}\n\nBlahblahblah, this document has some lists.\nThe `divide_latex_text` should not create a separate part for the below `enumerate`\nenvironment; after all, it seems better to include the list in the same file/note\nas the text that provides context for the list.\n\n\\begin{enumerate}\n  \\item Rings\n  \\item Fields\n\\end{enumerate}\n\nAnd here is another list, perhaps a grocery list:\n\n\\begin{enumerate}\n  \\setcounter{enumi}{3}\n  \\item apples\n  \\item bananas\n  \\item milk\n\\end{enumerate}\n\nLalalala\n\n\\end{document}\n\n\n\npreamble, document = divide_preamble(sample_latex_text)\nparts = divide_latex_text(document, dir)\nprint(parts)\ntest_eq(len(parts), 1)\n\n[['1. Introduction', '\\\\section{Introduction}\\n\\nBlahblahblah, this document has some lists.\\nThe `divide_latex_text` should not create a separate part for the below `enumerate`\\nenvironment; after all, it seems better to include the list in the same file/note\\nas the text that provides context for the list.\\n\\n\\\\begin{enumerate}\\n  \\\\item Rings\\n  \\\\item Fields\\n\\\\end{enumerate}\\n\\nAnd here is another list, perhaps a grocery list:\\n\\n\\\\begin{enumerate}\\n  \\\\setcounter{enumi}{3}\\n  \\\\item apples\\n  \\\\item bananas\\n  \\\\item milk\\n\\\\end{enumerate}\\n\\nLalalala\\n\\n']]\n\n\n\ndir = _test_directory() / 'latex_examples' / 'divide_latex_example_2'\nfile = dir / 'main.tex'\nsample_latex_text = text_from_file(file)\npreamble, document = divide_preamble(sample_latex_text)\nparts = divide_latex_text(document, dir)\nprint(parts)\n\n[['1', '\\\\maketitle'], ['abstract', '\\\\begin{abstract}\\nThis is an abstract\\n\\\\end{abstract}']]\n\n\nThe divide_latex_text function by default divides along a LaTeX environment (something which is invoked by \\begin{...} \\end{...}). One can use the optional environments_to_not_divide_along parameter in the function to specify which environments to not divide along. By default, this list is set as follows:\n\nDEFAULT_ENVIRONMENTS_TO_NOT_DIVIDE_ALONG\n\n['align',\n 'align*',\n 'diagram',\n 'displaymath',\n 'displaymath*',\n 'enumerate',\n 'eqnarray',\n 'eqnarray*',\n 'equation',\n 'equation*',\n 'gather',\n 'gather*',\n 'itemize',\n 'label',\n 'multiline',\n 'multiline*',\n 'multline',\n 'multline*',\n 'proof',\n 'quote',\n 'tabular',\n 'table']\n\n\nIn the following example, the theorem, corollary, and definition environments share a counter, which is not reset even when a new section begins.\n\ndir = _test_directory() / 'latex_examples' / 'numbering_example_1_consecutive_numbering_scheme'\nfile = dir / 'main.tex'\ntext = text_from_file(file)\nprint(text)\n\n\\documentclass{article}\n\\usepackage{amsthm}\n%\\usepackage{amsmath}\n\n\\newtheorem{theorem}{Theorem}\n\\newtheorem{corollary}[theorem]{Corollary}\n\\newtheorem{definition}[theorem]{Definition}\n\\newtheorem*{remark*}{Remark}\n\n%\\numberwithin{theorem}{part}\n\n\\begin{document}\nFor this document, the `theorem` counter is not reset whenever a new section begins.\n\nA similar numbering scheme can be accomplished by importing \\verb|amsmath| and invoking the code \\verb|\\numberwithin{theorem}{part}| in the preamble.\n\n\\section{Introduction}\n\n\\begin{theorem}\nThis is Theorem 1.\n\\end{theorem}\n\n\\begin{corollary}\nThis is Corollary 2.\n\\end{corollary}\n\n\\begin{remark*}\nThis is a remark. It is unnumbered and it does not affect the numberings of other environments.\n\\end{remark*}\n\n\\begin{definition}\nThis is Definition 3.\n\\end{definition}\n\n\n\n\\section{Another Section}\n\n\\begin{theorem}\nThis is Theorem 4.\n\\end{theorem}\n\nAnd we might get a corollary!\n\n\\begin{corollary}\nThis is Corollary 5.\n\\end{corollary}\n\n\\begin{definition}\nThis is Definition 6.\n\\end{definition}\n\n\\end{document}\n\n\n\nsample_output = divide_latex_text(text, dir)\nsample_output\n\n[['1',\n  'For this document, the `theorem` counter is not reset whenever a new section begins.\\n\\nA similar numbering scheme can be accomplished by importing \\\\verb|amsmath| and invoking the code \\\\verb|\\\\numberwithin{theorem}{part}| in the preamble.'],\n ['1. Introduction', '\\\\section{Introduction}\\n\\n'],\n ['Theorem 1.', '\\\\begin{theorem}\\nThis is Theorem 1.\\n\\\\end{theorem}'],\n ['Corollary 2.',\n  '\\\\begin{corollary}\\nThis is Corollary 2.\\n\\\\end{corollary}'],\n ['Remark',\n  '\\\\begin{remark*}\\nThis is a remark. It is unnumbered and it does not affect the numberings of other environments.\\n\\\\end{remark*}'],\n ['Definition 3.',\n  '\\\\begin{definition}\\nThis is Definition 3.\\n\\\\end{definition}'],\n ['2. Another Section', '\\\\section{Another Section}\\n\\n'],\n ['Theorem 4.', '\\\\begin{theorem}\\nThis is Theorem 4.\\n\\\\end{theorem}'],\n ['2', 'And we might get a corollary!'],\n ['Corollary 5.',\n  '\\\\begin{corollary}\\nThis is Corollary 5.\\n\\\\end{corollary}'],\n ['Definition 6.',\n  '\\\\begin{definition}\\nThis is Definition 6.\\n\\\\end{definition}']]\n\n\n\nassert sample_output[0][0] == '1'\nassert sample_output[1][0] == '1. Introduction'\nassert sample_output[2][0] == 'Theorem 1.'\nassert sample_output[3][0] == 'Corollary 2.'\nassert sample_output[4][0] == 'Remark'\n\nIn the following example, the \\numerwithin command is used to make the theorem-like environments numbered within sections. These environments are first numbered 1.1, 1.2, 1.3, etc., and then numbered 2.1, 2.2, 2.3, etc. once a new section starts.\n\ndir = _test_directory() / 'latex_examples' / 'numbering_example_2_numbering_scheme_reset_at_each_section'\nfile = dir / 'main.tex'\ntext = text_from_file(file)\nprint(text)\n\n% This is an example of a LaTeX document whose theorem-like environments are numbered with sections.\n\n\\documentclass{article}\n\\usepackage{amsthm}\n\\usepackage{amsmath}\n\n\\newtheorem{theorem}{Theorem}\n\\newtheorem{corollary}[theorem]{Corollary}\n\\newtheorem{definition}[theorem]{Definition}\n\\newtheorem*{remark*}{Remark}\n\n\\numberwithin{theorem}{section}\n\n\\begin{document}\n\nThis document resets its `theorem` counter whenever a new section begins.\n\n\\section{Introduction}\n\n\\begin{theorem}\nThis is Theorem 1.1.\n\\end{theorem}\n\n\\begin{corollary}\nThis is Corollary 1.2.\n\\end{corollary}\n\n\\begin{remark*}\nThis is a remark. It is unnumbered and it does not affect the numberings of other environments.\n\\end{remark*}\n\n\n\\begin{definition}\nThis is Definition 1.3.\n\\end{definition}\n\n\n\n\\section{Another Section}\n\n\\begin{theorem}\nThis is Theorem 2.1.\n\\end{theorem}\n\n\\begin{corollary}\nThis is Corollary 2.2.\n\\end{corollary}\n\n\\begin{definition}\nThis is Definition 2.3.\n\\end{definition}\n\n\\end{document}\n\n\n\n\ndivide_latex_text(text, dir)\n\n[['1',\n  'This document resets its `theorem` counter whenever a new section begins.'],\n ['1. Introduction', '\\\\section{Introduction}\\n\\n'],\n ['Theorem 1.1.', '\\\\begin{theorem}\\nThis is Theorem 1.1.\\n\\\\end{theorem}'],\n ['Corollary 1.2.',\n  '\\\\begin{corollary}\\nThis is Corollary 1.2.\\n\\\\end{corollary}'],\n ['Remark',\n  '\\\\begin{remark*}\\nThis is a remark. It is unnumbered and it does not affect the numberings of other environments.\\n\\\\end{remark*}'],\n ['Definition 1.3.',\n  '\\\\begin{definition}\\nThis is Definition 1.3.\\n\\\\end{definition}'],\n ['2. Another Section', '\\\\section{Another Section}\\n\\n'],\n ['Theorem 2.1.', '\\\\begin{theorem}\\nThis is Theorem 2.1.\\n\\\\end{theorem}'],\n ['Corollary 2.2.',\n  '\\\\begin{corollary}\\nThis is Corollary 2.2.\\n\\\\end{corollary}'],\n ['Definition 2.3.',\n  '\\\\begin{definition}\\nThis is Definition 2.3.\\n\\\\end{definition}']]\n\n\nIn this example, the various theorem-like environments share a counter with equation environments and this counter is reset at the start of each new section.\n\ndir = _test_directory() / 'latex_examples' / 'numbering_example_3_theorem_like_environments_share_counter_with_equation_and_reset_at_each_section' \nfile = dir / 'main.tex'\ntext = text_from_file(file)\nprint(text)\n\n\\documentclass{amsart}\n\\usepackage[utf8]{inputenc}\n\\usepackage{amsmath, amsfonts, amssymb, amsthm, amsopn}\n\n\\numberwithin{equation}{section}\n\n\\theoremstyle{plain}\n\\newtheorem*{theorem*}{Theorem}\n\\newtheorem*{theoremA}{Theorem A}\n\\newtheorem*{theoremB}{Theorem B}\n\\newtheorem{theorem}[equation]{Theorem}\n\\newtheorem{proposition}[equation]{Proposition}\n\\newtheorem{lemma}[equation]{Lemma}\n\\newtheorem{corollary}[equation]{Corollary}\n\n\\theoremstyle{definition}\n\\newtheorem{definition}[equation]{Definition}\n\\newtheorem{example}[equation]{Example}\n\\newtheorem*{acknowledgements}{Acknowledgements}\n\\newtheorem*{conventions}{Conventions}\n\n\\theoremstyle{remark}\n\\newtheorem{remark}[equation]{Remark}\n\n\\begin{document}\n\n\\section{Introduction}\n\n\\begin{theorem}\nThis is Theorem 1.1. This is because the \\verb|\\numberwithin{equation}{section}| makes the section number included in the equation counter and because the \\\\\n\\verb|\\newtheorem{theorem}[equation]{Theorem}| command makes the environment \\verb|theorem| be counted by the equation counter.\n\\end{theorem}\n\nThe following makes an equation labeled 1.2; \n\\begin{equation}\n5 + 7 = 12\n\\end{equation}\n\n\\begin{theorem*}\nThis Theorem is unnumbered\n\\end{theorem*}\n\n\\begin{corollary}\nThis is Corollary 1.3.\n\\end{corollary}\n\n\\section{Another section}\n\\begin{theorem}\nThis is theorem 2.1\n\\end{theorem}\n\nThe following is labeled 2.2:\n\\begin{equation}\n3+5 = 8.\n\\end{equation}\n\n\\end{document}\n\n\n\ndir = _test_directory() / 'latex_examples' / 'numbering_example_3_theorem_like_environments_share_counter_with_equation_and_reset_at_each_section'\nfile = dir / 'main.tex'\ntext = text_from_file(file)\ndivide_latex_text(text, dir)\n\n[['1. Introduction', '\\\\section{Introduction}\\n\\n'],\n ['Theorem 1.1.',\n  '\\\\begin{theorem}\\nThis is Theorem 1.1. This is because the \\\\verb|\\\\numberwithin{equation}{section}| makes the section number included in the equation counter and because the \\\\\\\\\\n\\\\verb|\\\\newtheorem{theorem}[equation]{Theorem}| command makes the environment \\\\verb|theorem| be counted by the equation counter.\\n\\\\end{theorem}'],\n ['1',\n  'The following makes an equation labeled 1.2; \\n\\\\begin{equation}\\n5 + 7 = 12\\n\\\\end{equation}'],\n ['Theorem', '\\\\begin{theorem*}\\nThis Theorem is unnumbered\\n\\\\end{theorem*}'],\n ['Corollary 1.3.',\n  '\\\\begin{corollary}\\nThis is Corollary 1.3.\\n\\\\end{corollary}'],\n ['2. Another section', '\\\\section{Another section}\\n'],\n ['Theorem 2.1.', '\\\\begin{theorem}\\nThis is theorem 2.1\\n\\\\end{theorem}'],\n ['2',\n  'The following is labeled 2.2:\\n\\\\begin{equation}\\n3+5 = 8.\\n\\\\end{equation}']]\n\n\n\ndir = _test_directory() / 'latex_examples' / 'numbering_example_4_unnumbered_section'\nfile = dir / 'main.tex'\ntext = text_from_file(file)\nprint(divide_latex_text(text, dir))\n\n[['1. This is section 1', '\\\\section{This is section 1}\\n\\n'], ['Theorem 1.1.', '\\\\begin{theorem}\\nThis is Theorem 1.1.\\n\\\\end{theorem}'], ['1.1. This is a subsection 1.1', '\\\\subsection{This is a subsection 1.1}\\n\\nThe following makes an equation labeled 1; \\n\\\\begin{equation}\\n5 + 7 = 12\\n\\\\end{equation}\\n\\n'], ['Theorem', '\\\\begin{theorem*}\\nThis Theorem is unnumbered\\n\\\\end{theorem*}'], ['1.2. This is subsection 1.2', '\\\\subsection{This is subsection 1.2}\\n\\n'], ['Corollary 1.2.', '\\\\begin{corollary}\\nThis is Corollary 1.2.\\n\\\\end{corollary}'], ['1. Unnumbered section', '\\\\section*{Unnumbered section}\\n\\n'], ['1.1. This is subsection 1.3', '\\\\subsection{This is subsection 1.3}\\n'], ['1.1.1. This is subsubsection 1.3.1', '\\\\subsubsection{This is subsubsection 1.3.1}\\n\\n'], ['Theorem 1.1.', '\\\\begin{theorem}\\nThis is Theorem 1.3.\\n\\\\end{theorem}'], ['2. Another section', '\\\\section{Another section}\\n\\n'], ['2.1. This is subsection 2.1', '\\\\subsection{This is subsection 2.1}\\n\\n'], ['Theorem 2.1.', '\\\\begin{theorem}\\nThis is Theorem 2.1\\n\\\\end{theorem}'], ['1', 'The following is labeled 2; note that the equation counter was not reset by section:\\n\\\\begin{equation}\\n3+5 = 8.\\n\\\\end{equation}']]\n\n\n\ndir = _test_directory() / 'latex_examples' / 'numbering_example_5_subsections_and_theorem_like_environments_share_counter'\nfile = dir / 'main.tex'\ntext = text_from_file(file)\nsample_output = divide_latex_text(text, dir)\nprint(divide_latex_text(text, dir))\ntest_eq(sample_output[4][0], '1. Remark.')\ntest_eq(sample_output[5][0], 'Remark')\n\n[['1. This is section 1', '\\\\section{This is section 1}\\n\\n'], ['1.1. Theorem.', '\\\\begin{thm}\\nThis is 1.1. Theorem. Note that the \\\\verb|\\\\swapnumbers| command is invoked in the preamble.\\n\\\\end{thm}'], ['1.2. This is 1.2. subsection.', '\\\\subsection{This is 1.2. subsection.}\\n\\nNote that the equation counter is numbered within the subsection counter and that the theorem-like environments are numbered with the equation counter.\\n\\n'], ['1.2.1. This is 1.2.1. Subsubsection', '\\\\subsubsection{This is 1.2.1. Subsubsection}\\n\\n'], ['1. Remark.', '\\\\begin{remark}\\nThis is an 1. Remark. Note that \\\\verb|\\\\remark| has a counter separate from those of many of the other theorem-like environments.\\n\\\\end{remark}'], ['Remark', '\\\\begin{rem*}\\nThis is an unnumbered Remark.\\n\\\\end{rem*}'], ['1.3. Proposition.', '\\\\begin{prop}\\nThis is 1.3. Proposition.\\n\\\\end{prop}'], ['1. Unnumbered section', '\\\\section*{Unnumbered section}\\n\\n'], ['1.1. Theorem.', '\\\\begin{thm}\\nThis is 1.4. Theorem.\\n\\\\end{thm}'], ['2. This is Section 2', '\\\\section{This is Section 2}\\n\\n'], ['2.1. Theorem.', '\\\\begin{thm}\\nThis is 2.1. Theorem\\n\\\\end{thm}']]\n\n\nIn the below example, the theorem count is specified to reset at every new section and the corollary environment is specified to reset at every new theorem.\nIn particular, note that there is a Theorem 1.2 and a subsequent Corollary 1.2.1 in the example:\n\ndir = _test_directory() / 'latex_examples' / 'numbering_example_7_newtheorem_command_restarts_counter_by_section'\nfile = dir / 'main.tex'\ntext = text_from_file(file) \nprint(text)\nsample_output = divide_latex_text(text, dir )\nprint(divide_latex_text(text, dir))\ntest_eq(sample_output[4][0], 'Corollary 1.2.1.')\n\n\n% Based on an example from https://www.overleaf.com/learn/latex/Theorems_and_proofs#Numbered_theorems.2C_definitions.2C_corollaries_and_lemmas\n\n\\documentclass[12 pt]{amsart}\n\n\\newtheorem{theorem}{Theorem}[section]\n\\newtheorem{corollary}{Corollary}[theorem]\n\\newtheorem{lemma}[theorem]{Lemma}\n% Note that the below invocation of \\newtheorem is invalid:\n% \\newtheorem{proposition}[theorem]{Proposition}[section]\n\\newtheorem{proposition}{Proposition}[section]\n\n\\begin{document}\n\\section{Introduction}\nTheorems can easily be defined:\n\n\\begin{theorem}\nLet \\(f\\) be a function whose derivative exists in every point, then \\(f\\) is \na continuous function.\n\\end{theorem}\n\n\\begin{theorem}[Pythagorean theorem]\n\\label{pythagorean}\nThis is a theorem about right triangles and can be summarised in the next \nequation \n\\[ x^2 + y^2 = z^2 \\]\n\\end{theorem}\n\nAnd a consequence of theorem \\ref{pythagorean} is the statement in the next \ncorollary.\n\n\\begin{corollary}\nThere's no right rectangle whose sides measure 3cm, 4cm, and 6cm.\n\\end{corollary}\n\nYou can reference theorems such as \\ref{pythagorean} when a label is assigned.\n\n\\begin{lemma}\nGiven two line segments whose lengths are \\(a\\) and \\(b\\) respectively there is a \nreal number \\(r\\) such that \\(b=ra\\).\n\\end{lemma}\n\n\\end{document}\n\n\n[['1. Introduction', '\\\\section{Introduction}\\nTheorems can easily be defined:\\n\\n'], ['Theorem 1.1.', '\\\\begin{theorem}\\nLet \\\\(f\\\\) be a function whose derivative exists in every point, then \\\\(f\\\\) is \\na continuous function.\\n\\\\end{theorem}'], ['Theorem 1.2.', '\\\\begin{theorem}[Pythagorean theorem]\\n\\\\label{pythagorean}\\nThis is a theorem about right triangles and can be summarised in the next \\nequation \\n\\\\[ x^2 + y^2 = z^2 \\\\]\\n\\\\end{theorem}'], ['1', 'And a consequence of theorem \\\\ref{pythagorean} is the statement in the next \\ncorollary.'], ['Corollary 1.2.1.', \"\\\\begin{corollary}\\nThere's no right rectangle whose sides measure 3cm, 4cm, and 6cm.\\n\\\\end{corollary}\"], ['2', 'You can reference theorems such as \\\\ref{pythagorean} when a label is assigned.'], ['Lemma 1.3.', '\\\\begin{lemma}\\nGiven two line segments whose lengths are \\\\(a\\\\) and \\\\(b\\\\) respectively there is a \\nreal number \\\\(r\\\\) such that \\\\(b=ra\\\\).\\n\\\\end{lemma}']]\n\n\nNote that part titles are stripped and are single-lined:\n\n# TODO: fill in the following example\n# part = parts[...]\n# assert part[0].strip() == part[0]\n\nIn the following example, the subsections and the theorem-like environments share a counter:\n\ndir = _test_directory() / 'latex_examples' / 'numbering_example_8_subsubsections_and_theorems_share_counter'\nfile = dir / 'main.tex'\ntext = text_from_file(file) \nprint(text)\nsample_output = divide_latex_text(text, dir)\nprint(sample_output)\ntest_eq(sample_output[-1][0], 'Theorem 1.1.2.')\ntest_eq(sample_output[-2][0], '1.1.1. section 1.1.1')\n\n\n% Based on an example from https://www.overleaf.com/learn/latex/Theorems_and_proofs#Numbered_theorems.2C_definitions.2C_corollaries_and_lemmas\n\n\\documentclass[12 pt]{amsart}\n\n\\newtheorem{cor}[subsubsection]{Corollary}\n\\newtheorem{lem}[subsubsection]{Lemma}\n\\newtheorem{prop}[subsubsection]{Proposition}\n\\newtheorem{propconstr}[subsubsection]{Proposition-Construction}\n\\newtheorem{lemconstr}[subsubsection]{Lemma-Construction}\n\\newtheorem{ax}[subsubsection]{Axiom}\n\\newtheorem{conj}[subsubsection]{Conjecture}\n\\newtheorem{thm}[subsubsection]{Theorem}\n\\newtheorem{qthm}[subsubsection]{Quasi-Theorem}\n\\newtheorem{qlem}[subsubsection]{Quasi-Lemma}\n\\newtheorem{defn}[subsubsection]{Definition}\n\\newtheorem{quest}[subsubsection]{Question}\n\\newtheorem{claim}[subsubsection]{Claim}\n\n\\begin{document}\n\\section{Introduction}\n\n\\subsection{section 1.1}\n\n\\subsubsection{section 1.1.1}\n\n\\begin{thm}\nThis is theorem 1.1.2\n\\end{thm}\n\n\\end{document}\n\n\n[['1. Introduction', '\\\\section{Introduction}\\n\\n'], ['1.1. section 1.1', '\\\\subsection{section 1.1}\\n\\n'], ['1.1.1. section 1.1.1', '\\\\subsubsection{section 1.1.1}\\n\\n'], ['Theorem 1.1.2.', '\\\\begin{thm}\\nThis is theorem 1.1.2\\n\\\\end{thm}']]\n\n\nIn the below example, note that there is some text immediately following the subsubsection; the “part” for the start of the subsubsection is joined by this following text:\n\ndir = _test_directory() / 'latex_examples' / 'divide_latex_example_text_after_subsubsection'\nfile = dir / 'main.tex'\nsample_latex_text = text_from_file(file)\nprint(sample_latex_text)\npreamble, document = divide_preamble(sample_latex_text)\nparts = divide_latex_text(sample_latex_text, dir)\nprint(parts)\ntest_eq(parts[2], ['1.1.1. section 1.1.1', '\\\\subsubsection{section 1.1.1}\\nSome text beneath subsubsection\\n'])\n\n\n% Based on an example from https://www.overleaf.com/learn/latex/Theorems_and_proofs#Numbered_theorems.2C_definitions.2C_corollaries_and_lemmas\n\n\\documentclass[12 pt]{amsart}\n\n\\newtheorem{cor}[subsubsection]{Corollary}\n\\newtheorem{lem}[subsubsection]{Lemma}\n\\newtheorem{prop}[subsubsection]{Proposition}\n\\newtheorem{propconstr}[subsubsection]{Proposition-Construction}\n\\newtheorem{lemconstr}[subsubsection]{Lemma-Construction}\n\\newtheorem{ax}[subsubsection]{Axiom}\n\\newtheorem{conj}[subsubsection]{Conjecture}\n\\newtheorem{thm}[subsubsection]{Theorem}\n\\newtheorem{qthm}[subsubsection]{Quasi-Theorem}\n\\newtheorem{qlem}[subsubsection]{Quasi-Lemma}\n\\newtheorem{defn}[subsubsection]{Definition}\n\\newtheorem{quest}[subsubsection]{Question}\n\\newtheorem{claim}[subsubsection]{Claim}\n\n\\begin{document}\n\\section{Introduction}\n\n\\subsection{section 1.1}\n\n\\subsubsection{section 1.1.1}\nSome text beneath subsubsection\n\\begin{thm}\nThis is theorem 1.1.2\n\\end{thm}\n\n\\end{document}\n\n\n[['1. Introduction', '\\\\section{Introduction}\\n\\n'], ['1.1. section 1.1', '\\\\subsection{section 1.1}\\n\\n'], ['1.1.1. section 1.1.1', '\\\\subsubsection{section 1.1.1}\\nSome text beneath subsubsection\\n'], ['Theorem 1.1.2.', '\\\\begin{thm}\\nThis is theorem 1.1.2\\n\\\\end{thm}']]\n\n\nIn the below example, theorem-like environments and equation environments share a counter and there is an equation within a theorem:\n\ndir = _test_directory() / 'latex_examples' / 'divide_latex_example_theorems_and_equations_share_counter_and_equation_in_theorem'\nfile = dir / 'main.tex'\nsample_latex_text = text_from_file(file)\nprint(sample_latex_text)\npreamble, document = divide_preamble(sample_latex_text)\nparts = divide_latex_text(sample_latex_text, dir)\nprint(parts)\ntest_eq(parts[2], ['Corollary 1.3.', '\\\\begin{cor}\\nThis is Corollary 1.3\\n\\\\end{cor}'])\n\n\n\\documentclass[12pt]{amsart}\n\\usepackage{amsmath}\n\\usepackage{amsfonts}\n\n\n\\numberwithin{equation}{section}\n\\numberwithin{figure}{section}\n\n\\newtheorem{lemma}[equation]{Lemma}\n\\newtheorem{theorem}[equation]{Theorem}\n\\newtheorem{conjecture}[equation]{Conjecture}\n\\newtheorem{cor}[equation]{Corollary}\n\\newtheorem{prop}[equation]{Proposition}\n\n\\begin{document}\n\n\\section{Introduction}\n\n\\begin{theorem}\n\\begin{equation}\nasdf\n\\end{equation}\n\\end{theorem}\n\n\\begin{cor}\nThis is Corollary 1.3\n\\end{cor}\n\n\\end{document}\n[['1. Introduction', '\\\\section{Introduction}\\n\\n'], ['Theorem 1.1.', '\\\\begin{theorem}\\n\\\\begin{equation}\\nasdf\\n\\\\end{equation}\\n\\\\end{theorem}'], ['Corollary 1.3.', '\\\\begin{cor}\\nThis is Corollary 1.3\\n\\\\end{cor}']]\n\n\nIn the below example, theorem-like environments and equation environments share a counter and there is an equation within the proof of a proposition:\n\ndir = _test_directory() / 'latex_examples' / 'divide_latex_example_equation_in_proof'\nfile = dir / 'main.tex'\nsample_latex_text = text_from_file(file)\nprint(sample_latex_text)\npreamble, document = divide_preamble(sample_latex_text)\nparts = divide_latex_text(sample_latex_text, dir)\nprint(parts)\ntest_eq(parts[2], ['Corollary 1.3.', '\\\\begin{cor}\\nThis is Corollary 1.3\\n\\\\end{cor}'])\n\n\n\\documentclass[12pt]{amsart}\n\\usepackage{amsmath}\n\\usepackage{amsfonts}\n\n\n\\numberwithin{equation}{section}\n\\numberwithin{figure}{section}\n\n\\newtheorem{lemma}[equation]{Lemma}\n\\newtheorem{theorem}[equation]{Theorem}\n\\newtheorem{conjecture}[equation]{Conjecture}\n\\newtheorem{cor}[equation]{Corollary}\n\\newtheorem{prop}[equation]{Proposition}\n\n\\begin{document}\n\n\\section{Introduction}\n\n\\begin{prop}\nThis is Proposition 1.1\n\\end{prop}\n\\begin{proof}\n\\begin{equation}\n\\end{equation}\n\\end{proof}\n\n\\begin{cor}\nThis is Corollary 1.3\n\\end{cor}\n\n\\end{document}\n[['1. Introduction', '\\\\section{Introduction}\\n\\n'], ['Proposition 1.1.', '\\\\begin{prop}\\nThis is Proposition 1.1\\n\\\\end{prop}\\\\begin{proof}\\n\\\\begin{equation}\\n\\\\end{equation}\\n\\\\end{proof}'], ['Corollary 1.3.', '\\\\begin{cor}\\nThis is Corollary 1.3\\n\\\\end{cor}']]\n\n\nIn the below example, theorem-like environments and equation environments share a counter and there is an eqnarray after the start of a section:\n\ndir = _test_directory() / 'latex_examples' / 'divide_latex_example_eqnarray_after_start_of_section'\nfile = dir / 'main.tex'\nsample_latex_text = text_from_file(file)\nprint(sample_latex_text)\npreamble, document = divide_preamble(sample_latex_text)\nparts = divide_latex_text(sample_latex_text, dir)\nprint(parts)\ntest_eq(parts[1], ['Proposition 1.2.', '\\\\begin{prop}\\nThis is Proposition 1.2\\n\\\\end{prop}'])\n\n\n\\documentclass[12pt]{amsart}\n\\usepackage{amsmath}\n\\usepackage{amsfonts}\n\n\n\\numberwithin{equation}{section}\n\\numberwithin{figure}{section}\n\n\\newtheorem{lemma}[equation]{Lemma}\n\\newtheorem{theorem}[equation]{Theorem}\n\\newtheorem{conjecture}[equation]{Conjecture}\n\\newtheorem{cor}[equation]{Corollary}\n\\newtheorem{prop}[equation]{Proposition}\n\n\\begin{document}\n\n\\section{Introduction}\nlalalala some stuff $5$\n\nHello I am saying stuff\n\\begin{eqnarray}\n\\end{eqnarray}\n\\begin{prop}\nThis is Proposition 1.2\n\\end{prop}\n\n\\end{document}\n[['1. Introduction', '\\\\section{Introduction}\\nlalalala some stuff $5$\\n\\nHello I am saying stuff\\n\\\\begin{eqnarray}\\n\\\\end{eqnarray}\\n'], ['Proposition 1.2.', '\\\\begin{prop}\\nThis is Proposition 1.2\\n\\\\end{prop}']]\n\n\nIn the below example, there are many custom commands deifned using the \\def command. Note that use of \\u in the LaTeX file, which causes problems for pylatexenc.\nThe divide_latex_text function had difficulties parsing through the latex document for the below example, specifically because this \\u command made pylatexenc unable to find the \\section following the \\u. Now that divide_latex_text provides the option to replace custom commands from the LaTeX document (with their underlying “meaning/definitions” via the replace_commands_in_latex_document function) before parsing through the LaTeX document, this is no longer a problem.\n\ndir = _test_directory() / 'latex_examples' / 'divide_latex_example_unknown_section_division_problem'\nfile = dir / 'main.tex'\nsample_latex_text = text_from_file(file)\n# print(sample_latex_text)\npreamble, document = divide_preamble(sample_latex_text)\nparts = divide_latex_text(sample_latex_text, dir)\n# test_eq(parts[1], ['Proposition 1.2.', '\\\\begin{prop}\\nThis is Proposition 1.2\\n\\\\end{prop}'])\ntest_eq(len(parts), 3)\nprint(parts)\n\n[['1. Background and Notation', '\\\\section{Background and Notation}\\n\\n'], ['1.1. Unitary groups', '\\\\subsection{Unitary groups}\\n\\\\label{subsecunitary}\\n\\nwhere $\\\\bm{{\\\\rm R}}_{{\\\\mathcal O}_E/{\\\\mathbb Z}}$ is the restriction of scalars functor.\\nThen $SU$ is the derived group of $GU$ and of ${\\\\rm U}$,\\n\\n'], ['2. Mumford-Tate groups and endomorphism rings', '\\\\section{Mumford-Tate groups and endomorphism rings}\\n\\n\\\\label{secmt}\\n\\nCarlson and Toledo have \\n\\n\\\\bibliographystyle{hamsplain}\\n\\\\bibliography{jda}\\n\\n']]\n\n\n\n# TODO: example with a multilined section title forced to single-lined:\n# e.g. `\\section{Exceptional maximal subgroups of \n# \\texorpdfstring{\\(\\GSp_4(\\ff_\\ell)\\)}{GSp4Fell}}`\n\n\n# TODO: Find a list of environment names commonly used.\n\n\n# TODO: examples with different numbering convention and different numbered environments\n\n\n# Here are some latex files with different conventions:\n# - Different environment types have different counts and the counts do not show the section number.\n#   - vankataramana_imbrd https://arxiv.org/abs/1205.6543: \n#       - e.g. section 1 has Theorem 1, Remark 1, Remark 2, Remark 3, subsection 1.1.3 has Remark 4, Subsection 2.2 has Definition 1",
    "crumbs": [
      "latex.divide"
    ]
  },
  {
    "objectID": "43_helper.topological_sort.html",
    "href": "43_helper.topological_sort.html",
    "title": "trouver",
    "section": "",
    "text": "# TODO: reformat the parameter specifications and add examples.\n\nIt is sometimes convenient to topological sort.\n\nsource\n\n\n\n natsort_comparison (str1:str, str2:str)\n\nParameters - str1 - str - str2 - str\n\nsource\n\n\n\n\n default_str_comparison (str1:str, str2:str)\n\nParameters - str1 - str - str2 - str\n\nsource\n\n\n\n\n containing_string_priority (str1:str, str2:str)\n\n*Returns 1, 0, -1 depending on whether one string contains the other.\nTODO make the string containment criterion looser, e.g. finite Galois etale cover “contains” finite etale cover.\nParameters - str1 - str - str2 - str*\n\nsource\n\n\n\n\n graph_for_topological_sort (items_to_sort:collections.abc.Iterable[str],\n                             key_order:Callable[[str,str],int])\n\n*Parameters - items_to_sort - Iterable[str] - key_order: Callable[[str, str], int] - Comparing str1 against str2 results in a positive number if str1 is “greater” than str2 (i.e. str1 is of a later priority)\nReturns - dict[str, set[str]] - A dict whose keys are the elements k of items_to_sort and whose values are sets of elements k2 of items_to_sort such that key_order(k, k2) &gt; 0.*\n\nsource\n\n\n\n\n dict_with_keys_topologically_sorted (dict_to_sort:dict[str],\n                                      key_order:Callable[[str,str],int],\n                                      reverse:bool=False)\n\n*Returns an OrderedDict whose keys are sorted topologically by the specified key order.\nParameters - dict_to_sort - dict[str] - The dict whose keys need to be ordered. - key_order - The comparison function on the keys of dict_to_sort. Defaults to the key function for the comparison [containing_string_priority](https://hyunjongkimmath.github.io/trouver/helper.topological_sort.html#containing_string_priority). - reverse - bool - Defaults to False\nReturns - OrderedDict[str]*\n\n# TODO: test",
    "crumbs": [
      "Topological sort"
    ]
  },
  {
    "objectID": "43_helper.topological_sort.html#topological-sort",
    "href": "43_helper.topological_sort.html#topological-sort",
    "title": "trouver",
    "section": "",
    "text": "# TODO: reformat the parameter specifications and add examples.\n\nIt is sometimes convenient to topological sort.\n\nsource\n\n\n\n natsort_comparison (str1:str, str2:str)\n\nParameters - str1 - str - str2 - str\n\nsource\n\n\n\n\n default_str_comparison (str1:str, str2:str)\n\nParameters - str1 - str - str2 - str\n\nsource\n\n\n\n\n containing_string_priority (str1:str, str2:str)\n\n*Returns 1, 0, -1 depending on whether one string contains the other.\nTODO make the string containment criterion looser, e.g. finite Galois etale cover “contains” finite etale cover.\nParameters - str1 - str - str2 - str*\n\nsource\n\n\n\n\n graph_for_topological_sort (items_to_sort:collections.abc.Iterable[str],\n                             key_order:Callable[[str,str],int])\n\n*Parameters - items_to_sort - Iterable[str] - key_order: Callable[[str, str], int] - Comparing str1 against str2 results in a positive number if str1 is “greater” than str2 (i.e. str1 is of a later priority)\nReturns - dict[str, set[str]] - A dict whose keys are the elements k of items_to_sort and whose values are sets of elements k2 of items_to_sort such that key_order(k, k2) &gt; 0.*\n\nsource\n\n\n\n\n dict_with_keys_topologically_sorted (dict_to_sort:dict[str],\n                                      key_order:Callable[[str,str],int],\n                                      reverse:bool=False)\n\n*Returns an OrderedDict whose keys are sorted topologically by the specified key order.\nParameters - dict_to_sort - dict[str] - The dict whose keys need to be ordered. - key_order - The comparison function on the keys of dict_to_sort. Defaults to the key function for the comparison [containing_string_priority](https://hyunjongkimmath.github.io/trouver/helper.topological_sort.html#containing_string_priority). - reverse - bool - Defaults to False\nReturns - OrderedDict[str]*\n\n# TODO: test",
    "crumbs": [
      "Topological sort"
    ]
  },
  {
    "objectID": "helper.latex.macros_and_commands.html",
    "href": "helper.latex.macros_and_commands.html",
    "title": "helper.latex.macros_and_commands",
    "section": "",
    "text": "from fastcore.test import *",
    "crumbs": [
      "helper.latex.macros_and_commands"
    ]
  },
  {
    "objectID": "helper.latex.macros_and_commands.html#identify-macros-and-commands-to-replace",
    "href": "helper.latex.macros_and_commands.html#identify-macros-and-commands-to-replace",
    "title": "helper.latex.macros_and_commands",
    "section": "Identify macros and commands (to replace)",
    "text": "Identify macros and commands (to replace)\nThe following functions were originally written for latex.formatting, but were moved here.\n\nsource\n\ncustom_commands\n\n custom_commands (preamble:str)\n\n*Return a dict mapping commands (and math operators) defined in preamble to the number of arguments display text of the commands.\nAssumes that the newcommands only have at most one default parameter (newcommands with multiple default parameters are not valid in LaTeX).\nIgnores all comented newcommands.*\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\npreamble\nstr\nThe preamble of a LaTeX document.\n\n\nReturns\nlist\nEach tuple consists of 1. the name of the custom command 2. the number of parameters 3. The default argument if specified or None otherwise, and 4. the display text of the command.\n\n\n\n\n# Basic\ntext_1 = r'\\newcommand{\\con}{\\mathcal{C}}'\ntest_eq(custom_commands(text_1), [('con', 0, None, r'\\mathcal{C}')])\n\n# With a parameter\ntext_2 = r'\\newcommand{\\field}[1]{\\mathbb{#1}}'\ntest_eq(custom_commands(text_2), [('field', 1, None, r'\\mathbb{#1}')]) \n\n# With multiple parameters, the first of which has a default value of `2`\ntext_3 = r'\\newcommand{\\plusbinomial}[3][2]{(#2 + #3)^#1}'\ntest_eq(custom_commands(text_3), [('plusbinomial', 3, '2', r'(#2 + #3)^#1')])\n\n# The display text has backslashes `\\` and curly brances `{}``\ntext_4 = r'\\newcommand{\\beq}{\\begin{displaymath}}'\ntest_eq(custom_commands(text_4), [('beq', 0, None, '\\\\begin{displaymath}')])\n\n\n# Basic with spaces in the newcommand declaration\ntext_6 = r'\\newcommand {\\con}  {\\mathcal{C}}'\ntest_eq(custom_commands(text_6), [('con', 0, None, r'\\mathcal{C}')])\n\n# With a parameter and spaces in the newcommand declaration\ntext_7 = r'\\newcommand   {\\field}   [1] {\\mathbb{#1}}'\ntest_eq(custom_commands(text_7), [('field', 1, None, r'\\mathbb{#1}')])\n\n# With multiple parameters, a default value, and spaces in the newcommand declaration\ntext_8 = r'\\newcommand {\\plusbinomial} [3] [2] {(#2 + #3)^#1}'\ntest_eq(custom_commands(text_8), [('plusbinomial', 3, '2', r'(#2 + #3)^#1')]) \n\n# With a comment `%'; commented out command declarations should not be detected.\ntext_9 = r'% \\newcommand{\\con}{\\mathcal{C}}'\ntest_eq(custom_commands(text_9), [])\n\n\n# Spanning multiple lines\ntext_10 = r'''\\newcommand{\\mat}[4]{\\left[\\begin{array}{cc}#1 & #2 \\\\\n                                         #3 & #4\\end{array}\\right]}'''\ntest_eq(\n    custom_commands(text_10),\n    [('mat', 4, None,\n             '\\\\left[\\\\begin{array}{cc}#1 & #2 \\\\\\\\\\n                                         #3 & #4\\\\end{array}\\\\right]')])\n\n# Math operator\ntext_11 = r'\\DeclareMathOperator{\\Hom}{Hom}'\ntest_eq(custom_commands(text_11), [('Hom', 0, None, 'Hom')])\n\ntext_12 = r'\\DeclareMathOperator{\\tConf}{\\widetilde{Conf}}'\ntest_eq(custom_commands(text_12), [('tConf', 0, None, r'\\widetilde{Conf}')])\n\n# `\\def` commands\n# \\def is a bit complicated because arguments can either be provided with []\n# or can be provided with {}.\ntext_13 = r'\\def\\A{{\\cO_{K}}}'\ntest_eq(custom_commands(text_13), [('A', 0, None, r'{\\cO_{K}}')])\n\n# newcommand and renewcommand don't require {} for the\n# command name, cf. https://arxiv.org/abs/1703.05365\ntext_14 = r'\\newcommand\\A{{\\mathbb A}}'\ntest_eq(custom_commands(text_14), [('A', 0, None, r'{\\mathbb A}')])\n\n# A test for https://arxiv.org/abs/0902.4637\ntext_15 = r'\\newcommand{\\til}[1]{{\\widetilde{#1}}}'\ntest_eq(custom_commands(text_15), [('til', 1, None, '{\\\\widetilde{#1}}')])\n\n\nsource\n\n\nregex_pattern_detecting_command\n\n regex_pattern_detecting_command\n                                  (command_tuple:tuple[str,int,typing.Opti\n                                  onal[str],str])\n\n*Return a regex.pattern object (not a re.pattern object) detecting the command with the specified number of parameters, optional argument, and display text.\nAssumes that the curly braces used to write the invocations of the commands are balanced and properly nested. Assumes that there are no two commands of the same name.*\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ncommand_tuple\ntuple\nConsists of 1. the name of the custom command 2. the number of parameters 3. The default argument if specified or None otherwise, and 4. the display text of the command.\n\n\nReturns\nPattern\n\n\n\n\n\n# Basic\npattern = regex_pattern_detecting_command(('Sur', 0, None, r'\\mathrm{Sur}'))\ntext = r'The number of element of $\\Sur(\\operatorname{Cl} \\mathcal{O}_L, A)$ is ...'\nmatch = pattern.search(text)\nstart, end = match.span()\ntest_eq(text[start:end], r'\\Sur')\n\npattern = regex_pattern_detecting_command(('frac', 2, None, r'\\mathrm{Sur}'))\ntext = r'\\frac{\\frac{2}{5}}{7}'\nmatch = pattern.search(text)\nstart, end = match.span()\ntest_eq(text[start:end], text)\n\npattern = regex_pattern_detecting_command(('frac', 2, None, r'\\mathrm{Sur}'))\ntext = r'\\frac{error}{7'\nmatch = pattern.search(text)\ntest_is(match, None)\n# start, end = match.span()\n# test_eq(text[start:end], text)\n\npattern = regex_pattern_detecting_command(('frac', 2, None, r'\\mathrm{Sur}'))\ntext = r'\\frac{\\frac{2}{5}}{7'\nmatch = pattern.search(text)\nstart, end = match.span()\ntest_eq(text[start:end], r'\\frac{2}{5}')\n\n# One parameter\npattern = regex_pattern_detecting_command(('field', 1, None, r'\\mathbb{#1}'))\ntext = r'\\field{Q}'\n# print(pattern.pattern)\nmatch = pattern.search(text)\nstart, end = match.span()\ntest_eq(text[start:end], text)\n\n# Multiple parameters\npattern = regex_pattern_detecting_command(('mat', 4, None, r'\\left[\\begin{array}{cc}#1 & #2 \\\\ #3 & #4\\end{array}\\right]'))\ntext = r'\\mat{{123}}{asdfasdf{}{}}{{{}}}{{asdf}{asdf}{}}' # This is a balanced str.\nmatch = pattern.search(text)\nstart, end = match.span()\ntest_eq(text[start:end], text)\ntest_eq(match.group(1), r'{123}')\n\n# Multiple parameters, one of which is optional parameter\npattern = regex_pattern_detecting_command(('plusbinomial', 3, '2', r'(#2 + #3)^#1'))\n# When the optional parameter is used\ntext = r'\\plusbinomial{x}{y}'\nmatch = pattern.search(text)\nstart, end = match.span()\ntest_eq(text[start:end], text)\n\n# When the optional parameter is not used\ntext = r'\\plusbinomial[4]{x}{y}'\nmatch = pattern.search(text)\nstart, end = match.span()\ntest_eq(text[start:end], text)\n\n# One parameter that is optional.\npattern = regex_pattern_detecting_command(('greet', 1, 'world', r'Hello #1!'))\n# When the optional parameter is used\ntext = r'\\greet'\nmatch = pattern.search(text)\nstart, end = match.span()\ntest_eq(text[start:end], text)\n\n# When the optional parameter is not used\ntext = r'\\greet[govna]'\nmatch = pattern.search(text)\nstart, end = match.span()\ntest_eq(text[start:end], text)\n\n# In the following example, `\\del` is a command defined as `\\delta`.\n# Any invocation `\\delta` should detected as invocations of `\\del``\ncommand_tuple = (r'del', 0, None, r'\\delta')\npattern = regex_pattern_detecting_command(command_tuple)\ntext = r'\\del should be detected.'\nmatch = pattern.search(text)\nstart, end = match.span()\ntest_eq(text[start:end], r'\\del')\ntext = r'\\delta should not be detected.'\nmatch = pattern.search(text)\nassert match is None\n# test_eq(replace_command_in_text(text, command_tuple), r'\\delta should be replaced. \\delta should not.')\n\n# In the following example, the command takes one argument, but sometimes the command\n# is `\\del` \ncommand_tuple = ('til', 1, None, '{\\\\widetilde{#1}}')\npattern = regex_pattern_detecting_command(command_tuple)\ntext = r'\\til \\calh_g'\nmatch = pattern.search(text)\n# start, end = match.span()",
    "crumbs": [
      "helper.latex.macros_and_commands"
    ]
  },
  {
    "objectID": "markdown.obsidian.vault_and_links.html",
    "href": "markdown.obsidian.vault_and_links.html",
    "title": "markdown.obsidian.vault_and_links",
    "section": "",
    "text": "source\n\n\n\n all_custom_text_for_links_in_vault\n                                     (note:trouver.markdown.obsidian.vault\n                                     .VaultNote, vault:os.PathLike,\n                                     anchor:Union[str,int]=-1)\n\nReturn all custom text used in the Obsidian vault for the specified note and anchor.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nnote\nVaultNote\n\nThe note to find the custom text for.\n\n\nvault\nPathLike\n\nThe path to the Obsidian vault directory\n\n\nanchor\nUnion\n-1\nThe anchor in the note to find the custom text for. If 0, then returns only the custom texts for internal links without anchors. If -1, then returns the custom texts for all of the internal links of the specified note.\n\n\nReturns\ndict\n\nEach key is the custom text used and each value is a set of paths relative to vault to the notes where the custom text is used. The key 0 means that no custom text is used.\n\n\n\n\n# TODO: examples\n\n\nsource\n\n\n\n\n all_links_in_vault (vault:os.PathLike, backlinks:bool=False,\n                     multiplicities:bool=False)\n\n*Returns a dict keeping track of which notes contain links to which notes.\nTODO: currently, the regex capture regex code. Change them so that this does not happen.\nParameters - vault - PathLike - backlinks - bool - If True, then keeps track of the links in each note. If False, then keeps track of the backlinks in each note, i.e. which other notes link to each note. Defaults to False. - multiplicties - bool - If True, then keeps track of multiple links to the same note for each note. Otherwise, only keeps track of whether or not a note links to a(nother) note. Defaults to False.\nReturns - dict[str, list[str]] - Each key is a str, referring to the name of a note. Each corresponding value is a list. The list contains the names of all the notes which the key note references to if backlinks is True, and contains the names of all the notes which reference the key note if backlinks is False. The list can contain multiple occurrences of the same note if multiplicities is True.*\n\n# TODO: examples",
    "crumbs": [
      "markdown.obsidian.vault_and_links"
    ]
  },
  {
    "objectID": "markdown.obsidian.vault_and_links.html#queries-about-links-in-a-vault",
    "href": "markdown.obsidian.vault_and_links.html#queries-about-links-in-a-vault",
    "title": "markdown.obsidian.vault_and_links",
    "section": "",
    "text": "source\n\n\n\n all_custom_text_for_links_in_vault\n                                     (note:trouver.markdown.obsidian.vault\n                                     .VaultNote, vault:os.PathLike,\n                                     anchor:Union[str,int]=-1)\n\nReturn all custom text used in the Obsidian vault for the specified note and anchor.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nnote\nVaultNote\n\nThe note to find the custom text for.\n\n\nvault\nPathLike\n\nThe path to the Obsidian vault directory\n\n\nanchor\nUnion\n-1\nThe anchor in the note to find the custom text for. If 0, then returns only the custom texts for internal links without anchors. If -1, then returns the custom texts for all of the internal links of the specified note.\n\n\nReturns\ndict\n\nEach key is the custom text used and each value is a set of paths relative to vault to the notes where the custom text is used. The key 0 means that no custom text is used.\n\n\n\n\n# TODO: examples\n\n\nsource\n\n\n\n\n all_links_in_vault (vault:os.PathLike, backlinks:bool=False,\n                     multiplicities:bool=False)\n\n*Returns a dict keeping track of which notes contain links to which notes.\nTODO: currently, the regex capture regex code. Change them so that this does not happen.\nParameters - vault - PathLike - backlinks - bool - If True, then keeps track of the links in each note. If False, then keeps track of the backlinks in each note, i.e. which other notes link to each note. Defaults to False. - multiplicties - bool - If True, then keeps track of multiple links to the same note for each note. Otherwise, only keeps track of whether or not a note links to a(nother) note. Defaults to False.\nReturns - dict[str, list[str]] - Each key is a str, referring to the name of a note. Each corresponding value is a list. The list contains the names of all the notes which the key note references to if backlinks is True, and contains the names of all the notes which reference the key note if backlinks is False. The list can contain multiple occurrences of the same note if multiplicities is True.*\n\n# TODO: examples",
    "crumbs": [
      "markdown.obsidian.vault_and_links"
    ]
  },
  {
    "objectID": "helper.html",
    "href": "helper.html",
    "title": "helper",
    "section": "",
    "text": "import operator\n\n\nfrom fastcore.test import *\n\n\n\nsublist_generator\n\n sublist_generator (input_list:list)\n\n\n\n\nsubstring_generator\n\n substring_generator (input_string:str)",
    "crumbs": [
      "helper"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.index_notes.html",
    "href": "markdown.obsidian.personal.index_notes.html",
    "title": "markdown.obisidian.personal.index_notes",
    "section": "",
    "text": "In a Obsidian math vault, it is convenient to keep index notes, which list links to other index notes or standard information notes.\nThe methods in this module - create (standard information) notes in appropriate folders, - set up the notes, - add links of the notes to appropriate index notes - indicate in the index note and the standard information note where the content of the information note originates from in the original text.\nimport tempfile\nfrom unittest import mock\nimport shutil\n\n\nfrom fastcore.test import *\nfrom pathvalidate import validate_filename\n\nfrom trouver.helper.files_and_folders import path_name_no_ext\nfrom trouver.helper.tests import _test_directory",
    "crumbs": [
      "markdown.obisidian.personal.index_notes"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.index_notes.html#identifying-subsections-listed-in-index-notes-and-subsection-folders",
    "href": "markdown.obsidian.personal.index_notes.html#identifying-subsections-listed-in-index-notes-and-subsection-folders",
    "title": "markdown.obisidian.personal.index_notes",
    "section": "Identifying subsections listed in index notes and subsection folders",
    "text": "Identifying subsections listed in index notes and subsection folders\n\nsource\n\nsubsections_listed_in_index_note\n\n subsections_listed_in_index_note\n                                   (index_note:Union[trouver.markdown.obsi\n                                   dian.vault.VaultNote,str],\n                                   vault:os.PathLike)\n\n*Return subsections/subchapters as listed in the index note\nSee Also\n\nThe get_headings_tree function of the MarkdownFile class.*\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nindex_note\nUnion\nThe index note\n\n\nvault\nPathLike\n\n\n\nReturns\ndict\nThe keys are 1. line numbers and 2. 'title'. The values are dict and str (the blank str if root node), respectively.\n\n\n\n\ntext = r\"\"\"# 1. Some section title\n- [[some_note]], Page 1\n- [[some_note_2]], Page 2\n\n# 2. Some other section title\n- [[some_note_3]], Page 2\n- [[some_note_4]], Page 3\n\n# 3. Section 3\n- [[some_note_5|an alias]], Page 3\n\n# 4. Section 4\n# 5. Section 5\n\"\"\"\n\nwith mock.patch(\"trouver.markdown.markdown.file.open\", mock.mock_open(read_data=text)):\n    fake_vn = VaultNote(rel_path='fake_note.md', vault='')  # Think of this as a VaultNote object whose underlying file has `text` as its content.\n    subsections_in_text = subsections_listed_in_index_note(fake_vn, vault='')\n    expected_output = {\n        'title': '',\n        0: {'title': '# 1. Some section title'},\n        4: {'title': '# 2. Some other section title'},\n        8: {'title': '# 3. Section 3'},\n        11: {'title': '# 4. Section 4'},\n        12: {'title': '# 5. Section 5'}}\n    test_eq(subsections_in_text, expected_output)\n\n\nsource\n\n\nsubsection_folders\n\n subsection_folders\n                     (index_note:Union[trouver.markdown.obsidian.vault.Vau\n                     ltNote,str], vault:os.PathLike, output_type:str)\n\n*Return subdirectories corresponding to subsections/subchapters, i.e. the folders in the same directory as the index note.\nThe folders are arranged in the order specified by natsorted.*\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nindex_note\nUnion\nThe index note\n\n\nvault\nPathLike\n\n\n\noutput_type\nstr\n'absolute_path', 'relative_path', or 'name'\n\n\nReturns\nlist\nList of immediate subdirectories in the directory containing the index note.\n\n\n\n\nwith (tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir):\n    temp_vault = Path(temp_dir) / 'test_vault_2'\n    shutil.copytree(_test_directory() / 'test_vault_2', temp_vault)\n\n    two_chapter_reference_1_index_note = VaultNote(temp_vault, name='_index_2_chapter_reference_1')\n    ss_folders = subsection_folders(two_chapter_reference_1_index_note, temp_vault, output_type='name')\n    assert len(ss_folders) &gt; 0\n\n\nmock_vault = Path('mock_absolute_path')\nmock_path =  mock_vault / Path('mock_reference_folder') / Path('mock_chapter')\nfolders = [  #glob.glob would return the folders in this order, at least on Windows:\n    '1 section',\n    '10 section',\n    '11 section',\n    '2 section',\n    '3 section',\n    '4 section',\n    '5 section',\n    '6 section',\n    '7 section',\n    '8 section',\n    '9 section']\n\nmock_glob_return_value = [str(mock_path / folder) for folder in folders]\n\nwith mock.patch(\"__main__.glob.glob\", return_value=mock_glob_return_value):\n    mock_index_note = VaultNote(rel_path='_index_mock_chapter.md', vault= mock_vault)\n    \n    sample_output_absolute_path = subsection_folders(mock_index_note, mock_vault, output_type='absolute_path')\n    test_shuffled(sample_output_absolute_path, mock_glob_return_value)\n    test_eq(sample_output_absolute_path, natsorted(mock_glob_return_value))\n\n    sample_output_relative_path = subsection_folders(mock_index_note, mock_vault, output_type='relative_path')\n    expected_output_for_relative_paths = [os.path.relpath(folder, mock_vault) for folder in mock_glob_return_value]\n    test_shuffled(sample_output_relative_path, expected_output_for_relative_paths)\n    test_eq(sample_output_relative_path, natsorted(expected_output_for_relative_paths))\n\n    # test_eq(sample_output_absolute_path, )\n    sample_output_name = subsection_folders(mock_index_note, mock_vault, output_type='name')\n    test_shuffled(sample_output_name, folders)\n    test_eq(sample_output_name, natsorted(folders))",
    "crumbs": [
      "markdown.obisidian.personal.index_notes"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.index_notes.html#corresponding-headings-in-index-notes-and-subfolders",
    "href": "markdown.obsidian.personal.index_notes.html#corresponding-headings-in-index-notes-and-subfolders",
    "title": "markdown.obisidian.personal.index_notes",
    "section": "Corresponding headings in index notes and subfolders",
    "text": "Corresponding headings in index notes and subfolders\n\nsource\n\nget_alphanumeric\n\n get_alphanumeric (title:str, title_type:str)\n\n*Get the alphanumeric of a title of either a folder or a heading in an index noteh.\nAssumes that each folder is titled '{alphanumeric}_{folder_title}' and each heading is titled '{alphanumeric}. {heading_title}'*\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ntitle\nstr\nThe title of either a folder or a heading. Must start with an alphanumeric.\n\n\ntitle_type\nstr\nEither folder or heading.\n\n\nReturns\nstr\nAn alphabet or a numeric (arabic or roman)\n\n\n\n\ntest_eq(get_alphanumeric('1. Higher direct images', 'heading'), '1')\ntest_eq(get_alphanumeric('1_higher_direct_images', 'folder'), '1')\ntest_eq(get_alphanumeric('12_higher_direct_images_the_leray_spectral_sequence', 'folder'), '12')\ntest_eq(get_alphanumeric('VII_elliptic_curves_over_local_fields', 'folder'), 'VII')\ntest_eq(get_alphanumeric('A_properties_of_morphisms', 'folder'), 'A')\n\n\nsource\n\n\ncorrespond_headings_with_folder\n\n correspond_headings_with_folder\n                                  (index_note:trouver.markdown.obsidian.va\n                                  ult.VaultNote, vault:os.PathLike,\n                                  include_non_heading:bool=True)\n\n*Return tuples of corresponding headings in an index note with folder names.\nAssumes that each folder is titled '{alphanumeric}_{folder_title}' and each heading is titled '{alphanumeric}. {heading_title}'\nReturns - dict[str, str] - Each key is a str indexing the headings and folders. The keys are usually alphanumerics (arabic or roman), depending on the numbering system of chapters/sections of the reference/text. The values are tuples (folder_title, heading_title) without the alphanumeric. For the blank heading, the key/index, the folder title, and the heading title are all the empty str.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nindex_note\nVaultNote\n\n\n\n\nvault\nPathLike\n\n\n\n\ninclude_non_heading\nbool\nTrue\nIf True, and if there is text before any heading, then treat such text as being under a “blank” heading.\n\n\nReturns\ndict\n\n\n\n\n\n\nwith (tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir):\n    temp_vault = Path(temp_dir) / 'test_vault_2'\n    shutil.copytree(_test_directory() / 'test_vault_2', temp_vault)\n\n    two_chapter_reference_1_index_note = VaultNote(temp_vault, name='_index_2_chapter_reference_1')\n    test_eq(len(correspond_headings_with_folder(two_chapter_reference_1_index_note, temp_vault)), 1)\n\n\nmock_vault = Path('mock_absolute_path')\nmock_path =  mock_vault / Path('algebraic_geometry') / Path('some_reference') / Path('chapter_18_some_chapter')\nfolders = ['181_some_title',\n    '182_some_other_title',\n    '183_yet_another_title']\nmock_glob_return_value = [str(mock_path / folder) for folder in folders]\n\ntext = r\"\"\"# 18.1. Some title \n- [ ] [[some_reference 18.1|some_reference_some_alias]], 18.1, Page 300\n# 18.2. Some other title \n- [ ] [[some_reference 18.2]], 18.2, Page 305\n# 18.3. Yet another title \n- [ ] [[some_reference 18.3|]], 18.3, Page 308\n\"\"\"\nmock_index_file = MarkdownFile.from_string(text)\n\nwith (mock.patch(\"__main__.glob.glob\", return_value=mock_glob_return_value),\n      mock.patch(\"trouver.markdown.markdown.file.MarkdownFile.from_vault_note\", return_value=mock_index_file)):\n\n    mock_index_note = VaultNote(rel_path = '_index_mock.md', vault=mock_vault)\n    # subsections_listed_in_index_note(mock_index_note, vault=mock_vault)\n    sample_output = correspond_headings_with_folder(mock_index_note, mock_vault)\n    print(sample_output)\n    test_eq(len(sample_output), 3)\n    for key, value in sample_output.items():\n        assert value[0].startswith(key)\n        assert value[1].startswith(key.replace('.', ''))\n\n{'18.1': ('18.1. Some title', '181_some_title'), '18.2': ('18.2. Some other title', '182_some_other_title'), '18.3': ('18.3. Yet another title', '183_yet_another_title')}",
    "crumbs": [
      "markdown.obisidian.personal.index_notes"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.index_notes.html#move-information-notes-to-their-appropriate-folders.",
    "href": "markdown.obsidian.personal.index_notes.html#move-information-notes-to-their-appropriate-folders.",
    "title": "markdown.obisidian.personal.index_notes",
    "section": "Move information notes to their appropriate folders.",
    "text": "Move information notes to their appropriate folders.\nSometimes, I end up creating information notes in the wrong folders. It would be nice to detect which ones are in the wrong folders and to move them appropriately.\n\nsource\n\ninformation_notes_linked_in_index_note\n\n information_notes_linked_in_index_note\n                                         (index_note:trouver.markdown.obsi\n                                         dian.vault.VaultNote,\n                                         vault:os.PathLike,\n                                         hints:list[os.PathLike]=None)\n\n*Find information notes to be moved to the correct folder.\nCurrent implementation just looks at level 1 headings. This function is used in move_information_notes_to_correct_folder. Assumes that all notes in the vault have unique names.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nindex_note\nVaultNote\n\nThe note indexing the information notes.\n\n\nvault\nPathLike\n\n\n\n\nhints\nlist\nNone\nHints on where the information notes are likely to be found at. Each path is relative to vault and points to a directory. Defaults to None.\n\n\nReturns\ndict\n\nEach key is the index for the heading (usually either an alphanumerical or a roman numerical). Each value is a list of the information notes linked in the index note.\n\n\n\n\nVaultNote.clear_cache()\n\nmock_vault = Path('mock_absolute_path')\nmock_path =  mock_vault / Path('algebraic_geometry') / Path('some_reference') / Path('chapter_18_some_chapter')\nfolders = ['181_some_title',\n    '182_some_other_title',\n    '183_yet_another_title']\nmock_glob_return_value = [str(mock_path / folder) for folder in folders]\n\nmock_correspond_headings_with_folder_return_value = {\n  '18.1': ('18.1. Some title', '181_some_title'),\n  '18.2': ('18.2. Some other title', '182_some_other_title'),\n  '18.3': ('18.3. Yet another title', '183_yet_another_title')}\n\ntext = r\"\"\"# 18.1. Some title \n- [ ] [[some_reference 18.1|some_reference_some_alias]], 18.1, Page 300\n- [ ] [[some_reference 18.1.1|another_alias]], 18.1.1, Page 300\n- [ ] [[some_reference 18.1.2]], 18.1.2, Page 301\n# 18.2. Some other title \n- [ ] [[some_reference 18.2]], 18.2, Page 305\n- [ ] [[some_reference 18.2.1]], 18.2.1, Page 306\n# 18.3. Yet another title \n- [ ] [[some_reference 18.3]], 18.3, Page 308\n- [ ] [[some_reference 18.3.1]], 18.3.1, Page 308\n\"\"\"\n\nmock_index_file = MarkdownFile.from_string(text)\n\nmock_index_note = VaultNote(rel_path = mock_path / '_index_18_some_index_note.md', vault=mock_vault)\n\nwith (mock.patch(\"trouver.markdown.markdown.file.MarkdownFile.from_vault_note\", return_value=mock_index_file),\n      mock.patch(\"__main__.correspond_headings_with_folder\", return_value=mock_correspond_headings_with_folder_return_value),\n      # mock.patch(\"__main__.VaultNote\", side_effect=[None, None, None, None, None, None, None])\n      ):\n    sample_output = information_notes_linked_in_index_note(mock_index_note, mock_vault)\n    print(sample_output)\n    \n    test_eq(len(sample_output), 3)\n    test_eq(len(sample_output['18.1']), 3)\n    test_eq(len(sample_output['18.2']), 2)\n    test_eq(sample_output['18.1'][0].name, 'some_reference 18.1')\n    test_eq(sample_output['18.2'][1].name, 'some_reference 18.2.1')\n\n{'18.1': [&lt;trouver.markdown.obsidian.vault.VaultNote object&gt;, &lt;trouver.markdown.obsidian.vault.VaultNote object&gt;, &lt;trouver.markdown.obsidian.vault.VaultNote object&gt;], '18.2': [&lt;trouver.markdown.obsidian.vault.VaultNote object&gt;, &lt;trouver.markdown.obsidian.vault.VaultNote object&gt;], '18.3': [&lt;trouver.markdown.obsidian.vault.VaultNote object&gt;, &lt;trouver.markdown.obsidian.vault.VaultNote object&gt;]}\n\n\n\nsource\n\n\nmove_information_notes_to_correct_folder\n\n move_information_notes_to_correct_folder\n                                           (index_note:trouver.markdown.ob\n                                           sidian.vault.VaultNote,\n                                           vault:os.PathLike,\n                                           hints:list[os.PathLike]=None)\n\n*Moves the information notes indexed by index_note to the correct folder.\nThe “correct folder” is a folder in the same directory as index_note corresponding to the heading under which the information note is indexed. The current implementation just looks at level 1 headings.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nindex_note\nVaultNote\n\n\n\n\nvault\nPathLike\n\n\n\n\nhints\nlist\nNone\nHints on where the information notes are likely to be found at. Each path is relative to vault and points to a directory. Defaults to None.\n\n\nReturns\nNone\n\n\n\n\n\nIn the following example, there is an index note listing links to three notes. One of the notes does not belong beneath a heading and the other two notes belong beneath a heading. Correspondingly, the move_information_notes_to_correct_folder function moves the file for the first note to the same directory that the index note itself is in and the two other notes end up in the section folder corresponding to the heading\n\nwith (tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir,\n      ):\n    temp_vault = Path(temp_dir) / 'test_vault_2'\n    shutil.copytree(_test_directory() / 'test_vault_2', temp_vault)\n\n    index_note = VaultNote(temp_vault, name='_index_1_chapter_reference_4')\n    print(f'The following is the text in the index note:\\n\\n{index_note.text()}')\n    move_information_notes_to_correct_folder(index_note, temp_vault)\n    assert str(VaultNote(temp_vault, name='this_note_stay_in_the_section_folder').path().parent).endswith('1_section')\n    assert str(VaultNote(temp_vault, name='this_note_should_be_moved_to_the_chapter_folder_from_the_section_folder').path().parent).endswith('1_chapter_reference_4')\n    assert str(VaultNote(temp_vault, name='this_note_should_be_moved_to_the_section_folder_from_the_chapter_folder').path().parent).endswith('1_section')\n\nThe following is the text in the index note:\n\n- [[this_note_should_be_moved_to_the_chapter_folder_from_the_section_folder]]\n# 1. First section in 1_chapter_reference_3\n- [[this_note_should_be_moved_to_the_section_folder_from_the_chapter_folder]]\n- [[this_note_stay_in_the_section_folder]]\n\n\n\n# TODO: see if I can implement the functionalities specified by the following example\n# In the following example, there is an unnamed heading not corresponding to any section and not corresponding to any folder within the directory that the index note belongs to. The notes linked beneath the unnamed heading should nevertheless be moved into the directory that the index note is in.\n\n# with (tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir,\n#       ):\n#     temp_vault = Path(temp_dir) / 'test_vault_2'\n#     shutil.copytree(_test_directory() / 'test_vault_2', temp_vault)\n\n#     index_note = VaultNote(temp_vault, name='_index_3_chapter_reference_4')\n#     print(f'The following is the text in the index note:\\n\\n{index_note.text()}')\n#     move_information_notes_to_correct_folder(index_note, temp_vault)\n#     note_that_should_have_moved = VaultNote(temp_vault, name='this_note_is_in_the_temp_folder_and_should_be_moved_3_chapter_reference_4_where_it_is_linked_by_the_index_note')\n#     assert str(note_that_should_have_moved.path().parent).endswith('3_chapter_reference_4')\n#     # assert str(VaultNote(temp_vault, name='this_note_should_be_moved_to_the_chapter_folder_from_the_section_folder').path().parent).endswith('1_chapter_reference_4')\n#     # assert str(VaultNote(temp_vault, name='this_note_should_be_moved_to_the_section_folder_from_the_chapter_folder').path().parent).endswith('1_section')\n\n\nsource\n\n\nmove_information_notes_to_correct_folder_for_all_indices\n\n move_information_notes_to_correct_folder_for_all_indices\n                                                           (index_of_index\n                                                           _notes:trouver.\n                                                           markdown.obsidi\n                                                           an.vault.VaultN\n                                                           ote, vault:os.P\n                                                           athLike, hints:\n                                                           list[os.PathLik\n                                                           e]=[])\n\nMoves the information notes for all index notes belonging to the reference as specified by index_of_index_notes.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nindex_of_index_notes\nVaultNote\n\nThe index note indexing other index notes; index_of_index_notes is intended to be an index note for an entire reference whereas the index notes are intended to correspond to chapters/sections in the reference.\n\n\nvault\nPathLike\n\n\n\n\nhints\nlist\n[]\nHints on where the information notes are likely to be found at. Each path is relative to vault and points to a directory.\n\n\nReturns\nNone\n\n\n\n\n\nThe following example demonstrating move_information_notes_to_correct_folder and move_information_notes_to_correct_folder_for_all_indices concerns test_vault_2 in nbs/_tests.\nNote that it contains the note _index_1_chapter_reference_1, which has the following content:\n\nvn = VaultNote(_test_directory(), name='_index_1_chapter_reference_1')\nprint(vn.text())\n\n# 1. Section\n- [[note_11]]\n- [[note_12]]\n- [[note_13]]\n\n# 2. Section\n- [[note_21]]\n- [[note_22]]\n\n# 3. Section\n- [[note_31]]\n- [[note_32]]\n- [[a_note_belonging_in_3_section_1_chapter_reference_1]]\n\n# 4. Section\n- [[note_41]]\n- [[note_42]]\n\n\nHowever, the following notes are in the “wrong” folders according to these index notes:\n\nnote_21.md is in the folder 1_section_1_chapter_reference_1, but it should be in the folder 2_section_1_chapter_reference_1.\nnote_41.md is in the folder 3_section_1_chapter_reference_1, but it should be in the folder 4_section_1_chapter_reference_1.\nnote_42.md is in the folder 3_section_1_chapter_reference_1, but it should be in the folder 4_section_1_chapter_reference_1.\na_note_belonging_in_1_section_1_chapter_reference_2.md is in the folder 4_section_1_chapter_reference_1, but it should be in the folder 1_section_1_chapter_reference_2.\na_note_belonging_in_1_section_2_chapter_reference_1.md is in the folder 4_section_1_chapter_reference_1, but it should be in the folder 1_section_2_chapter_reference_1.\na_note_belonging_in_3_section_1_chapter_reference_1.md is in the folder 1_section_2_chapter_reference_2, but it should be in the folder 3_section_1_chapter_reference_1.\n\nThe move_information_notes_to_correct_folder method first applied to the index note _index_1_chapter_reference_1.md moves the notes indexed in the index note to their correct locations. In particular, the following notes are moved to their correct locations:\n\nnote_21.md,\nnote_41.md,\nnote_42.md, and\na_note_belonging_in_3_section_1_chapter_reference_1.md\n\nThe move_information_notes_to_correct_folder method applied to _index_2_chapter_reference_1.md then moves a_note_belonging_in_1_section_2_chapter_reference_1.md to its correct location.\nLastly, the move_information_notes_to_correct_folder method applied to _index_1_chapter_reference_2.md then moves a_note_belonging_in_1_section_1_chapter_reference_2.md to its correct location.\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'test_vault_2'\n    shutil.copytree(_test_directory() / 'test_vault_2', temp_vault)\n    # os.startfile(temp_dir)\n    # input()\n\n    one_chapter_reference_1_index_note = VaultNote(temp_vault, name='_index_1_chapter_reference_1')\n    two_chapter_reference_1_index_note = VaultNote(temp_vault, name='_index_2_chapter_reference_1')\n    one_chapter_reference_2_index_note = VaultNote(temp_vault, name='_index_1_chapter_reference_2')\n\n    move_information_notes_to_correct_folder(one_chapter_reference_1_index_note, temp_vault)\n    note_21 = VaultNote(temp_vault, name='note_21')\n    test_eq(path_name_no_ext(note_21.path().parent), '2_section_1_chapter_reference_1')\n    note_41 = VaultNote(temp_vault, name='note_41')\n    test_eq(path_name_no_ext(note_41.path().parent), '4_section_1_chapter_reference_1')\n    note_42 = VaultNote(temp_vault, name='note_42')\n    test_eq(path_name_no_ext(note_42.path().parent), '4_section_1_chapter_reference_1')\n    note_alpha = VaultNote(temp_vault, name='a_note_belonging_in_3_section_1_chapter_reference_1')\n    test_eq(path_name_no_ext(note_alpha.path().parent), '3_section_1_chapter_reference_1')\n\n    # os.startfile(temp_vault)\n    move_information_notes_to_correct_folder(two_chapter_reference_1_index_note, temp_vault)\n    note_beta = VaultNote(temp_vault, name='a_note_belonging_in_1_section_2_chapter_reference_1')\n    test_eq(path_name_no_ext(note_beta.path().parent), '1_section_2_chapter_reference_1')\n\n    move_information_notes_to_correct_folder(one_chapter_reference_2_index_note, temp_vault)\n    note_gamma = VaultNote(temp_vault, name='a_note_belonging_in_1_section_1_chapter_reference_2')\n    test_eq(path_name_no_ext(note_gamma.path().parent), '1_section_1_chapter_reference_2')\n\nThe move_information_notes_to_correct_folder_for_all_indices applied to _index_reference_1.md effectively invokes move_information_notes_to_correct_folder to the index notes which are indexed in _index_reference_1.md, i.e. to _index_1_chapter_reference_1, _index_2_chapter_reference_1, _index_3_chapter_reference_1. Note that this invocation of the method does not invoke move_information_notes_to_correct_folder to _index_1_chapter_reference_2 and hence a_note_belonging_in_1_section_1_chapter_reference_2 is not moved to its correct location.\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'test_vault_2'\n    shutil.copytree(_test_directory() / 'test_vault_2', temp_vault)\n\n    reference_1_index_note = VaultNote(temp_vault, name='_index_reference_1')\n    move_information_notes_to_correct_folder_for_all_indices(reference_1_index_note, temp_vault)\n\n    # These notes are moved to their correct locations because they belong to reference_1, i.e. \n    # are indexed in indexed notes which are indexed in `_index_reference_1`.\n    note_21 = VaultNote(temp_vault, name='note_21')\n    test_eq(path_name_no_ext(note_21.path().parent), '2_section_1_chapter_reference_1')\n    note_41 = VaultNote(temp_vault, name='note_41')\n    test_eq(path_name_no_ext(note_41.path().parent), '4_section_1_chapter_reference_1')\n    note_42 = VaultNote(temp_vault, name='note_42')\n    test_eq(path_name_no_ext(note_42.path().parent), '4_section_1_chapter_reference_1')\n    note_alpha = VaultNote(temp_vault, name='a_note_belonging_in_3_section_1_chapter_reference_1')\n    test_eq(path_name_no_ext(note_alpha.path().parent), '3_section_1_chapter_reference_1')\n\n    note_beta = VaultNote(temp_vault, name='a_note_belonging_in_1_section_2_chapter_reference_1')\n    test_eq(path_name_no_ext(note_beta.path().parent), '1_section_2_chapter_reference_1')\n\n    # This note is not moved to its correct location because it does not belong to reference_2.\n    note_gamma = VaultNote(temp_vault, name='a_note_belonging_in_1_section_1_chapter_reference_2')\n    test_ne(path_name_no_ext(note_gamma.path().parent), '1_section_1_chapter_reference_2')\n    test_eq(path_name_no_ext(note_gamma.path().parent), '4_section_1_chapter_reference_1')",
    "crumbs": [
      "markdown.obisidian.personal.index_notes"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.index_notes.html#automatically-make-subfolders-based-on-index-note-headings",
    "href": "markdown.obsidian.personal.index_notes.html#automatically-make-subfolders-based-on-index-note-headings",
    "title": "markdown.obisidian.personal.index_notes",
    "section": "Automatically make subfolders based on index note headings",
    "text": "Automatically make subfolders based on index note headings\n\nsource\n\nconvert_title_to_folder_name\n\n convert_title_to_folder_name (title:str)\n\n*Returns a folder name for the given string, e.g. replaces spaces with underscore.\nParameters - title - str\nReturns - str*\n\n# TODO: add examples\nsample_title = convert_title_to_folder_name(r'1. $\\mathscr{M}_g$ and its boundary')\nprint(sample_title)\n\nsample_title = convert_title_to_folder_name(r'''7. Exceptional maximal subgroups of \n\\texorpdfstring{\\(\\GSp_4(\\ff_\\ell)\\)}{GSp4Fell}''')\nprint(sample_title)\nvalidate_filename(sample_title)\n\n1_m_g_and_its_boundary\n7_exceptional_maximal_subgroups_of_texorpdfstringgsp_4ff_ellgsp4fell\n\n\n\nsource\n\n\nconvert_heading_to_folder_name\n\n convert_heading_to_folder_name (heading:str)\n\n*Converts a heading to a valid name for a folder.\nTODO Might not work correctly.\nParameters - heading: str*\n\n\n\n\nType\nDetails\n\n\n\n\nheading\nstr\nMatches regex \\# (\\w+?)\\. (.*?)\n\n\nReturns\nstr\n\n\n\n\n\nprint(convert_heading_to_folder_name(r'# 1. First title'))\nprint(convert_heading_to_folder_name(r'# A. appendix title'))\n# print(convert_heading_to_folder_name(r'# A.1. appendix title')) # Works incorrectly TODO fix\nprint(convert_heading_to_folder_name(r\"# 1. Hi I'm Bob\"))\n\n1_first_title\nA_appendix_title\n1_hi_im_bob\n\n\n\nsource\n\n\nmake_folders_from_index_note_headers\n\n make_folders_from_index_note_headers\n                                       (index_note:trouver.markdown.obsidi\n                                       an.vault.VaultNote)\n\n*Make folders in the same directory as index note whose names are the titles of the headers of the index note.\nThe headers of the index note must match the regex pattern \\# (\\w+?)\\. (.*?).*\n\nwith (tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir,\n      mock.patch('__main__.convert_heading_to_folder_name') as mock_convert_heading_to_folder_name):\n    temp_vault = Path(temp_dir) / 'test_vault_2'\n    shutil.copytree(_test_directory() / 'test_vault_2', temp_vault)\n\n    # This mocks return values of `convert_heading_to_folder_name` which is used to\n    # determine the names of the folders to be made; I am using this because 1. I \n    # do not really care what the folders are named for the purposes of this example/test\n    # and 2. I anticipate that I will make several modifications to the method before\n    # I am satisfied with it.\n    mock_convert_heading_to_folder_name.side_effect = [\n        \"1_first_section_in_1_chapter_reference_3\",\n        \"2_second_section_in_1_chapter_reference_3\",\n        \"3_hi_im_bob\"]\n    \n    index_note = VaultNote(temp_vault, name='_index_1_chapter_reference_3')\n    make_folders_from_index_note_headers(index_note)\n    absolute_path = index_note.path(relative=False)\n    index_note_directory = absolute_path.parent\n    list_of_folders_in_the_same_directory_as_index_note = os.listdir(\n        index_note_directory)\n\n    # 3 folders plus the index note itself will be made in the \n    test_eq(len(list_of_folders_in_the_same_directory_as_index_note), 4)\n\n    mock_convert_heading_to_folder_name.assert_has_calls(\n        [mock.call('# 1. First section in 1_chapter_reference_3'),\n         mock.call('# 2. Second section in 1_chapter_reference_3'),\n         mock.call(\"# 3. Hi I'm Bob\")])",
    "crumbs": [
      "markdown.obisidian.personal.index_notes"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.index_notes.html#identify-order-of-notes-in-index-notes",
    "href": "markdown.obsidian.personal.index_notes.html#identify-order-of-notes-in-index-notes",
    "title": "markdown.obisidian.personal.index_notes",
    "section": "Identify order of notes in index notes",
    "text": "Identify order of notes in index notes\n\nsource\n\nget_notes_from_index_note\n\n get_notes_from_index_note (vault:os.PathLike,\n                            index_note:trouver.markdown.obsidian.vault.Vau\n                            ltNote, as_vault_notes:bool=True,\n                            include_embedded_notes:bool=False)\n\n*Returns the list of notes listed in the index note in the order that they are listed in.\nAsssumes that the index note is “formatted correctly”.\nSee Also - [get_index_notes_from_index_note](https://hyunjongkimmath.github.io/trouver/markdown.obsidian.personal.reference.html#get_index_notes_from_index_note) in markdown.obsidian.personal.reference.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nvault\nPathLike\n\nThe path to the Obsidian vault directory\n\n\nindex_note\nVaultNote\n\nThe VaultNote object for the index note.\n\n\nas_vault_notes\nbool\nTrue\nIf True, returns the [VaultNote](https://hyunjongkimmath.github.io/trouver/markdown.obsidian.vault.html#vaultnote) objects for the index notes. Otherwise, returns the names of these notes\n\n\ninclude_embedded_notes\nbool\nFalse\nIf True, include in the list the embedded notes. Defaults to False.\n\n\nReturns\nlist\n\nEither of the names of the index notes in the vault or of the index notes as VaultNote objects, depending on as_vault_notes.\n\n\n\nWe can get the notes indexed in an index note in the order that they are indexed:\n\nvault = _test_directory() / 'test_vault_2'\nindex_note = VaultNote(vault, name='_index_1_chapter_reference_1')\nlist_of_notes_in_index_note = get_notes_from_index_note(vault, index_note)\ntest_eq(len(list_of_notes_in_index_note), 10)\nnames_of_notes_in_index_note = [vn.name for vn in list_of_notes_in_index_note]\nprint(names_of_notes_in_index_note)\ntest_eq(names_of_notes_in_index_note[0], \"note_11\")\ntest_eq(names_of_notes_in_index_note[7], \"a_note_belonging_in_3_section_1_chapter_reference_1\")\n\n['note_11', 'note_12', 'note_13', 'note_21', 'note_22', 'note_31', 'note_32', 'a_note_belonging_in_3_section_1_chapter_reference_1', 'note_41', 'note_42']\n\n\nWe can just get the names of these notes instead of VaultNote objects representing these notes:\n\nlist_of_notes_in_index_note = get_notes_from_index_note(vault, index_note, as_vault_notes=False)\ntest_eq(len(list_of_notes_in_index_note), 10)\nprint(list_of_notes_in_index_note)\n\n['note_11', 'note_12', 'note_13', 'note_21', 'note_22', 'note_31', 'note_32', 'a_note_belonging_in_3_section_1_chapter_reference_1', 'note_41', 'note_42']",
    "crumbs": [
      "markdown.obisidian.personal.index_notes"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.index_notes.html#add-line-in-index-note",
    "href": "markdown.obsidian.personal.index_notes.html#add-line-in-index-note",
    "title": "markdown.obisidian.personal.index_notes",
    "section": "Add line in index note",
    "text": "Add line in index note\n\nsource\n\nadd_link_in_index_note_after_note_link\n\n add_link_in_index_note_after_note_link\n                                         (index_note:trouver.markdown.obsi\n                                         dian.vault.VaultNote, note_to_add\n                                         _link_after:trouver.markdown.obsi\n                                         dian.vault.VaultNote, link_to_add\n                                         :trouver.markdown.obsidian.links.\n                                         ObsidianLink)\n\n*Adds a link in the index note.\nThe link is added after the first link to note_to_add_link_after. If no link to note_to_add_link_after is found, then a link is added at the end.*\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'test_vault_2'\n    shutil.copytree(_test_directory() / 'test_vault_2', temp_vault)\n\n    index_note = VaultNote(temp_vault, name='_index_1_chapter_reference_1')\n    note_to_add_link_after = VaultNote(temp_vault, name='note_21')\n    link_to_add = ObsidianLink.from_text('[[another_note]]')\n    add_link_in_index_note_after_note_link(index_note, note_to_add_link_after, link_to_add)\n    new_text_of_the_index_note = index_note.text()\n    assert str(link_to_add) in new_text_of_the_index_note\n    print(new_text_of_the_index_note)\n\n# 1. Section\n- [[note_11]]\n- [[note_12]]\n- [[note_13]]\n\n# 2. Section\n- [[note_21]]\n- [[another_note]]\n- [[note_22]]\n\n# 3. Section\n- [[note_31]]\n- [[note_32]]\n- [[a_note_belonging_in_3_section_1_chapter_reference_1]]\n\n# 4. Section\n- [[note_41]]\n- [[note_42]]\n\n\nIf there are multiple instances of note_to_add_link_after, then the link is added after the first link to note_to_add_link_after.\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'test_vault_2'\n    shutil.copytree(_test_directory() / 'test_vault_2', temp_vault)\n\n    index_note = VaultNote(temp_vault, name='_index_2_chapter_reference_3')\n    note_1 = VaultNote(temp_vault, name='link_1')\n    link_to_add = ObsidianLink(False, 'new_link', 0, 0)\n    add_link_in_index_note_after_note_link(index_note, note_1, link_to_add)\n\n    new_text_of_the_index_note = index_note.text()\n    assert new_text_of_the_index_note.startswith('- [[link_1]]\\n- [[new_link]]')\n    assert str(link_to_add) in new_text_of_the_index_note\n    print(new_text_of_the_index_note)\n\n- [[link_1]]\n- [[new_link]]\n- [[link_2]]\n- [[link_3]]\n- [[link_1]]\n\n\nIf there are no links to note_to_add_link_after, then the link is added at the end.\n\n# TODO: do example.\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'test_vault_2'\n    shutil.copytree(_test_directory() / 'test_vault_2', temp_vault)\n\n    index_note = VaultNote(temp_vault, name='_index_2_chapter_reference_3')\n    note_1 = VaultNote(temp_vault, name='link_that_does_not_exist')\n    link_to_add = ObsidianLink(False, 'new_link', 0, 0)\n    add_link_in_index_note_after_note_link(index_note, note_1, link_to_add)\n\n    new_text_of_the_index_note = index_note.text()\n    print(new_text_of_the_index_note)\n    assert new_text_of_the_index_note.endswith('- [[link_1]]\\n- [[new_link]]')\n    assert str(link_to_add) in new_text_of_the_index_note\n\n- [[link_1]]\n- [[link_2]]\n- [[link_3]]\n- [[link_1]]\n- [[new_link]]",
    "crumbs": [
      "markdown.obisidian.personal.index_notes"
    ]
  },
  {
    "objectID": "todo.html",
    "href": "todo.html",
    "title": "TODO list",
    "section": "",
    "text": "I make a TODO list here:\n\nIssues to report to nbdev/fastai\n\nFor parameter tables of a docstring, things like list[type] don’t show that brackets:\nFor parameter tables, it seems that the table does not get rendered if there are no parameters.\n\n\nlisty = [1,2,3,4,5]\ndel listy[2:3]\nlisty\n\n[1, 2, 4, 5]",
    "crumbs": [
      "TODO list"
    ]
  },
  {
    "objectID": "unused.html",
    "href": "unused.html",
    "title": "How to use",
    "section": "",
    "text": "Trouver can parse LaTeX documents and split them up into parts which are convenient to read in Obsidian.md and to take notes on. For example, the following code splits up this paper in creates a folder in an Obsidian.md vault[^4].\n\nimport os\nfrom pathlib import Path\nimport shutil\nimport tempfile\n\nfrom trouver.helper.tests import _test_directory\nfrom trouver.helper.files_and_folders import  text_from_file\nfrom trouver.latex.convert import (\n    divide_preamble, divide_latex_text, custom_commands,\n    setup_reference_from_latex_parts\n)\n\n\n# This context manager is implemented to make sure that a temporary\n# folder is created and copies contents from `test_vault_5` in `nbs/_tests`,\n# only the contents of the temporary folder are modified, and \nwith (tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir):\n    temp_vault = Path(temp_dir) / 'test_vault_5'\n    shutil.copytree(_test_directory() / 'test_vault_5', temp_vault)\n\n    sample_latex_file = _test_directory() / 'latex_examples' / 'kim_park_ga1dcmmc' / 'main.tex'\n    sample_latex_text = text_from_file(sample_latex_file)\n    preamble, _ = divide_preamble(sample_latex_text)\n    parts = divide_latex_text(sample_latex_text)\n    cust_comms = custom_commands(preamble)\n    vault = temp_vault\n    location = Path('') # The path relative to the vault of the directory in which to make the new folder containing the new notes.\n    reference_name = 'kim_park_ga1dcmmc'\n    author_names = ['Kim', 'Park']\n    \n    setup_reference_from_latex_parts(\n        parts, cust_comms, vault, location,\n        reference_name,\n        author_names)\n\n    # os.startfile(os.getcwd()) # This open the current working directory; find the temporary folder in here.\n    # input() # There should be an input prompt; make an input here when you are done viewing the\n\n\n\n\nThe created folder in Obsidian.md looks like this in Obsidian.md The text in magenta are links, each to a file in the Obsidian.md vault\n\n\nWhile Obsidian.md is not strictly necessary to use trouver or to read and write the files created by setup_reference_from_latex_parts (in fact, any traditional file reader/writer can be used for such purposes), reading and writing the files on Obsidian.md can be convenient. Moreover, even when you use Obsidian, your data is in a local folder. In particular, even if Obsidian.md happens to get shut down, get bought, or change privacy policy, you will (supposedly) not lose access to your data.",
    "crumbs": [
      "How to use"
    ]
  },
  {
    "objectID": "unused.html#parse-latex-documents-and-split-them-into-parts",
    "href": "unused.html#parse-latex-documents-and-split-them-into-parts",
    "title": "How to use",
    "section": "",
    "text": "Trouver can parse LaTeX documents and split them up into parts which are convenient to read in Obsidian.md and to take notes on. For example, the following code splits up this paper in creates a folder in an Obsidian.md vault[^4].\n\nimport os\nfrom pathlib import Path\nimport shutil\nimport tempfile\n\nfrom trouver.helper.tests import _test_directory\nfrom trouver.helper.files_and_folders import  text_from_file\nfrom trouver.latex.convert import (\n    divide_preamble, divide_latex_text, custom_commands,\n    setup_reference_from_latex_parts\n)\n\n\n# This context manager is implemented to make sure that a temporary\n# folder is created and copies contents from `test_vault_5` in `nbs/_tests`,\n# only the contents of the temporary folder are modified, and \nwith (tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir):\n    temp_vault = Path(temp_dir) / 'test_vault_5'\n    shutil.copytree(_test_directory() / 'test_vault_5', temp_vault)\n\n    sample_latex_file = _test_directory() / 'latex_examples' / 'kim_park_ga1dcmmc' / 'main.tex'\n    sample_latex_text = text_from_file(sample_latex_file)\n    preamble, _ = divide_preamble(sample_latex_text)\n    parts = divide_latex_text(sample_latex_text)\n    cust_comms = custom_commands(preamble)\n    vault = temp_vault\n    location = Path('') # The path relative to the vault of the directory in which to make the new folder containing the new notes.\n    reference_name = 'kim_park_ga1dcmmc'\n    author_names = ['Kim', 'Park']\n    \n    setup_reference_from_latex_parts(\n        parts, cust_comms, vault, location,\n        reference_name,\n        author_names)\n\n    # os.startfile(os.getcwd()) # This open the current working directory; find the temporary folder in here.\n    # input() # There should be an input prompt; make an input here when you are done viewing the\n\n\n\n\nThe created folder in Obsidian.md looks like this in Obsidian.md The text in magenta are links, each to a file in the Obsidian.md vault\n\n\nWhile Obsidian.md is not strictly necessary to use trouver or to read and write the files created by setup_reference_from_latex_parts (in fact, any traditional file reader/writer can be used for such purposes), reading and writing the files on Obsidian.md can be convenient. Moreover, even when you use Obsidian, your data is in a local folder. In particular, even if Obsidian.md happens to get shut down, get bought, or change privacy policy, you will (supposedly) not lose access to your data.",
    "crumbs": [
      "How to use"
    ]
  },
  {
    "objectID": "unused.html#ml-model-utilities",
    "href": "unused.html#ml-model-utilities",
    "title": "How to use",
    "section": "ML model utilities",
    "text": "ML model utilities\nWe have trained a few ML models to detect/predict and provide information about short (or at least not-too-long) mathematical text. These ML models are available on Hugging Face and as such, they can be downloaded to and used from one’s local machines. Please note that ML models can be large and the locations that the Hugging Face Transformers library downloads such models to can vary from machine to machine. Typically, the models are stored in the following directories:\n\nLinux/macOS: ~/.cache/huggingface/transformers\nWindows: C:\\Users\\&lt;YourUsername&gt;\\.cache\\huggingface\\transformers\n\nFor each of these models, we may or may not have also written some instructions on how to train similar models given appropriately formatted data1.\nNote that the data used to train these models contains mathematical text pertaining mostly to fields closely related to number theory and algebraic geometry.",
    "crumbs": [
      "How to use"
    ]
  },
  {
    "objectID": "unused.html#use-an-ml-model-to-categorize-and-label-the-note-types",
    "href": "unused.html#use-an-ml-model-to-categorize-and-label-the-note-types",
    "title": "How to use",
    "section": "Use an ML model to categorize and label the note types",
    "text": "Use an ML model to categorize and label the note types\nOne of these ML models predicts the type of a piece of mathematical writing. For example, this model may predict that\nLet $L/K$ be an field extension. An element $\\alpha \\in L$ is said to be algebraic over $K$ if there exists some polynomial $f(x) \\in K[x]$ such that $f(\\alpha) = 0$.\nintroduces a definition. For the purposes of trouver, an Obsidian.md note containing ought to be labeled with the #_meta/definition tag by adding the text _meta/definition to the tags field in the frontmatter YAML metadata of the note:\n\n\n\nIn this note, there is a _meta/definition in the tags field in the frontmatter YAML metadata of the note\n\n\nSee markdown.obsidian.personal.machine_learning.information_note_types for more details.\nThis ML model is trained using the fast.ai library with the ULMFiT approach; see how_to.train_ml_model.fastai for the steps taken to train this model. This ML model is also available on Hugging Face under the repository hyunjongkimmath/information_note_type\nThe following code downloads the model into the local Hugging Face cache (if necessary) and loads the model.\n\nimport pathlib\nfrom pathlib import WindowsPath\nimport platform\n\nfrom huggingface_hub import from_pretrained_fastai\n\n\nrepo_id = 'hyunjongkimmath/information_note_type'\n\n# There is a PosixPath problem when trying to load\n# the model on Windows; we get around this problem\n# within the `if` statement.\nif platform.system() == 'Windows':\n    temp = pathlib.PosixPath # See https://stackoverflow.com/questions/57286486/i-cant-load-my-model-because-i-cant-put-a-posixpath\n    pathlib.PosixPath = pathlib.WindowsPath\n    information_note_type_model = from_pretrained_fastai(repo_id)\n    pathlib.PosixPath = temp\nelse:\n    information_note_type_model = from_pretrained_fastai(repo_id)\n\n\nsample_prediction_1 = information_note_type_model.predict(r'Let $L/K$ be an field extension. An element $\\alpha \\in L$ is said to be algebraic over $K$ if there exists some polynomial $f(x) \\in K[x]$ such that $f(\\alpha) = 0$.')\nprint(sample_prediction_1) \nsample_prediction_2 = information_note_type_model.predict(r'Theorem. Let $q$ be a prime power. Up to isomorphism, there is exactly one field with $q$ elements.')\nprint(sample_prediction_2)\n\n\n\n\n\n\n\n\n(['#_meta/definition', '#_meta/notation'], tensor([False, False, False, False, False, False,  True, False, False, False,\n         True, False, False, False]), tensor([1.9631e-03, 3.4931e-04, 1.7551e-02, 4.8163e-02, 5.7628e-06, 3.0610e-06,\n        9.6544e-01, 2.3179e-03, 2.4539e-03, 1.6170e-02, 5.8807e-01, 4.5185e-03,\n        2.5055e-04, 4.6183e-03]))\n\n\n\n\n\n\n\n\n\n(['#_meta/concept', '#_meta/proof'], tensor([False, False, False,  True, False, False, False, False, False, False,\n        False,  True, False, False]), tensor([3.4701e-03, 6.6588e-05, 7.8861e-02, 9.7205e-01, 8.8357e-06, 6.1183e-06,\n        9.5552e-02, 4.0747e-03, 2.7043e-04, 2.7545e-02, 1.3064e-02, 5.6198e-01,\n        1.5603e-04, 5.5122e-03]))\n\n\nAt the time of this writing (01/18/2023), the model seems to incorrect predict - in sample_prediction_1 that the text introduces a notation. - in sample_prediction_2 that the text contains a proof.\n\n# from trouver.markdown.obsidian.personal.machine_learning.information_note_types import\n\nWhile one can make use of the model’s predict method as is, trouver also provides functions which predict the types of mathematical text written in notes formatted in a specific way and record on these notes the predictions made. This way, one can make the model predict once and use these predictions for later, which can save computational resources.\n\nfrom trouver.markdown.obsidian.vault import VaultNote\nfrom trouver.markdown.obsidian.personal.notes import notes_linked_in_notes_linked_in_note\nfrom trouver.markdown.obsidian.personal.machine_learning.information_note_types import automatically_add_note_type_tags\n\n\nwith (tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir):\n    temp_vault = Path(temp_dir) / 'test_vault_8'\n    shutil.copytree(_test_directory() / 'test_vault_8', temp_vault)\n    reference = 'number_theory_reference_1'\n\n    index_note = VaultNote(temp_vault, name=f'_index_{reference}')\n    # `notes` below is a list of `VaultNote` objects.\n    # Also, the `notes_linked_in_note` function can be a useful\n    # alternative to the `notes_linked_in_notes_linked_in_note` function.\n    notes = notes_linked_in_notes_linked_in_note(index_note, as_dict=False)\n    \n    print(\"This is what one of the notes looks like before predicting its note type:\\n\\n\")\n    print(notes[0].text())\n\n    print(\"\\n\\nTagging notes\\n\\n\")\n    # Note that `information_note_type_model` was loaded previously.\n    automatically_add_note_type_tags(information_note_type_model, temp_vault, notes)\n\n    print(\"This is what the same note looks like after predicting its note type:\\n\\n\")\n    print(notes[0].text())\n\n    # os.startfile(os.getcwd()) # This opens the current working directory; find the temporary folder in here and explore it if desired.\n    # input() # There should be an input prompt; make an input here when you are done viewing the\n\nThis is what one of the notes looks like before predicting its note type:\n\n\n---\ncssclass: clean-embeds\naliases: [number_theory_reference_1_ring]\ntags: [_meta/literature_note, _reference/number_theory_reference_1]\n---\n# Ring[^1]\n\nA **(commutative) ring** is a set $R$, equipped with two binary operators, denoted $+$ and $\\cdot$, such that the following hold:\n\n1. $R$ is an abelian group under $+$ with identity element $0$.\n2. $R$ is an commutative monoid under $\\cdot$ with identity element $1$.\n3. For all $a,b,c \\in R$, we have $a \\cdot (b+c) = a \\cdot b + a \\cdot c$.\n\n# See Also\n\n# Meta\n## References\n![[_reference_number_theory_reference_1]]\n\n## Citations and Footnotes\n[^1]: Kim, Definition 1.1, Page 1\n\n\nTagging notes\n\n\nThis is what the same note looks like after predicting its note type:\n\n\n---\ncssclass: clean-embeds\naliases: [number_theory_reference_1_ring]\ntags: [_reference/number_theory_reference_1, _meta/literature_note, _auto/_meta/definition]\n---\n# Ring[^1]\n\nA **(commutative) ring** is a set $R$, equipped with two binary operators, denoted $+$ and $\\cdot$, such that the following hold:\n\n1. $R$ is an abelian group under $+$ with identity element $0$.\n2. $R$ is an commutative monoid under $\\cdot$ with identity element $1$.\n3. For all $a,b,c \\in R$, we have $a \\cdot (b+c) = a \\cdot b + a \\cdot c$.\n\n# See Also\n\n# Meta\n## References\n![[_reference_number_theory_reference_1]]\n\n## Citations and Footnotes\n[^1]: Kim, Definition 1.1, Page 1",
    "crumbs": [
      "How to use"
    ]
  },
  {
    "objectID": "unused.html#use-an-ml-model-to-find-notations-introduced-in-text",
    "href": "unused.html#use-an-ml-model-to-find-notations-introduced-in-text",
    "title": "How to use",
    "section": "Use an ML model to find notations introduced in text",
    "text": "Use an ML model to find notations introduced in text\nAnother ML model predicts locations of notations introduced in text. This model is trained as a categorizer - given a piece of mathematical text in LaTeX in which a single LaTeX math mode string (surrounded either by the dollar sign $ or double dollar signs $$) is surrounded by double asterisks **, the model should determine whether or not the LaTeX math mode string contains a newly introduced notation.\nFor example, suppose that we want to find notations introduced in the following text:\nLet $L/K$ be a Galois field extension. Its Galois group $\\operatorname{Gal}(L/K)$ is defined as the group of automorphisms of $L$ fixing $K$ pointwise.\nOur approach is to consider each latex math mode strings in this text (of which there are 4: \\(L/K\\), \\(\\operatorname{Gal}(L/K)\\), \\(L\\), and \\(K\\)), consider the four alternate versions of this text in which double asterisks ** are surround one of these math mode strings, and use the model to predict whether that math mode string contains a newly introduced notation. In particular, we pass through the model the following pieces of text:\n\n\n\nLet **$L/K$** be a Galois field extension. Its Galois group $\\operatorname{Gal}(L/K)$ is defined as the group of automorphisms of $L$ fixing $K$ pointwise.\n\n\n\nLet $L/K$ be a Galois field extension. Its Galois group **$\\operatorname{Gal}(L/K)$** is defined as the group of automorphisms of $L$ fixing $K$ pointwise.\n\n\n\nLet $L/K$ be a Galois field extension. Its Galois group $\\operatorname{Gal}(L/K)$ is defined as the group of automorphisms of **$L$** fixing $K$ pointwise.\n\n\n\nLet $L/K$ be a Galois field extension. Its Galois group $\\operatorname{Gal}(L/K)$ is defined as the group of automorphisms of $L$ fixing **$K$** pointwise.\nIdeally, the model should determine only the second version of text to contain a newly introduced notation\nSee markdown.obsidian.personal.machine_learning.notation_identifcation for more details.\nThis ML model is also trained using the fast.ai library with the ULMFiT approach, and is available on Hugging Face under the repository hyunjongkimmath/notation_identification.\n\nimport pathlib\nfrom pathlib import WindowsPath\nimport platform\n\nfrom huggingface_hub import from_pretrained_fastai\n\n\nrepo_id = 'hyunjongkimmath/notation_identification'\n\n# There is a PosixPath problem when trying to load\n# the model on Windows; we get around this problem\n# within the `if` statement.\nif platform.system() == 'Windows':\n    temp = pathlib.PosixPath # See https://stackoverflow.com/questions/57286486/i-cant-load-my-model-because-i-cant-put-a-posixpath\n    pathlib.PosixPath = pathlib.WindowsPath\n    notation_identification_model = from_pretrained_fastai(repo_id)\n    pathlib.PosixPath = temp\nelse:\n    notation_identification_model = from_pretrained_fastai(repo_id)\n\n\n\n\n\ncontains_a_notation = notation_identification_model.predict(r'Let $L/K$ be a Galois field extension. Its Galois group **$\\operatorname{Gal}(L/K)$** is defined as the group of automorphisms of $L$ fixing $K$ pointwise.')\ndoes_not_contain_a_notation = notation_identification_model.predict(r'Let **$L/K$** be a Galois field extension. Its Galois group $\\operatorname{Gal}(L/K)$ is defined as the group of automorphisms of $L$ fixing $K$ pointwise.')\nprint(contains_a_notation)\nprint(does_not_contain_a_notation)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n('True', tensor(1), tensor([9.0574e-08, 1.0000e+00]))\n('False', tensor(0), tensor([1.0000e+00, 4.8617e-06]))\n\n\n\n# TODO: examples of using functions in markdown.obsidian.personal.machine_learning.notation_identifcation.\n\nSimilarly as with the information_note_type model, trouver provides functions (namely automatically_mark_notations) which locate within notes mathematical notations that are newly introduced in the text of the notes and record on these notes locations of such notations (by surrounding double asterisks ** to LaTeX math mode strings). Note that this is done by applying the notation_identification model’s predict method as many times on a single piece of text as there are LaTeX math mode strings in the text. As such, these predictions often take a long time.\nTo save time, it is recommended to apply automatically_mark_notations only on notes which have the _meta/definition or _meta/notation tags (or _auto/_meta/definittion or _auto/_meta/notation) in their frontmatter YAML metadata2.\n\nWarning The automatically_mark_notations function not only adds double asterisks ** to LaTeX math mode strings, but also removes components such as links and footnotes from the text of the note. It is recommended to only apply this function to notes whose text has not been embellished with such components3. Moreover, the automatically_mark_notations is currently buggy and should not be applied to the same note twice\n\nThe test vault used in the below example contains a single note which has already been marked with the _meta/definition and _meta/notation notes. The following example in particular locates notations in that note at the very least.\n\nfrom trouver.markdown.markdown.file import MarkdownFile\nfrom trouver.markdown.obsidian.vault import VaultNote\nfrom trouver.markdown.obsidian.personal.notes import notes_linked_in_notes_linked_in_note\nfrom trouver.markdown.obsidian.personal.machine_learning.notation_identification import automatically_mark_notations\n\n\nwith (tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir):\n    temp_vault = Path(temp_dir) / 'test_vault_8'\n    shutil.copytree(_test_directory() / 'test_vault_8', temp_vault)\n    reference = 'number_theory_reference_1'\n\n    index_note = VaultNote(temp_vault, name=f'_index_{reference}')\n    # `notes` below is a list of `VaultNote` objects.\n    # Also, the `notes_linked_in_note` function can be a useful\n    # alternative to the `notes_linked_in_notes_linked_in_note` function.\n    notes = notes_linked_in_notes_linked_in_note(index_note, as_dict=False)\n    one_note_with_notation_tag = VaultNote(temp_vault, name='number_theory_reference_1_Definition 1.7')\n    \n    print(\"This is what one of the notes looks like before locating notations introduced:\\n\\n\")\n    print(one_note_with_notation_tag.text())\n\n    print(\"\\n\\nFinding notations\\n\\n\")\n    # Note that `information_note_type_model` was loaded previously.\n    automatically_add_note_type_tags(notation_identification_model, temp_vault, notes)\n\n    note_mfs = [MarkdownFile.from_vault_note(note) for note in notes]\n    # The below code ensures that the model searches for notations only in \n    # notes marked with a `_meta/definition` or a `_meta/notation`tag or\n    # their `_auto` versions. \n    notation_introducing_notes = [\n        note for note, mf in zip(notes, note_mfs)\n        if mf.has_tag('_auto/_meta/definition') or mf.has_tag('_auto/_meta/notation')\n        or mf.has_tag('_meta/definition') or mf.has_tag('_meta/notation')]\n    for note in notation_introducing_notes:\n        automatically_mark_notations(note, notation_identification_model, reference_name=reference)\n\n    print(\"This is what the same note looks like after locating notations introduced:\\n\\n\")\n    print(one_note_with_notation_tag.text())\n\n    # os.startfile(os.getcwd()) # This opens the current working directory; find the temporary folder in here and explore it if desired.\n    # input() # There should be an input prompt; make an input here when you are done viewing the\n\nThis is what one of the notes looks like before locating notations introduced:\n\n\n---\ncssclass: clean-embeds\naliases: [number_theory_reference_1_ring_of_integers_modulo_n]\ntags: [_meta/literature_note, _reference/number_theory_reference_1, _meta/definition, _meta/notation]\n---\n# Ring of integers modulo $n$[^1]\nThe ring of integers modulo $n$, denoted $\\mathbb{Z}/n\\mathbb{Z}$ has the elements $[m]$ for each integer $m$ where $[m_1] = [m_2]$ if and only if $m_1-m_2$ is divisible by $n$. As a ring, it has the following structure:\n\n1. $[m_1] + [m_2] = [m_1+m_2]$\n2. $[m_1] \\cdot [m_2] = [m_1 \\cdot m_2]$.\n\n\n# See Also\n\n# Meta\n## References\n![[_reference_number_theory_reference_1]]\n\n## Citations and Footnotes\n[^1]: Kim, Definition 1.7, Page 3\n\n\nFinding notations\n\n\nThis is what the same note looks like after locating notations introduced:\n\n\n---\ncssclass: clean-embeds\naliases: [number_theory_reference_1_ring_of_integers_modulo_n]\ntags: [_meta/literature_note, _auto/l, _auto/e, _auto/F, _meta/notation, _auto/a, _meta/definition, _reference/number_theory_reference_1, _auto/s]\n---\n# Topic[^1]\nThe ring of integers modulo $n$, denoted **$\\mathbb{Z}/n\\mathbb{Z}$** has the elements $[m]$ for each integer $m$ where $[m_1] = [m_2]$ if and only if $m_1-m_2$ is divisible by $n$. As a ring, it has the following structure:\n\n1. $[m_1] + [m_2] = [m_1+m_2]$\n2. $[m_1] \\cdot [m_2] = [m_1 \\cdot m_2]$.\n\n# See Also\n\n# Meta\n## References\n![[_reference_number_theory_reference_1]]\n\n## Citations and Footnotes\n[^1]: Kim, Definition 1.7, Page 3\n\n\n4",
    "crumbs": [
      "How to use"
    ]
  },
  {
    "objectID": "unused.html#use-an-ml-model-to-summarize-notations-introduced-in-text",
    "href": "unused.html#use-an-ml-model-to-summarize-notations-introduced-in-text",
    "title": "How to use",
    "section": "Use an ML model to summarize notations introduced in text",
    "text": "Use an ML model to summarize notations introduced in text\nNow that we have found notations introduced in text and created notation notes for them in our Obisidian.md vault, we now generate summaries for these notations.\nThe ML model in question fine-tuned from a T5 model\nThis ML model is available on Hugging Face under the repository hyunjongkimmath/notation_summarizations_model.\n\nfrom transformers import AutoModelForSeq2SeqLM, AutoTokenizer, pipeline\n\n\nmodel = AutoModelForSeq2SeqLM.from_pretrained('hyunjongkimmath/notation_summarizations_model')\ntokenizer = AutoTokenizer.from_pretrained('hyunjongkimmath/notation_summarizations_model')\nsummarizer = pipeline('summarization', model=model, tokenizer=tokenizer)\n\nThe summarizer pipeline can be used to summarize notations newly introduced in a piece of mathematical text. The text needs to be formatted as follows:\nsummarize: &lt;mathematical_text_goes_here&gt;\n\nlatex_in_original: $&lt;notation_to_summarize&gt;$\n\ntype(summarizer)\n\ntransformers.pipelines.text2text_generation.SummarizationPipeline\n\n\n\nsummarizer(\"summarize:Let us now define the upper half plane $\\mathbb{H}$ as the set of all complex numbers of real part greater than $1$.\\n\\n\\nlatex_in_original: $\\mathbb{H}$\")\n\nYour max_length is set to 200, but you input_length is only 54. You might consider decreasing max_length manually, e.g. summarizer('...', max_length=27)\n\n\n[{'summary_text': 'the upper half plane of the real part greater than $1$. It is defined as the set of all complex numbers of real parts greater than $$.'}]\n\n\nIn the above example, the summarizer determines that the notation $\\mathbb{H}$ introduced in the text\nLet us now define the upper half plane $\\mathbb{H}$ as the set of all complex numbers of real part greater than $1$.\ndenotes 'the upper half plane of the complex plane $\\\\ mathbb{ H} $. It is defined as the set of all complex numbers of real part greater than $1$.'.\nOnce we mark notations introduced in information notes by surrounding LaTeX math mode strings with double asterisks ** (manually and/or by using the notation_identification model, see the section about the notation_identification model above), we can use the make_notation_notes_from_double_asts function to make notation notes dedicated to those introduced notations and to link these newly created notation notes to the information notes.\nAfter making these notation notes, we can use the append_summary_to_notation_note function to predict what each notation is supposed to denote and add these predicted summaries to the notation notes themselves.\nFor the example below, there is at least one information note with notations already marked with double asterisks **.\n\nfrom trouver.markdown.obsidian.personal.notation import make_notation_notes_from_double_asts\nfrom trouver.markdown.obsidian.personal.notation.in_standard_information_note import notation_notes_linked_in_see_also_section\nfrom trouver.markdown.obsidian.personal.machine_learning.notation_summarization import append_summary_to_notation_note\n\n\nwith (tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir):\n    temp_vault = Path(temp_dir) / 'test_vault_8'\n    shutil.copytree(_test_directory() / 'test_vault_8', temp_vault)\n    reference = 'number_theory_reference_1'\n\n    index_note = VaultNote(temp_vault, name=f'_index_{reference}')\n    # Also, the `notes_linked_in_note` function can be a useful\n    # alternative to the `notes_linked_in_notes_linked_in_note` function.\n    notes = notes_linked_in_notes_linked_in_note(index_note, as_dict=False)\n    one_note_with_notations_marked = VaultNote(temp_vault, name='number_theory_reference_1_Definition 2.3')\n\n    print(\"This is what the information note looks like before we add the links to the notation notes:\\n\\n\")\n    print(one_note_with_notations_marked.text())\n\n    for note in notes:\n        new_notation_notes = make_notation_notes_from_double_asts(note, temp_vault, reference_name=reference)\n\n    print(\"\\n\\nThis is what the information note looks like after we add the links to the notation notes:\\n\\n\")\n    print(one_note_with_notations_marked.text())\n\n\n    for note in notes:\n        notation_notes_linked_in_note = notation_notes_linked_in_see_also_section(note, temp_vault)\n        for notation_note in notation_notes_linked_in_note:\n            append_summary_to_notation_note(notation_note, temp_vault, summarizer)\n\n    print(\"\\n\\nThis is what the newly created notation notes look like after we add the predicted summaries:\\n\\n\")\n    notation_notes_linked_in_the_one_note = notation_notes_linked_in_see_also_section(\n        one_note_with_notations_marked, temp_vault)\n    for notation_note in notation_notes_linked_in_note:\n        print(notation_note.text(), '\\n')\n\nYour max_length is set to 200, but you input_length is only 166. You might consider decreasing max_length manually, e.g. summarizer('...', max_length=83)\n\n\nThis is what the information note looks like before we add the links to the notation notes:\n\n\n---\ncssclass: clean-embeds\naliases: []\ntags: [_meta/literature_note, _reference/number_theory_reference_1, _meta/definition, _meta/notation]\n---\n# Quotient ring of a ring by an ideal[^1]\n\nLet $R$ be a ring and let $I$ be an ideal. The quotient ring **$R/I$** is the ring whose elements are the equivalence classes of elements of $R$ with respect to the equivalence relation **$\\sim$** given by $x \\sim y$ if $x-y \\in I$ and whose ring structure is given by\n\n$$\\begin{align*}\n[x]+[y] &= [x+y] \\\\\n[x] \\cdot [y] &= [x \\cdot y].\n\\end{align*}$$\n\n\n# See Also\n\n# Meta\n## References\n![[_reference_number_theory_reference_1]]\n\n## Citations and Footnotes\n[^1]: Kim, \n\n\nThis is what the information note looks like after we add the links to the notation notes:\n\n\n---\ncssclass: clean-embeds\naliases: []\ntags: [_meta/literature_note, _reference/number_theory_reference_1, _meta/definition, _meta/notation]\n---\n# Quotient ring of a ring by an ideal[^1]\n\nLet $R$ be a ring and let $I$ be an ideal. The quotient ring **$R/I$** is the ring whose elements are the equivalence classes of elements of $R$ with respect to the equivalence relation **$\\sim$** given by $x \\sim y$ if $x-y \\in I$ and whose ring structure is given by\n\n$$\\begin{align*}\n[x]+[y] &= [x+y] \\\\\n[x] \\cdot [y] &= [x \\cdot y].\n\\end{align*}$$\n\n\n# See Also\n- [[number_theory_reference_1_notation_R_I]]\n- [[number_theory_reference_1_notation_sim]]\n\n# Meta\n## References\n![[_reference_number_theory_reference_1]]\n\n## Citations and Footnotes\n[^1]: Kim, \n\n\nYour max_length is set to 200, but you input_length is only 166. You might consider decreasing max_length manually, e.g. summarizer('...', max_length=83)\n\n\n\n\nThis is what the newly created notation notes look like after we add the predicted summaries:\n\n\n---\ndetect_regex: []\nlatex_in_original: [R/I]\ntags: [_auto/notation_summary]\n---\n$R/I$ [[number_theory_reference_1_Definition 2.3|denotes]] the quotient ring of the ideal $R/I$. It is the ring whose elements are the equivalence classes of elements of $R$. \n\n---\ndetect_regex: []\nlatex_in_original: [\"\\\\sim\"]\ntags: [_auto/notation_summary]\n---\n$\\sim$ [[number_theory_reference_1_Definition 2.3|denotes]] the quotient ring of the ideal $R/I$. It is the ring whose elements are the equivalence classes of elements of a ring $R$. \n\n\n\nAt the time of this writing (1/30/2023), the author of trouver believes that this summarization model could be improved upon with more data; thus far, this model was trained on less than 1700 data points.",
    "crumbs": [
      "How to use"
    ]
  },
  {
    "objectID": "unused.html#footnotes",
    "href": "unused.html#footnotes",
    "title": "How to use",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nGiven time, the author of trouver eventually plans on writing instructions on training each of the models.↩︎\nAt the time of this writing (1/30/2023), the information_note_type model is fairly good at telling when a note introduces a definition or a notation, but will often conflate the two. In other words, the model may predict that a note ought to have the _meta/definition tag assigned to it when the _meta/notation tag should be assigned to it and vice versa, but the model will fairly usually assign at least one of the tags when the note introduces a definition or a notation and will assign neither of the tags when the note does not introduce a definition or a notation.↩︎\nMore precisely, automatically_mark_notations first applies process_standard_information_note to a MarkdownFile object constructed from the VaultNote object to roughly obtain the raw text of the note, uses that raw text to locate notations, marks the notations in the raw text, and then replaces the text from the note with the raw text with notations marked. In the process of obtaining the raw text, the process_standard_information_note function removes components such as links and footnotes from the text.↩︎\nThere seems to be a bug in the above example where inexplicable tags (e.g. _auto/s, _auto/a) are added to the note along with the double asterisks **. This issue is reported as Issue #33.↩︎",
    "crumbs": [
      "How to use"
    ]
  },
  {
    "objectID": "helper.html.html",
    "href": "helper.html.html",
    "title": "helper.html",
    "section": "",
    "text": "from fastcore.test import *\n\n\nConsolidating special characters that are changed with the __str__ function of bs4.element.Tags objects\n\nsource\n\n\nhtml_tag_str\n\n html_tag_str (html_tag:bs4.element.Tag)\n\nReturn the full string of html_tag, accounting for special characters that bs4 changes\nWhen using the __str__ function of bs4.element.Tag objects, special characters such as &lt;, &gt; and & change into &lt;, &gt; and &amp;, etc. The html_tag_str function makes it so that these characters are changed back.\n\nsoup = BeautifulSoup('', 'html.parser')\ntag = soup.new_tag('span')\ntag.string = '&hi&lt;'\ntest_eq(html_tag_str(tag), '&lt;span&gt;&hi&lt;&lt;/span&gt;')\n\n\nHandling less than &lt; symbols in latex math mode strings\nBeautifulSoup’s html.parser parses less than &lt; symbols without a following space as the beginning of an HTML tag, even when the symbol &lt; is used within a LaTeX math mode string. To get around this, we detect when this happens and add a space after these symbols.\n\nsource\n\n\n\nfind_lt_symbols_without_space_in_math_mode\n\n find_lt_symbols_without_space_in_math_mode (text:str)\n\nReturn the indices in text with math mode less than &lt; symbols without a space that follows.\n\n\n\n\nType\nDetails\n\n\n\n\ntext\nstr\n\n\n\nReturns\nlist\nThe index of\n\n\n\nIn the following example, there are a few math mode strings with less than &lt; symbols. Some of these symbols are followed by spaces and others are not.\n\ntext = r\"\"\"\nhere is a math mode $a&lt;b$. Here is another $a&lt; b$.\nHere is an in-line one:\n\n$$ asdf &lt;cbba$$\n\nHere is another:\n\n$$\nasdf &lt; basdf\n$$\n\"\"\"\noutput = find_lt_symbols_without_space_in_math_mode(text)\nprint(output)\ntest_eq(len(output), 2)\ntest_eq(text[output[0] + 1], 'b')\ntest_eq(text[output[1] + 1], 'c')\n\n[23, 85]\n\n\n\ntext_2 = r\"\"\"\n&lt;b&gt;Now there is an HTML tag&lt;/b&gt;. But it shouldn't be detected\nbecause the tag is not within math mode text.\nBut this inequality is: $a &lt;d$\n\"\"\"\noutput = find_lt_symbols_without_space_in_math_mode(text_2)\nprint(output)\ntest_eq(len(output), 1)\ntest_eq(text_2[output[0] + 1], 'd')\n\n[136]\n\n\n\nsource\n\n\nadd_space_to_lt_symbols_without_space\n\n add_space_to_lt_symbols_without_space (text:str)\n\nAdd space after less than &lt; symbols if the symbol is not followed by a space.\nLet us again use text from the example for the find_lt_symbols_without_space_in_math_mode function:\n\nprint(add_space_to_lt_symbols_without_space(text))\nassert not find_lt_symbols_without_space_in_math_mode(add_space_to_lt_symbols_without_space(text))\n\n\nhere is a math mode $a&lt; b$. Here is another $a&lt; b$.\nHere is an in-line one:\n\n$$ asdf &lt; cbba$$\n\nHere is another:\n\n$$\nasdf &lt; basdf\n$$\n\n\n\n\nRemoving HTML tags in a text and obtaining the data of the tags.\n\nmarkup = '&lt;b&gt;Hello&lt;/b&gt;'\nsoup = BeautifulSoup(markup, 'html.parser')\ntag = soup.b\nnew_str = soup.new_string(' World')\ntag.append(new_str)\n\n\nnew_str\n\n' World'\n\n\n\nsource\n\n\n\nremove_html_tags_in_text\n\n remove_html_tags_in_text (text:str,\n                           replace_with_attributes:Union[str,list[str],Non\n                           eType]=None, definitely_replace:bool=False,\n                           seed:int=None)\n\n*Remove the HTML tags in text.\nHTML tags are assumed to be not nested.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ntext\nstr\n\nThe text in which to remove the HTML tags.\n\n\nreplace_with_attributes\nUnion\nNone\nAttribute(s) within the HTML tags which should be used to replace the text of the tags. If None, then the texts are not replaced with the attributes. If multiple attributes are specified, then only one attribute is used to replace the text for each HTML tag (independently at random of other replacements). Each attribute’s text has an equal chance of being selected for replacement. Repeats are ignored.\n\n\ndefinitely_replace\nbool\nFalse\nIf True and if a given HTML tag has an attribute specified in replace_with_attributes, then the text for that tag will definitely be replaced by the text of one of the attributes. Otherwise, the original text and each attribute’s text have an equal chance of being selected.\n\n\nseed\nint\nNone\nRandom seed\n\n\nReturns\ntuple\n\nThe text removed without HTML tags and a list whose elements consist of the removed HTML tags and the starting and ending indices of the text corresponding to the removed tags within removed.\n\n\n\nThe remove_html_tags_in_text function removes HTML tags, preserving the underlying text by default.\n\nhtml = 'Let $K$ be a field. An &lt;b definition=\"Abelian variety over a field\"&gt;Abelian variety over $K$&lt;/b&gt; is a variety that'\ntext_without_html_tags, removed_tags = remove_html_tags_in_text(html)\nprint(text_without_html_tags)\n\ntest_eq(text_without_html_tags, 'Let $K$ be a field. An Abelian variety over $K$ is a variety that')\n\nLet $K$ be a field. An Abelian variety over $K$ is a variety that\n\n\n\nremoved_tags[0][0].attrs\n\n{'definition': 'Abelian variety over a field'}\n\n\nIn the following example, there is a less than &lt; symbol, which is definitely not the opening of an HTML tag. The following verifies that the placeholder &lt; is not used to replace the less than symbol, which is what bs4.BeautifulSoup’s html.parser does.\n\ntext = 'Hello, this has a less than symbol: $a&lt; b$'\ntext, html_tags = remove_html_tags_in_text(text)\nassert not html_tags\nassert '&lt; ' in text\nassert 'lt' not in html_tags\n\nThe same applies to the greater than &gt; symbol, and & symbols\n\ntext = 'Hello, this has a greater than symbol: $a&gt;b$'\ntext, html_tags = remove_html_tags_in_text(text)\nassert not html_tags\nassert '&gt;' in text\nassert 'gt' not in html_tags\n\ntext = r'Hello $$ f &= 3 \\\\ g &= 5'\ntext, html_tags = remove_html_tags_in_text(text)\nassert not html_tags\nassert '&' in text\nassert '&amp;' not in html_tags\n\nc:\\Users\\hyunj\\Documents\\Development\\Python\\trouver_py310_venv\\lib\\site-packages\\bs4\\__init__.py:435: MarkupResemblesLocatorWarning: The input looks more like a filename than markup. You may want to open this file and pass the filehandle into Beautiful Soup.\n  warnings.warn(\n\n\nThe remove_html_tags_in_text function additionally returns a list with information about the tags that are removed. Each item in this list is a tuple (tag, start, end), where tag is the tag that has been removed, and start and end are the indices within the string output text_without_html_tags of the function at which the text replacing the tag can be found.\nIn the example above (continued below), there is excactly one tag that is removed.\n\nprint(removed_tags)\nremoved_tag, start, end = removed_tags[0]\nprint(text_without_html_tags[start:end])\n\ntest_eq(text_without_html_tags[start:end], 'Abelian variety over $K$')\n\n[(&lt;b definition=\"Abelian variety over a field\"&gt;Abelian variety over $K$&lt;/b&gt;, 23, 47)]\nAbelian variety over $K$\n\n\nThe remove_html_tags_in_text function can be used to replace the underlying text of HTML tags with specified attribute values.\nIn the below example, the text has a tag which contains a typo attribute. Passing 'typo' to the replace_with_attributes parameter and passing True to the definitely_replace parameter guarantees that the value of the typo attribute is used instead of the text of the tag.\n\nhtml = r'The following tag fixes a typo and simultaneously keeps around the data of that typo: &lt;span typo=\"$\\operatorname{Gul}(K)$\"&gt;$\\operatorname{Gal}(K)$&lt;/span&gt;'\ntext_without_html_tags, removed_tags = remove_html_tags_in_text(html, replace_with_attributes='typo', definitely_replace=True)\nprint(text_without_html_tags)\n\ntest_eq(text_without_html_tags, 'The following tag fixes a typo and simultaneously keeps around the data of that typo: $\\\\operatorname{Gul}(K)$')\n\nremoved_tag, start, end = removed_tags[0]\ntest_eq(text_without_html_tags[start:end], '$\\\\operatorname{Gul}(K)$')\n\nThe following tag fixes a typo and simultaneously keeps around the data of that typo: $\\operatorname{Gul}(K)$\n\n\nIf the definitely_replace parameter is False (which it is by default), then the original text might be preserved or it might be replaced.\n\nhtml = r'&lt;span typo=\"$\\operatorname{Gul}(K)$\"&gt;$\\operatorname{Gal}(K)$&lt;/span&gt;'\npossible_outputs = [\n    r'$\\operatorname{Gal}(K)$',\n    r'$\\operatorname{Gul}(K)$'\n]\noutput, _ = remove_html_tags_in_text(html, replace_with_attributes='typo', definitely_replace=False)\nassert output in possible_outputs\n\n\nAdding HTML tag data\nOn the other hand, we may also need to add HTML tag data to a text.\n\nsource\n\n\n\nadd_HTML_tag_data_to_raw_text\n\n add_HTML_tag_data_to_raw_text (text:str,\n                                tags_and_locations:list[tuple[bs4.element.\n                                Tag,int,int]])\n\n*Add specified HTML tags to the specified locations/ranges in text.\nSee the add_HTML_tag_data_to_text function for adding HTML tag data to text that may or may not already have HTML tags.*\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ntext\nstr\nThe text onto which to add HTML tags. This is assumed to contain no HTML tags.\n\n\ntags_and_locations\nlist\nEach tuple consists of the tag object to add as well as the indices within text to. The ranges specified by the tuples are assumed to not overlap with one another.\n\n\nReturns\nstr\nThe modification of text in which the tags are added at the specified locations; the ranges in text are replaced..\n\n\n\n\ntext = \"Now this will have an HTML tag. This will also have an HTML tag too!\"\ntags_and_locations = [\n    (BeautifulSoup('&lt;span some_attr=\"hi\"&gt;this&lt;/span&gt;', 'html.parser'), 4,8),\n    (BeautifulSoup('&lt;div some_attr=\"hi\"&gt;This&lt;/div&gt;', 'html.parser'), 32,36)\n]\noutput = add_HTML_tag_data_to_raw_text(text, tags_and_locations)\nprint(output)\ntest_eq(output, 'Now &lt;span some_attr=\"hi\"&gt;this&lt;/span&gt; will have an HTML tag. &lt;div some_attr=\"hi\"&gt;This&lt;/div&gt; will also have an HTML tag too!')\n\nNow &lt;span some_attr=\"hi\"&gt;this&lt;/span&gt; will have an HTML tag. &lt;div some_attr=\"hi\"&gt;This&lt;/div&gt; will also have an HTML tag too!\n\n\nNow let us look at the same example, with the order in tags_and_locations reversed.\n\ntext = \"Now this will have an HTML tag. This will also have an HTML tag too!\"\ntags_and_locations = [\n    (BeautifulSoup('&lt;div some_attr=\"hi\"&gt;This&lt;/div&gt;', 'html.parser'), 32,36),\n    (BeautifulSoup('&lt;span some_attr=\"hi\"&gt;this&lt;/span&gt;', 'html.parser'), 4,8)\n]\noutput = add_HTML_tag_data_to_raw_text(text, tags_and_locations)\nprint(output)\ntest_eq(output, 'Now &lt;span some_attr=\"hi\"&gt;this&lt;/span&gt; will have an HTML tag. &lt;div some_attr=\"hi\"&gt;This&lt;/div&gt; will also have an HTML tag too!')\n\nNow &lt;span some_attr=\"hi\"&gt;this&lt;/span&gt; will have an HTML tag. &lt;div some_attr=\"hi\"&gt;This&lt;/div&gt; will also have an HTML tag too!",
    "crumbs": [
      "helper.html"
    ]
  },
  {
    "objectID": "helper.numbers.html",
    "href": "helper.numbers.html",
    "title": "helper.numbers",
    "section": "",
    "text": "source\n\n\n\n is_number (x:Union[float,int,complex,str])\n\n*Return True if the input x represents a number.\nThis function is different from Python’s built-in is_numeric function, which returns True when all characters of a string are digits.*\n\nassert is_number(\"3.45\")\nassert is_number(1 + 5j)\nassert is_number(5)\nassert is_number(0.0)\nassert not is_number(\"3.43.55\")\nassert not is_number(\"hie\")\nassert not is_number(\"[^1]\")\nassert not is_number(None)",
    "crumbs": [
      "helper.numbers"
    ]
  },
  {
    "objectID": "helper.numbers.html#numbers",
    "href": "helper.numbers.html#numbers",
    "title": "helper.numbers",
    "section": "",
    "text": "source\n\n\n\n is_number (x:Union[float,int,complex,str])\n\n*Return True if the input x represents a number.\nThis function is different from Python’s built-in is_numeric function, which returns True when all characters of a string are digits.*\n\nassert is_number(\"3.45\")\nassert is_number(1 + 5j)\nassert is_number(5)\nassert is_number(0.0)\nassert not is_number(\"3.43.55\")\nassert not is_number(\"hie\")\nassert not is_number(\"[^1]\")\nassert not is_number(None)",
    "crumbs": [
      "helper.numbers"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.machine_learning.information_note_types.html",
    "href": "markdown.obsidian.personal.machine_learning.information_note_types.html",
    "title": "markdown.obsidian.personal.machine_learning.information_note_types",
    "section": "",
    "text": "Some common types of components in mathematical writing include: definitions, notations, concepts (e.g. theorems, propositions, corollaries, lemmas), proofs. The functions in this module gather data from labeled “standard information notes” (formatted in trouver’s standard formatting) in an Obsidian.md vault about the types of these notes. Such data can be used to train a categorization ML model to predict types of unlabeled notes.\nThe labels are done by Markdown tags in the notes’ YAML frontmatter meta (so tags in the body of the Markdown file, are ignored). For example, the note\nhas the tag #_meta/definition 1\nLABEL_TAGS\n\n['#_meta/concept',\n '#_meta/exercise',\n '#_meta/definition',\n '#_meta/example',\n '#_meta/narrative',\n '#_meta/notation',\n '#_meta/proof',\n '#_meta/remark',\n '#_meta/TODO/split',\n '#_meta/TODO/merge',\n '#_meta/TODO/delete',\n '#_meta/hint',\n '#_meta/how_to',\n '#_meta/conjecture',\n '#_meta/convention',\n '#_meta/context',\n '#_meta/permanent_note',\n '#_meta/question',\n '#_meta/problem']\nLABEL_TAGS above lists the tags for the note types that we would like to eventually train a model to predict. The following are the tags for which the author of trouver has ample labeled data:\nnote that the author of trouver has only trained a model that predicts some of the note types listed in LABEL_TAGS. Moreover, the accuracy of the predictions can widely depend amongst the different types.\nIt is often appropriate to label a single note with more than one of these tags. For example, a note containing the statement “We define the ring \\(\\mathbb{Z}/n\\mathbb{Z}\\) of integers modulo \\(n\\)” is both a definition note and a notation note because it both introduces notion of the ring of integers modulo \\(n\\) and gives notation for the ring.\nfrom fastai.text.learner import TextLearner\nfrom fastai.learner import load_learner\nimport pathlib\nfrom pathlib import WindowsPath\nimport platform\nimport shutil\nimport tempfile\nfrom unittest import mock\n\nfrom fastcore.test import *\nfrom fastcore.test import all_equal\nfrom torch import tensor\n\nfrom trouver.helper.tests import _test_directory\nfrom trouver.markdown.obsidian.personal.notes import notes_linked_in_note",
    "crumbs": [
      "markdown.obsidian.personal.machine_learning.information_note_types"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.machine_learning.information_note_types.html#gather-and-label-data",
    "href": "markdown.obsidian.personal.machine_learning.information_note_types.html#gather-and-label-data",
    "title": "markdown.obsidian.personal.machine_learning.information_note_types",
    "section": "Gather and label data",
    "text": "Gather and label data\n\nsource\n\nnote_is_labeled_with_tag\n\n note_is_labeled_with_tag (note:trouver.markdown.obsidian.vault.VaultNote,\n                           label_tag:str, count_auto_tags:bool=False)\n\n*Return True if the standard information note is labeled as begin a specified type.\nRaises\n\nValueError\n\nIf label_tag does not include the beginning hashtag #.*\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nnote\nVaultNote\n\n\n\n\nlabel_tag\nstr\n\nA tag which labels a type that note is. Includes the beginning hashtag #, e.g. #_meta/definition, #_meta/TODO/split\n\n\ncount_auto_tags\nbool\nFalse\nIf True, count #_auto/_meta/&lt;tag&gt; notes as #_meta/&lt;tag&gt; for the purposes of the data collection.\n\n\nReturns\nbool\n\nTrue if note is labeled as type label_type.\n\n\n\n\nsample_text = r\"\"\"---\ncssclass: clean-embeds\naliases: []\ntags: [_meta/literature_note, _meta/definition]\n---\n# This is a title of a note[^1]\n\nWe could talk about many things. I like to talk about rings!\n\nA **ring** is a set equipped with two binary operators $+$ and $\\cdot$\nsuch that...\n\n# See Also\n\n# Meta\n## References\n![[_reference_sample_reference]]\n\n## Citations and Footnotes\n[^1]: Author names, Some way to identify where this information comes from\n\"\"\"\nsample_mf = MarkdownFile.from_string(sample_text)\n\nwith mock.patch(\"__main__.MarkdownFile.from_vault_note\", return_value=sample_mf) as mock_markdownfile_from_vault_note:\n    mock_note = None\n    # This is setup in such a way that the invocation to\n    # `note_is_labeled_with_tag` will use\n    # a note whose text is `sample_text`.\n    assert note_is_labeled_with_tag(mock_note, '#_meta/definition')\n    assert not note_is_labeled_with_tag(mock_note, '#_meta/notation')\n    assert not note_is_labeled_with_tag(mock_note, '#_meta/concept')\n\n    with ExceptionExpected(ValueError):\n        # The argument to `label_tag` requires the starting hashtag `#`.`\n        note_is_labeled_with_tag(mock_note, '_meta/definition')\n\nSetting count_auto_tags to True allows for _auto tags (those tags labeled by an ML model) to count.\n\nsample_text = r\"\"\"---\ncssclass: clean-embeds\naliases: []\ntags: [_meta/literature_note, _auto/_meta/definition]\n---\n# This is a title of a note[^1]\n\n# See Also\n\n# Meta\n## References\n![[_reference_sample_reference]]\n\n## Citations and Footnotes\n[^1]: Author names, Some way to identify where this information comes from\n\"\"\"\nsample_mf = MarkdownFile.from_string(sample_text)\n\nwith mock.patch(\"__main__.MarkdownFile.from_vault_note\", return_value=sample_mf) as mock_markdownfile_from_vault_note:\n    mock_note = None\n    # This is setup in such a way that the invocation to\n    # `note_is_labeled_with_tag` will use\n    # a note whose text is `sample_text`.\n    assert note_is_labeled_with_tag(mock_note, '#_meta/definition', count_auto_tags=True)\n    assert not note_is_labeled_with_tag(mock_note, '#_meta/notation')\n    assert not note_is_labeled_with_tag(mock_note, '#_meta/concept')\n\n    with ExceptionExpected(ValueError):\n        # The argument to `label_tag` requires the starting hashtag `#`.`\n        note_is_labeled_with_tag(mock_note, '_meta/definition')\n\n# Test count_auto_tags=False\n\nsample_text = r\"\"\"---\ncssclass: clean-embeds\naliases: []\ntags: [_meta/literature_note, _auto/_meta/definition]\n---\n# This is a title of a note[^1]\n\n# See Also\n\n# Meta\n## References\n![[_reference_sample_reference]]\n\n## Citations and Footnotes\n[^1]: Author names, Some way to identify where this information comes from\n\"\"\"\nsample_mf = MarkdownFile.from_string(sample_text)\n\nwith mock.patch(\"__main__.MarkdownFile.from_vault_note\", return_value=sample_mf) as mock_markdownfile_from_vault_note:\n    mock_note = None\n    # This is setup in such a way that the invocation to\n    # `note_is_labeled_with_tag` will use\n    # a note whose text is `sample_text`.\n    assert not note_is_labeled_with_tag(mock_note, '#_meta/definition', count_auto_tags=False)\n    assert not note_is_labeled_with_tag(mock_note, '#_meta/notation')\n    assert not note_is_labeled_with_tag(mock_note, '#_meta/concept')\n\n    with ExceptionExpected(ValueError):\n        # The argument to `label_tag` requires the starting hashtag `#`.`\n        note_is_labeled_with_tag(mock_note, '_meta/definition')\n\n\nsource\n\n\nnote_labels\n\n note_labels (note:trouver.markdown.obsidian.vault.VaultNote,\n              count_auto_tags:bool=False)\n\n*Return a dict indicating what labels a note has.\nThe labels come from the LABEL_TAGS dict.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nnote\nVaultNote\n\n\n\n\ncount_auto_tags\nbool\nFalse\nIf True, count #_auto/_meta/&lt;tag&gt; notes as #_meta/&lt;tag&gt; for the purposes of the data collection.\n\n\nReturns\ndict\n\n\n\n\n\n\nsample_text = r\"\"\"---\ncssclass: clean-embeds\naliases: []\ntags: [_meta/literature_note, _meta/definition]\n---\n# This is a title of a note[^1]\n\nWe could talk about many things. I like to talk about rings!\n\nA **ring** is a set equipped with two binary operators $+$ and $\\cdot$\nsuch that...\n\n# See Also\n\n# Meta\n## References\n![[_reference_sample_reference]]\n\n## Citations and Footnotes\n[^1]: Author names, Some way to identify where this information comes from\n\"\"\"\nsample_mf = MarkdownFile.from_string(sample_text)\n\nwith mock.patch(\"__main__.MarkdownFile.from_vault_note\", return_value=sample_mf) as mock_markdownfile_from_vault_note:\n    mock_note = None\n    # This is setup in such a way that the invocation to\n    # `note_labels` will use\n    # a note whose text is `sample_text`.\n    sample_output = note_labels(mock_note)\n    test_eq(sample_output['#_meta/definition'], 'IS #_meta/definition')\n    test_eq(sample_output['#_meta/concept'], 'NOT #_meta/concept')\n    for label_tag in LABEL_TAGS:\n        assert label_tag in sample_output\n    print(sample_output)\n\n{'#_meta/concept': 'NOT #_meta/concept', '#_meta/exercise': 'NOT #_meta/exercise', '#_meta/definition': 'IS #_meta/definition', '#_meta/example': 'NOT #_meta/example', '#_meta/narrative': 'NOT #_meta/narrative', '#_meta/notation': 'NOT #_meta/notation', '#_meta/proof': 'NOT #_meta/proof', '#_meta/remark': 'NOT #_meta/remark', '#_meta/TODO/split': 'NOT #_meta/TODO/split', '#_meta/TODO/merge': 'NOT #_meta/TODO/merge', '#_meta/TODO/delete': 'NOT #_meta/TODO/delete', '#_meta/hint': 'NOT #_meta/hint', '#_meta/how_to': 'NOT #_meta/how_to', '#_meta/conjecture': 'NOT #_meta/conjecture', '#_meta/convention': 'NOT #_meta/convention', '#_meta/context': 'NOT #_meta/context', '#_meta/permanent_note': 'NOT #_meta/permanent_note', '#_meta/question': 'NOT #_meta/question', '#_meta/problem': 'NOT #_meta/problem'}\n\n\n\nGather data into a dataset\nThe way that data for information note types should be obtained is fairly simple - for each note, obtain the YAML frontmatter metadata.\n\nsource\n\n\n\nlabels_and_identifying_info_from_notes\n\n labels_and_identifying_info_from_notes (vault:os.PathLike,\n                                         notes:list[trouver.markdown.obsid\n                                         ian.vault.VaultNote],\n                                         count_auto_tags:bool=False, raise\n                                         _error_that_arises:bool=True)\n\n*Return a list of dict’s, each corresponding to the data from an information note.\nThe keys in the dict’s are as follows\n\nTime added - The time when the row was added.\nTime modified - The time when the labels of the row\nNote name - The name of the note from which the data for the row was derived.\nFull note content - The entire content/text of the note.\nProcessed note content - The “raw” content of the note without the YAML frontmatter meta, Markdown headings, links, footnotes, etc.\nThe various labels for note types (e.g. #_meta/definition)\n\nAll timestamps are in UTC time and specify time to minutes (i.e. no seconds/microseconds).*\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nvault\nPathLike\n\nThe vault from which the notes come from; this is to invoke process_standard_information_note.\n\n\nnotes\nlist\n\nAssumed to only contain standard information notes from which note type labels are to be gathered.\n\n\ncount_auto_tags\nbool\nFalse\nIf True, count #_auto/_meta/&lt;tag&gt; notes as #_meta/&lt;tag&gt; for the purposes of the data collection.\n\n\nraise_error_that_arises\nbool\nTrue\nIf True, raise errors that arise as data is gathered from individual notes. Otherwise, print the would-be error message for individual notes, but do not include the data from the note.\n\n\nReturns\nlist\n\nEach dict has keys Time added, Time modified, Note name, Full note content, Processed note content as well as columns for each tag label.\n\n\n\n\nsource\n\n\ninformation_note_types_as_dataset\n\n information_note_types_as_dataset (vault:os.PathLike,\n                                    notes:list[trouver.markdown.obsidian.v\n                                    ault.VaultNote],\n                                    count_auto_tags:bool=False,\n                                    raise_error_that_arises:bool=True)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nvault\nPathLike\n\nThe vault from which the notes come from; this is to invoke process_standard_information_note.\n\n\nnotes\nlist\n\nAssumed to only contain standard information notes from which note type labels are to be gathered.\n\n\ncount_auto_tags\nbool\nFalse\nIf True, count #_auto/_meta/&lt;tag&gt; notes as #_meta/&lt;tag&gt; for the purposes of the data collection.\n\n\nraise_error_that_arises\nbool\nTrue\nIf True, raise errors that arise as data is gathered from individual notes. Otherwise, print the would-be error message for individual notes, but do not include the data from the note.\n\n\nReturns\nDataset\n\n\n\n\n\ninformation_note_types_as_dataset gathers data for information notes types as a Dataset from the huggingface dataset library.\n\ntest_vault = _test_directory() / 'test_vault_6'\nindex_note = VaultNote(test_vault, name='_index_1_introduction_reference_with_tag_labels')\n# There shoudl be 6 notes\nnotes = notes_linked_in_note(index_note, as_dict=False)\ndataset = information_note_types_as_dataset(test_vault, notes)\ndataset\n# test_eq(len(df), 6)\n# df.head()\n\nc:\\Users\\hyunj\\Documents\\Development\\Python\\trouver_py310_venv\\lib\\site-packages\\bs4\\__init__.py:435: MarkupResemblesLocatorWarning: The input looks more like a filename than markup. You may want to open this file and pass the filehandle into Beautiful Soup.\n  warnings.warn(\n\n\nDataset({\n    features: ['Time added', 'Time modified', 'Note name', 'Full note content', 'Processed note content', '#_meta/concept', '#_meta/exercise', '#_meta/definition', '#_meta/example', '#_meta/narrative', '#_meta/notation', '#_meta/proof', '#_meta/remark', '#_meta/TODO/split', '#_meta/TODO/merge', '#_meta/TODO/delete', '#_meta/hint', '#_meta/how_to', '#_meta/conjecture', '#_meta/convention', '#_meta/context', '#_meta/permanent_note', '#_meta/question', '#_meta/problem'],\n    num_rows: 6\n})\n\n\nLet us view the dataset as a pandas Dataframe\n\ndataset.to_pandas()\n\n\n\n\n\n\n\n\nTime added\nTime modified\nNote name\nFull note content\nProcessed note content\n#_meta/concept\n#_meta/exercise\n#_meta/definition\n#_meta/example\n#_meta/narrative\n...\n#_meta/TODO/merge\n#_meta/TODO/delete\n#_meta/hint\n#_meta/how_to\n#_meta/conjecture\n#_meta/convention\n#_meta/context\n#_meta/permanent_note\n#_meta/question\n#_meta/problem\n\n\n\n\n0\n2024-12-16T17:26\n2024-12-16T17:26\nreference_with_tag_labels_something_something\n---\\ncssclass: clean-embeds\\naliases: []\\ntags: [_meta/literature_note, _meta/narrative]\\n---\\n# Topic[^1]\\n\\nIn this chapter, we describe some basics of ring theory. Rings are mathematical structures which generalize the structures of the familiar integers, rational numbers, real numbers, complex numberes, etc.\\n\\n\\n\\n# See Also\\n\\n# Meta\\n## References\\n\\n## Citations and Footnotes\\n[^1]: Kim, Page 1\nIn this chapter, we describe some basics of ring theory. Rings are mathematical structures which generalize the structures of the familiar integers, rational numbers, real numbers, complex numberes, etc.\\n\nNOT #_meta/concept\nNOT #_meta/exercise\nNOT #_meta/definition\nNOT #_meta/example\nIS #_meta/narrative\n...\nNOT #_meta/TODO/merge\nNOT #_meta/TODO/delete\nNOT #_meta/hint\nNOT #_meta/how_to\nNOT #_meta/conjecture\nNOT #_meta/convention\nNOT #_meta/context\nNOT #_meta/permanent_note\nNOT #_meta/question\nNOT #_meta/problem\n\n\n1\n2024-12-16T17:26\n2024-12-16T17:26\nreference_with_tag_labels_Definition 1\n---\\ncssclass: clean-embeds\\naliases: []\\ntags: [_meta/literature_note, _meta/definition]\\n---\\n# Ring[^1]\\n\\nA **ring** is a set with binary operators $+$ and $\\cdot$ such that ...\\n\\n# See Also\\n\\n# Meta\\n## References\\n\\n## Citations and Footnotes\\n[^1]: Kim, Definition 1\nA ring is a set with binary operators $+$ and $\\cdot$ such that ...\\n\nNOT #_meta/concept\nNOT #_meta/exercise\nIS #_meta/definition\nNOT #_meta/example\nNOT #_meta/narrative\n...\nNOT #_meta/TODO/merge\nNOT #_meta/TODO/delete\nNOT #_meta/hint\nNOT #_meta/how_to\nNOT #_meta/conjecture\nNOT #_meta/convention\nNOT #_meta/context\nNOT #_meta/permanent_note\nNOT #_meta/question\nNOT #_meta/problem\n\n\n2\n2024-12-16T17:26\n2024-12-16T17:26\nreference_with_tag_labels_Definition 2\n---\\ncssclass: clean-embeds\\naliases: []\\ntags: [_meta/literature_note, _meta/definition, _meta/notation]\\n---\\n# Ring of integers modulo $n$[^1]\\n\\nLet $n \\geq 1$ be an integer. The **ring of integers modulo $n$**, denoted by **$\\mathbb{Z}/n\\mathbb{Z}$**, is, informally, the ring whose elements are represented by the integers with the understanding that $0$ and $n$ are equal.\\n\\nMore precisely, $\\mathbb{Z}/n\\mathbb{Z}$ has the elements $0,1,\\ldots,n-1$.\\n\\n...\\n\\n\\n# See Also\\n- [[reference_with_tag_labels_Exercise 1|reference_with_tag_labels_Z_nZ_is_a_ring]]\\n# Meta\\n## References\\n\\n## ...\nLet $n \\geq 1$ be an integer. The ring of integers modulo $n$, denoted by $\\mathbb{Z}/n\\mathbb{Z}$, is, informally, the ring whose elements are represented by the integers with the understanding that $0$ and $n$ are equal.\\n\\nMore precisely, $\\mathbb{Z}/n\\mathbb{Z}$ has the elements $0,1,\\ldots,n-1$.\\n\\n...\\n\nNOT #_meta/concept\nNOT #_meta/exercise\nIS #_meta/definition\nNOT #_meta/example\nNOT #_meta/narrative\n...\nNOT #_meta/TODO/merge\nNOT #_meta/TODO/delete\nNOT #_meta/hint\nNOT #_meta/how_to\nNOT #_meta/conjecture\nNOT #_meta/convention\nNOT #_meta/context\nNOT #_meta/permanent_note\nNOT #_meta/question\nNOT #_meta/problem\n\n\n3\n2024-12-16T17:26\n2024-12-16T17:26\nreference_with_tag_labels_Exercise 1\n---\\ncssclass: clean-embeds\\naliases: [reference_with_tag_labels_Z_nZ_is_a_ring]\\ntags: [_meta/literature_note, _meta/exercise]\\n---\\n# $\\mathbb{Z}/n\\mathbb{Z}$ is a ring[^1]\\n\\nShow that $\\mathbb{Z}/n\\mathbb{Z}$ is a ring.\\n\\n# See Also\\n\\n# Meta\\n## References\\n\\n## Citations and Footnotes\\n[^1]: Exercise 1\nShow that $\\mathbb{Z}/n\\mathbb{Z}$ is a ring.\\n\nNOT #_meta/concept\nIS #_meta/exercise\nNOT #_meta/definition\nNOT #_meta/example\nNOT #_meta/narrative\n...\nNOT #_meta/TODO/merge\nNOT #_meta/TODO/delete\nNOT #_meta/hint\nNOT #_meta/how_to\nNOT #_meta/conjecture\nNOT #_meta/convention\nNOT #_meta/context\nNOT #_meta/permanent_note\nNOT #_meta/question\nNOT #_meta/problem\n\n\n4\n2024-12-16T17:26\n2024-12-16T17:26\nreference_with_tag_labels_Theorem 1\n---\\ncssclass: clean-embeds\\naliases: []\\ntags: [_meta/literature_note, _meta/concept, _meta/proof]\\n---\\n# The polynomial ring of a UFD is a UFD[^1]\\n\\nTheorem 1. Let $R$ be a UFD. Then $R[x]$ is a UFD.\\n\\nProof. Let $f,g \\in R[x]$ and suppose that $fg = 0$. Write $f = \\sum_{i=0}^n a_i x^i$ and $g = \\sum_{j=0}^m b_j x^j$ for some $a_i,b_j \\in R$.\\n\\n...\\n\\n# See Also\\n\\n# Meta\\n## References\\n\\n## Citations and Footnotes\\n[^1]: Kim, Theorem 1\nTheorem 1. Let $R$ be a UFD. Then $R[x]$ is a UFD.\\n\\nProof. Let $f,g \\in R[x]$ and suppose that $fg = 0$. Write $f = \\sum_{i=0}^n a_i x^i$ and $g = \\sum_{j=0}^m b_j x^j$ for some $a_i,b_j \\in R$.\\n\\n...\\n\nIS #_meta/concept\nNOT #_meta/exercise\nNOT #_meta/definition\nNOT #_meta/example\nNOT #_meta/narrative\n...\nNOT #_meta/TODO/merge\nNOT #_meta/TODO/delete\nNOT #_meta/hint\nNOT #_meta/how_to\nNOT #_meta/conjecture\nNOT #_meta/convention\nNOT #_meta/context\nNOT #_meta/permanent_note\nNOT #_meta/question\nNOT #_meta/problem\n\n\n5\n2024-12-16T17:26\n2024-12-16T17:26\nreference_with_tag_labels_Theorem 2\n---\\ncssclass: clean-embeds\\naliases: []\\ntags: [_meta/literature_note, _meta/concept, _auto/_meta/proof, _meta/definition]\\n---\\n%%Note that this note introduces a notation and hence actually ought to be labeled with the tag _meta/notation as well; but for the sake of example, the job of adding the _meta/notation tag will be left to the `automatically_add_note_type_tags` function.%%\\n\\n# The polynomial ring of a UFD is a UFD[^1]\\nLet $q$ be the power of a prime number. Up to isomorphism, there is a unique field with $q$ elements. This field is denoted **$\\mathbb{F}_q$** and is called the ...\n%%Note that this note introduces a notation and hence actually ought to be labeled with the tag _meta/notation as well; but for the sake of example, the job of adding the _meta/notation tag will be left to the `automatically_add_note_type_tags` function.%%\\n\\nLet $q$ be the power of a prime number. Up to isomorphism, there is a unique field with $q$ elements. This field is denoted $\\mathbb{F}_q$ and is called the finite field of $q$ elements.\\n\\nProof. Say that $q = p^k$ and let $F$ be a field with $q$ elements. First note that $F$ has a subfield \"generated by $1$\", i.e. the elements $0,1,...\nIS #_meta/concept\nNOT #_meta/exercise\nIS #_meta/definition\nNOT #_meta/example\nNOT #_meta/narrative\n...\nNOT #_meta/TODO/merge\nNOT #_meta/TODO/delete\nNOT #_meta/hint\nNOT #_meta/how_to\nNOT #_meta/conjecture\nNOT #_meta/convention\nNOT #_meta/context\nNOT #_meta/permanent_note\nNOT #_meta/question\nNOT #_meta/problem\n\n\n\n\n6 rows × 24 columns\n\n\n\n\n(Deprecated) Gather data into a pandas.DataFrame\n\nsource\n\n\n\ngather_information_note_types\n\n gather_information_note_types (vault:os.PathLike,\n                                notes:list[trouver.markdown.obsidian.vault\n                                .VaultNote],\n                                raise_error_that_arises:bool=True)\n\nReturn a pandas.DataFrame encapsulating the data of note labels.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nvault\nPathLike\n\n\n\n\nnotes\nlist\n\n\n\n\nraise_error_that_arises\nbool\nTrue\n\n\n\nReturns\nDataFrame\n\nHas columns Time added, Time modified, Note name, Full note content, Processed note content as well as columns for each tag label. See append_to_information_note_type_database for more details about these columns.\n\n\n\n\ntest_vault = _test_directory() / 'test_vault_6'\nindex_note = VaultNote(test_vault, name='_index_1_introduction_reference_with_tag_labels')\n# There are just 5 notes\nnotes = notes_linked_in_note(index_note, as_dict=False)\ndf = gather_information_note_types(test_vault, notes)\ntest_eq(len(df), 6)\ndf.head()\n\nC:\\Users\\hyunj\\AppData\\Local\\Temp\\ipykernel_24944\\2112522642.py:5: DeprecationWarning: Call to deprecated function (or staticmethod) gather_information_note_types. (Use Using a pandas `DataFrame` is slow. Use `information_note_types_as_dataset` instead to gather data as a `Dataset`.)\n  df = gather_information_note_types(test_vault, notes)\nc:\\Users\\hyunj\\Documents\\Development\\Python\\trouver_py310_venv\\lib\\site-packages\\bs4\\__init__.py:435: MarkupResemblesLocatorWarning: The input looks more like a filename than markup. You may want to open this file and pass the filehandle into Beautiful Soup.\n  warnings.warn(\n\n\n\n\n\n\n\n\n\nTime added\nTime modified\nNote name\nFull note content\nProcessed note content\n#_meta/concept\n#_meta/exercise\n#_meta/definition\n#_meta/example\n#_meta/narrative\n...\n#_meta/TODO/merge\n#_meta/TODO/delete\n#_meta/hint\n#_meta/how_to\n#_meta/conjecture\n#_meta/convention\n#_meta/context\n#_meta/permanent_note\n#_meta/question\n#_meta/problem\n\n\n\n\n0\n2024-12-16T17:26\n2024-12-16T17:26\nreference_with_tag_labels_something_something\n---\\ncssclass: clean-embeds\\naliases: []\\ntags: [_meta/literature_note, _meta/narrative]\\n---\\n# Topic[^1]\\n\\nIn this chapter, we describe some basics of ring theory. Rings are mathematical structures which generalize the structures of the familiar integers, rational numbers, real numbers, complex numberes, etc.\\n\\n\\n\\n# See Also\\n\\n# Meta\\n## References\\n\\n## Citations and Footnotes\\n[^1]: Kim, Page 1\nIn this chapter, we describe some basics of ring theory. Rings are mathematical structures which generalize the structures of the familiar integers, rational numbers, real numbers, complex numberes, etc.\\n\nNOT #_meta/concept\nNOT #_meta/exercise\nNOT #_meta/definition\nNOT #_meta/example\nIS #_meta/narrative\n...\nNOT #_meta/TODO/merge\nNOT #_meta/TODO/delete\nNOT #_meta/hint\nNOT #_meta/how_to\nNOT #_meta/conjecture\nNOT #_meta/convention\nNOT #_meta/context\nNOT #_meta/permanent_note\nNOT #_meta/question\nNOT #_meta/problem\n\n\n1\n2024-12-16T17:26\n2024-12-16T17:26\nreference_with_tag_labels_Definition 1\n---\\ncssclass: clean-embeds\\naliases: []\\ntags: [_meta/literature_note, _meta/definition]\\n---\\n# Ring[^1]\\n\\nA **ring** is a set with binary operators $+$ and $\\cdot$ such that ...\\n\\n# See Also\\n\\n# Meta\\n## References\\n\\n## Citations and Footnotes\\n[^1]: Kim, Definition 1\nA ring is a set with binary operators $+$ and $\\cdot$ such that ...\\n\nNOT #_meta/concept\nNOT #_meta/exercise\nIS #_meta/definition\nNOT #_meta/example\nNOT #_meta/narrative\n...\nNOT #_meta/TODO/merge\nNOT #_meta/TODO/delete\nNOT #_meta/hint\nNOT #_meta/how_to\nNOT #_meta/conjecture\nNOT #_meta/convention\nNOT #_meta/context\nNOT #_meta/permanent_note\nNOT #_meta/question\nNOT #_meta/problem\n\n\n2\n2024-12-16T17:26\n2024-12-16T17:26\nreference_with_tag_labels_Definition 2\n---\\ncssclass: clean-embeds\\naliases: []\\ntags: [_meta/literature_note, _meta/definition, _meta/notation]\\n---\\n# Ring of integers modulo $n$[^1]\\n\\nLet $n \\geq 1$ be an integer. The **ring of integers modulo $n$**, denoted by **$\\mathbb{Z}/n\\mathbb{Z}$**, is, informally, the ring whose elements are represented by the integers with the understanding that $0$ and $n$ are equal.\\n\\nMore precisely, $\\mathbb{Z}/n\\mathbb{Z}$ has the elements $0,1,\\ldots,n-1$.\\n\\n...\\n\\n\\n# See Also\\n- [[reference_with_tag_labels_Exercise 1|reference_with_tag_labels_Z_nZ_is_a_ring]]\\n# Meta\\n## References\\n\\n## ...\nLet $n \\geq 1$ be an integer. The ring of integers modulo $n$, denoted by $\\mathbb{Z}/n\\mathbb{Z}$, is, informally, the ring whose elements are represented by the integers with the understanding that $0$ and $n$ are equal.\\n\\nMore precisely, $\\mathbb{Z}/n\\mathbb{Z}$ has the elements $0,1,\\ldots,n-1$.\\n\\n...\\n\nNOT #_meta/concept\nNOT #_meta/exercise\nIS #_meta/definition\nNOT #_meta/example\nNOT #_meta/narrative\n...\nNOT #_meta/TODO/merge\nNOT #_meta/TODO/delete\nNOT #_meta/hint\nNOT #_meta/how_to\nNOT #_meta/conjecture\nNOT #_meta/convention\nNOT #_meta/context\nNOT #_meta/permanent_note\nNOT #_meta/question\nNOT #_meta/problem\n\n\n3\n2024-12-16T17:26\n2024-12-16T17:26\nreference_with_tag_labels_Exercise 1\n---\\ncssclass: clean-embeds\\naliases: [reference_with_tag_labels_Z_nZ_is_a_ring]\\ntags: [_meta/literature_note, _meta/exercise]\\n---\\n# $\\mathbb{Z}/n\\mathbb{Z}$ is a ring[^1]\\n\\nShow that $\\mathbb{Z}/n\\mathbb{Z}$ is a ring.\\n\\n# See Also\\n\\n# Meta\\n## References\\n\\n## Citations and Footnotes\\n[^1]: Exercise 1\nShow that $\\mathbb{Z}/n\\mathbb{Z}$ is a ring.\\n\nNOT #_meta/concept\nIS #_meta/exercise\nNOT #_meta/definition\nNOT #_meta/example\nNOT #_meta/narrative\n...\nNOT #_meta/TODO/merge\nNOT #_meta/TODO/delete\nNOT #_meta/hint\nNOT #_meta/how_to\nNOT #_meta/conjecture\nNOT #_meta/convention\nNOT #_meta/context\nNOT #_meta/permanent_note\nNOT #_meta/question\nNOT #_meta/problem\n\n\n4\n2024-12-16T17:26\n2024-12-16T17:26\nreference_with_tag_labels_Theorem 1\n---\\ncssclass: clean-embeds\\naliases: []\\ntags: [_meta/literature_note, _meta/concept, _meta/proof]\\n---\\n# The polynomial ring of a UFD is a UFD[^1]\\n\\nTheorem 1. Let $R$ be a UFD. Then $R[x]$ is a UFD.\\n\\nProof. Let $f,g \\in R[x]$ and suppose that $fg = 0$. Write $f = \\sum_{i=0}^n a_i x^i$ and $g = \\sum_{j=0}^m b_j x^j$ for some $a_i,b_j \\in R$.\\n\\n...\\n\\n# See Also\\n\\n# Meta\\n## References\\n\\n## Citations and Footnotes\\n[^1]: Kim, Theorem 1\nTheorem 1. Let $R$ be a UFD. Then $R[x]$ is a UFD.\\n\\nProof. Let $f,g \\in R[x]$ and suppose that $fg = 0$. Write $f = \\sum_{i=0}^n a_i x^i$ and $g = \\sum_{j=0}^m b_j x^j$ for some $a_i,b_j \\in R$.\\n\\n...\\n\nIS #_meta/concept\nNOT #_meta/exercise\nNOT #_meta/definition\nNOT #_meta/example\nNOT #_meta/narrative\n...\nNOT #_meta/TODO/merge\nNOT #_meta/TODO/delete\nNOT #_meta/hint\nNOT #_meta/how_to\nNOT #_meta/conjecture\nNOT #_meta/convention\nNOT #_meta/context\nNOT #_meta/permanent_note\nNOT #_meta/question\nNOT #_meta/problem\n\n\n\n\n5 rows × 24 columns\n\n\n\n\nsource\n\n\nappend_to_information_note_type_database\n\n append_to_information_note_type_database (vault:os.PathLike,\n                                           file:os.PathLike, notes:list[tr\n                                           ouver.markdown.obsidian.vault.V\n                                           aultNote], backup:bool=True)\n\n*Either create a csv file containing data for information note type labels or append to an existing csv file.\nThe columns of the database file are as follows:\n\nTime added - The time when the row was added.\nTime modified - The time when the labels of the row\nNote name - The name of the note from which the data for the row was derived.\nFull note content - The entire content/text of the note.\nProcessed note content - The “raw” content of the note without the YAML frontmatter meta, Markdown headings, links, footnotes, etc.\n\nAll timestamps are in UTC time and specify time to minutes (i.e. no seconds/microseconds).\nIf a “new” note has the same processed content as a pre-existing note and anything is different about the “new” note, then update the row of the existing note. In particular, the following are updated: - Time modified (set to current time) - Note name (overwritten) - Full note content (overwritten) - Columns for categorization (overwritten)\nThis method assumes that all the processed content in the CSV file are all distinct if the CSV file exists.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nvault\nPathLike\n\nThe vault freom which the data is drawn\n\n\nfile\nPathLike\n\nThe path to a CSV file\n\n\nnotes\nlist\n\nthe notes to add to the database\n\n\nbackup\nbool\nTrue\nIf True, makes a copy of file in the same directory and with the same name, except with an added extension of .bak.\n\n\nReturns\nNone\n\n\n\n\n\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'test_vault_6'\n    shutil.copytree(_test_directory() / 'test_vault_6', temp_vault)\n\n    index_note = VaultNote(temp_vault, name='_index_1_introduction_reference_with_tag_labels')\n    notes = notes_linked_in_note(index_note, as_dict=False)\n    file = temp_vault / '_ml_data' / 'information_note_type_labels.csv'\n    append_to_information_note_type_database(\n         temp_vault, file, notes)\n\n    # Uncomment these lines to see `temp_vault` and its contents.\n#     os.startfile(os.getcwd())\n#     input()\n    df = pd.read_csv(file)\n    print(df.head())\n\nC:\\Users\\hyunj\\AppData\\Local\\Temp\\ipykernel_24944\\2798749500.py:8: DeprecationWarning: Call to deprecated function (or staticmethod) append_to_information_note_type_database. (Use Using a pandas `DataFrame` is slow. Use `information_note_types_as_dataset` instead to gather data as a `Dataset`.)\n  append_to_information_note_type_database(\nC:\\Users\\hyunj\\AppData\\Local\\Temp\\ipykernel_24944\\381146521.py:42: DeprecationWarning: Call to deprecated function (or staticmethod) gather_information_note_types. (Use Using a pandas `DataFrame` is slow. Use `information_note_types_as_dataset` instead to gather data as a `Dataset`.)\n  new_df = gather_information_note_types(vault, notes)\n\n\n         Time added     Time modified  \\\n0  2024-12-16T17:26  2024-12-16T17:26   \n1  2024-12-16T17:26  2024-12-16T17:26   \n2  2024-12-16T17:26  2024-12-16T17:26   \n3  2024-12-16T17:26  2024-12-16T17:26   \n4  2024-12-16T17:26  2024-12-16T17:26   \n\n                                       Note name  \\\n0  reference_with_tag_labels_something_something   \n1         reference_with_tag_labels_Definition 1   \n2         reference_with_tag_labels_Definition 2   \n3           reference_with_tag_labels_Exercise 1   \n4            reference_with_tag_labels_Theorem 1   \n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         Full note content  \\\n0                                                                                                                                                                                                    ---\\ncssclass: clean-embeds\\naliases: []\\ntags: [_meta/literature_note, _meta/narrative]\\n---\\n# Topic[^1]\\n\\nIn this chapter, we describe some basics of ring theory. Rings are mathematical structures which generalize the structures of the familiar integers, rational numbers, real numbers, complex numberes, etc.\\n\\n\\n\\n# See Also\\n\\n# Meta\\n## References\\n\\n## Citations and Footnotes\\n[^1]: Kim, Page 1   \n1                                                                                                                                                                                                                                                                                                                                      ---\\ncssclass: clean-embeds\\naliases: []\\ntags: [_meta/literature_note, _meta/definition]\\n---\\n# Ring[^1]\\n\\nA **ring** is a set with binary operators $+$ and $\\cdot$ such that ...\\n\\n# See Also\\n\\n# Meta\\n## References\\n\\n## Citations and Footnotes\\n[^1]: Kim, Definition 1   \n2  ---\\ncssclass: clean-embeds\\naliases: []\\ntags: [_meta/literature_note, _meta/definition, _meta/notation]\\n---\\n# Ring of integers modulo $n$[^1]\\n\\nLet $n \\geq 1$ be an integer. The **ring of integers modulo $n$**, denoted by **$\\mathbb{Z}/n\\mathbb{Z}$**, is, informally, the ring whose elements are represented by the integers with the understanding that $0$ and $n$ are equal.\\n\\nMore precisely, $\\mathbb{Z}/n\\mathbb{Z}$ has the elements $0,1,\\ldots,n-1$.\\n\\n...\\n\\n\\n# See Also\\n- [[reference_with_tag_labels_Exercise 1|reference_with_tag_labels_Z_nZ_is_a_ring]]\\n# Meta\\n## References\\n\\n## ...   \n3                                                                                                                                                                                                                                                                                                   ---\\ncssclass: clean-embeds\\naliases: [reference_with_tag_labels_Z_nZ_is_a_ring]\\ntags: [_meta/literature_note, _meta/exercise]\\n---\\n# $\\mathbb{Z}/n\\mathbb{Z}$ is a ring[^1]\\n\\nShow that $\\mathbb{Z}/n\\mathbb{Z}$ is a ring.\\n\\n# See Also\\n\\n# Meta\\n## References\\n\\n## Citations and Footnotes\\n[^1]: Exercise 1   \n4                                                                                                                                                          ---\\ncssclass: clean-embeds\\naliases: []\\ntags: [_meta/literature_note, _meta/concept, _meta/proof]\\n---\\n# The polynomial ring of a UFD is a UFD[^1]\\n\\nTheorem 1. Let $R$ be a UFD. Then $R[x]$ is a UFD.\\n\\nProof. Let $f,g \\in R[x]$ and suppose that $fg = 0$. Write $f = \\sum_{i=0}^n a_i x^i$ and $g = \\sum_{j=0}^m b_j x^j$ for some $a_i,b_j \\in R$.\\n\\n...\\n\\n# See Also\\n\\n# Meta\\n## References\\n\\n## Citations and Footnotes\\n[^1]: Kim, Theorem 1   \n\n                                                                                                                                                                                                                                                                                                   Processed note content  \\\n0                                                                                                           In this chapter, we describe some basics of ring theory. Rings are mathematical structures which generalize the structures of the familiar integers, rational numbers, real numbers, complex numberes, etc.\\n   \n1                                                                                                                                                                                                                                                   A ring is a set with binary operators $+$ and $\\cdot$ such that ...\\n   \n2  Let $n \\geq 1$ be an integer. The ring of integers modulo $n$, denoted by $\\mathbb{Z}/n\\mathbb{Z}$, is, informally, the ring whose elements are represented by the integers with the understanding that $0$ and $n$ are equal.\\n\\nMore precisely, $\\mathbb{Z}/n\\mathbb{Z}$ has the elements $0,1,\\ldots,n-1$.\\n\\n...\\n   \n3                                                                                                                                                                                                                                                                         Show that $\\mathbb{Z}/n\\mathbb{Z}$ is a ring.\\n   \n4                                                                                                           Theorem 1. Let $R$ be a UFD. Then $R[x]$ is a UFD.\\n\\nProof. Let $f,g \\in R[x]$ and suppose that $fg = 0$. Write $f = \\sum_{i=0}^n a_i x^i$ and $g = \\sum_{j=0}^m b_j x^j$ for some $a_i,b_j \\in R$.\\n\\n...\\n   \n\n       #_meta/concept      #_meta/exercise      #_meta/definition  \\\n0  NOT #_meta/concept  NOT #_meta/exercise  NOT #_meta/definition   \n1  NOT #_meta/concept  NOT #_meta/exercise   IS #_meta/definition   \n2  NOT #_meta/concept  NOT #_meta/exercise   IS #_meta/definition   \n3  NOT #_meta/concept   IS #_meta/exercise  NOT #_meta/definition   \n4   IS #_meta/concept  NOT #_meta/exercise  NOT #_meta/definition   \n\n       #_meta/example      #_meta/narrative  ...      #_meta/TODO/merge  \\\n0  NOT #_meta/example   IS #_meta/narrative  ...  NOT #_meta/TODO/merge   \n1  NOT #_meta/example  NOT #_meta/narrative  ...  NOT #_meta/TODO/merge   \n2  NOT #_meta/example  NOT #_meta/narrative  ...  NOT #_meta/TODO/merge   \n3  NOT #_meta/example  NOT #_meta/narrative  ...  NOT #_meta/TODO/merge   \n4  NOT #_meta/example  NOT #_meta/narrative  ...  NOT #_meta/TODO/merge   \n\n       #_meta/TODO/delete      #_meta/hint      #_meta/how_to  \\\n0  NOT #_meta/TODO/delete  NOT #_meta/hint  NOT #_meta/how_to   \n1  NOT #_meta/TODO/delete  NOT #_meta/hint  NOT #_meta/how_to   \n2  NOT #_meta/TODO/delete  NOT #_meta/hint  NOT #_meta/how_to   \n3  NOT #_meta/TODO/delete  NOT #_meta/hint  NOT #_meta/how_to   \n4  NOT #_meta/TODO/delete  NOT #_meta/hint  NOT #_meta/how_to   \n\n       #_meta/conjecture      #_meta/convention      #_meta/context  \\\n0  NOT #_meta/conjecture  NOT #_meta/convention  NOT #_meta/context   \n1  NOT #_meta/conjecture  NOT #_meta/convention  NOT #_meta/context   \n2  NOT #_meta/conjecture  NOT #_meta/convention  NOT #_meta/context   \n3  NOT #_meta/conjecture  NOT #_meta/convention  NOT #_meta/context   \n4  NOT #_meta/conjecture  NOT #_meta/convention  NOT #_meta/context   \n\n       #_meta/permanent_note      #_meta/question      #_meta/problem  \n0  NOT #_meta/permanent_note  NOT #_meta/question  NOT #_meta/problem  \n1  NOT #_meta/permanent_note  NOT #_meta/question  NOT #_meta/problem  \n2  NOT #_meta/permanent_note  NOT #_meta/question  NOT #_meta/problem  \n3  NOT #_meta/permanent_note  NOT #_meta/question  NOT #_meta/problem  \n4  NOT #_meta/permanent_note  NOT #_meta/question  NOT #_meta/problem  \n\n[5 rows x 24 columns]\n\n\nc:\\Users\\hyunj\\Documents\\Development\\Python\\trouver_py310_venv\\lib\\site-packages\\bs4\\__init__.py:435: MarkupResemblesLocatorWarning: The input looks more like a filename than markup. You may want to open this file and pass the filehandle into Beautiful Soup.\n  warnings.warn(",
    "crumbs": [
      "markdown.obsidian.personal.machine_learning.information_note_types"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.machine_learning.information_note_types.html#use-the-trained-model-to-predict-note-types",
    "href": "markdown.obsidian.personal.machine_learning.information_note_types.html#use-the-trained-model-to-predict-note-types",
    "title": "markdown.obsidian.personal.machine_learning.information_note_types",
    "section": "Use the trained model to predict note types",
    "text": "Use the trained model to predict note types\nAfter training the model (cf. how_to.train_ml_model.fastai), we can now predict the types of notes\n\nsource\n\npossible_text_type_labels\n\n possible_text_type_labels (learn:fastai.text.learner.TextLearner)\n\nReturn the possible labels outputted by learn.predict\n\nsource\n\n\npredict_text_types_with_one_learner\n\n predict_text_types_with_one_learner\n                                      (learner:fastai.text.learner.TextLea\n                                      rner, texts:list[str],\n                                      remove_NO_TAG:bool=True,\n                                      include_probabilities:bool=False)\n\nPredict the types of mathematical texts using an ML model.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nlearner\nTextLearner\n\nThe ML models predicting note types.\n\n\ntexts\nlist\n\n\n\n\nremove_NO_TAG\nbool\nTrue\nIf True, remove NO_TAG, which in theory is supposed to indicate that no types are predicted, but in practice can somehow be predicted along with actual types.\n\n\ninclude_probabilities\nbool\nFalse\nIf True, then\n\n\nReturns\nlist\n\nEach list or tuple corresponds to each entry from text and contains the predicted types of the text. A list[str] consists of the predicted types/labels of the text and a tuple[list[str], dict[str,float]] contains the list of predicted types along with a dict of all possible types predictable by learn along with probabilities.\n\n\n\nWe can predict types of short mathematical texts. Say that the information note type classification model, trained in how_to.train_ml_model.fastai is loaded, e.g. via fastai’s load_learner function:\nmodel = load_learner(&lt;path_to_model&gt;)\n\ntexts_to_predict = [\n    '',\n    'In this chapter, we introduce the notion of rings, some related notions, and many examples.',\n    'A ring is a set equipped with two binary operators $+$ and $\\cdot$ such that...',\n    'Theorem. For every prime power $q$, there is, up to isomorphism, exactly one field with $q$ elements.\\n\\nProof. Let $q = p^k$ where $p$ is a prime. Let $F$ be a field with $q$ elements. Note that...',\n    'Remark. Note that $\\mathbb{F}_q$ and $\\mathbb{Z}/q\\mathbb{Z}$ are different rings',\n    'As an example, take $\\mathbb{F}_9$. It can be presented as $\\mathbb{F}_3[x^2+1]$ as well as $\\mathbb{F}_3[x^2+x+2]$.'\n]\nsample_outputs = predict_text_types_with_one_learner(\n    model, texts_to_predict)\n\nprint(sample_outputs)\n\n[['#_meta/TODO/delete', '#_meta/TODO/merge', '#_meta/TODO/split', '#_meta/concept', '#_meta/proof'], ['#_meta/TODO/split'], ['#_meta/TODO/split', '#_meta/definition'], ['#_meta/concept', '#_meta/proof'], ['#_meta/TODO/split', '#_meta/remark'], ['#_meta/example', '#_meta/narrative']]\n\n\n\npossible_text_type_labels(model)\nsample_outputs = predict_text_types_with_one_learner(model, texts_to_predict, include_probabilities=True)\nprint(sample_outputs[0][0])\nprint(sample_outputs[0][1])\nprint(sample_outputs[0][1])\n\n['#_meta/TODO/delete', '#_meta/TODO/merge', '#_meta/TODO/split', '#_meta/concept', '#_meta/proof']\n{'#_meta/TODO/delete': 1.0, '#_meta/TODO/merge': 0.8483227491378784, '#_meta/TODO/split': 0.9903709292411804, '#_meta/concept': 0.6789883375167847, '#_meta/conjecture': 8.332841361369248e-12, '#_meta/convention': 0.3710557222366333, '#_meta/definition': 4.3158637708984315e-05, '#_meta/example': 4.248961886332836e-06, '#_meta/exercise': 1.3349553228181321e-05, '#_meta/how_to': 6.355472578434274e-05, '#_meta/narrative': 7.353986575253657e-07, '#_meta/notation': 1.661649002926424e-05, '#_meta/proof': 0.9312137365341187, '#_meta/remark': 0.001952954800799489, 'NO_TAG': 4.766645744780362e-09}\n{'#_meta/TODO/delete': 1.0, '#_meta/TODO/merge': 0.8483227491378784, '#_meta/TODO/split': 0.9903709292411804, '#_meta/concept': 0.6789883375167847, '#_meta/conjecture': 8.332841361369248e-12, '#_meta/convention': 0.3710557222366333, '#_meta/definition': 4.3158637708984315e-05, '#_meta/example': 4.248961886332836e-06, '#_meta/exercise': 1.3349553228181321e-05, '#_meta/how_to': 6.355472578434274e-05, '#_meta/narrative': 7.353986575253657e-07, '#_meta/notation': 1.661649002926424e-05, '#_meta/proof': 0.9312137365341187, '#_meta/remark': 0.001952954800799489, 'NO_TAG': 4.766645744780362e-09}\n\n\n\nsource\n\n\nconsolidate_single_text_predictions_by_sum_of_confidence\n\n consolidate_single_text_predictions_by_sum_of_confidence\n                                                           (predictions_fo\n                                                           r_single_text:l\n                                                           ist[tuple[list[\n                                                           str],dict[str,f\n                                                           loat]]])\n\n*Consolidate single text predictions by summing the “probabilities” predicted by the various models. If the sum of the probabilities that the label should be predicted is greater than the sum of the probabilities that the label should not be predicted, then the label is predicted.\nThis is a sample input to the consolidation parameter of the predict_note_types function*\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\npredictions_for_single_text\nlist\nEach tuple corresponds to the predictions made by each model.\n\n\nReturns\nlist\nThe labels\n\n\n\n\nsource\n\n\npredict_note_types\n\n predict_note_types (learners:fastai.text.learner.TextLearner|list[fastai.\n                     text.learner.TextLearner], vault:os.PathLike, notes:l\n                     ist[trouver.markdown.obsidian.vault.VaultNote],\n                     remove_NO_TAG:bool=True,\n                     consolidation:Optional[Callable]=&lt;function consolidat\n                     e_single_text_predictions_by_sum_of_confidence&gt;)\n\n*Parameters\nReturns*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nlearners\nfastai.text.learner.TextLearner | list[fastai.text.learner.TextLearner]\n\nThe ML models predicting note types.\n\n\nvault\nPathLike\n\nThe vault with the notes.\n\n\nnotes\nlist\n\nThe notes with texts to predict\n\n\nremove_NO_TAG\nbool\nTrue\nIf True, remove NO_TAG, which in theory is supposed to indicate that no types are predicted, but in practice can somehow be predicted along with actual types.\n\n\nconsolidation\nOptional\nconsolidate_single_text_predictions_by_sum_of_confidence\nThe method to consolidate between different predictions made by the possibly more-than-one model in learners.\n\n\nReturns\nlist\n\nEach list[str]`` corresponds to an item innotes` and contains the predicted note types for that note.\n\n\n\n\n# TODO: tests\n# predict_note_types\n\ntest_vault = _test_directory() / 'test_vault_6'\nnotes_to_predict = [\n    VaultNote(test_vault, name='reference_with_tag_labels_Theorem 1'),\n    VaultNote(test_vault, name='reference_with_tag_labels_Definition 1')\n]\nsample_outputs = predict_note_types(model, test_vault, notes_to_predict)\n\nprint(\n    f'The following are the raw content of the notes without'\n    f'metadata along with the model\\'s predictions for their types:\\n\\n')\nfor note, prediction in zip(notes_to_predict, sample_outputs):\n    print(process_standard_information_note(MarkdownFile.from_vault_note(note), test_vault) )\n    print(prediction, '\\n\\n')\n\nc:\\Users\\hyunj\\Documents\\Development\\Python\\trouver_py310_venv\\lib\\site-packages\\bs4\\__init__.py:435: MarkupResemblesLocatorWarning: The input looks more like a filename than markup. You may want to open this file and pass the filehandle into Beautiful Soup.\n  warnings.warn(\n\n\nThe following are the raw content of the notes withoutmetadata along with the model's predictions for their types:\n\n\nTheorem 1. Let $R$ be a UFD. Then $R[x]$ is a UFD.\n\nProof. Let $f,g \\in R[x]$ and suppose that $fg = 0$. Write $f = \\sum_{i=0}^n a_i x^i$ and $g = \\sum_{j=0}^m b_j x^j$ for some $a_i,b_j \\in R$.\n\n...\n\n['#_meta/concept', '#_meta/proof'] \n\n\nA ring is a set with binary operators $+$ and $\\cdot$ such that ...\n\n['#_meta/definition', '#_meta/TODO/split'] \n\n\n\n\nc:\\Users\\hyunj\\Documents\\Development\\Python\\trouver_py310_venv\\lib\\site-packages\\bs4\\__init__.py:435: MarkupResemblesLocatorWarning: The input looks more like a filename than markup. You may want to open this file and pass the filehandle into Beautiful Soup.\n  warnings.warn(\n\n\n\nwith (mock.patch('__main__.MarkdownFile.from_vault_note') as mock_markdownfile_from_vault_note,\n          mock.patch('__main__.process_standard_information_note') as mock_process_standard_information_note,\n          mock.patch('__main__.load_learner') as mock_load_learner,\n          mock.patch('__main__.possible_text_type_labels') as mock_possible_text_type_labels):\n      mock_path, mock_vault = None, None\n      mock_notes = [None, None, None, None, None]\n      mock_learner = load_learner(mock_path)\n      mock_possible_text_type_labels.return_value = ['#_meta/TODO/delete', '#_meta/TODO/merge', '#_meta/TODO/split', '#_meta/concept', '#_meta/conjecture', '#_meta/convention', '#_meta/definition', '#_meta/example', '#_meta/exercise', '#_meta/how_to', '#_meta/narrative', '#_meta/notation', '#_meta/proof', '#_meta/remark', 'NO_TAG']\n      mock_learner.predict.side_effect = [\n          (['#_meta/TODO/delete','#_meta/TODO/split','#_meta/concept','#_meta/convention'],\n            tensor([ True, False,  True,  True, False,  True, False, False, False, False,\n                    False, False, False, False, False]),\n            tensor([1.0000e+00, 1.0748e-02, 8.5110e-01, 8.2098e-01, 3.0918e-09, 8.9845e-01,\n                    6.3798e-03, 1.1441e-06, 2.3794e-07, 1.7402e-02, 3.2704e-06, 1.6747e-03,\n                    2.1008e-01, 3.8969e-04, 3.7873e-07])),\n          (['#_meta/narrative'],\n            tensor([False, False, False, False, False, False, False, False, False, False,\n                      True, False, False, False, False]),\n            tensor([8.4556e-06, 3.2360e-06, 2.0235e-01, 1.1844e-03, 5.1291e-08, 2.9886e-07,\n                    4.8174e-04, 8.9895e-06, 1.3379e-09, 2.8261e-11, 9.9701e-01, 5.8664e-04,\n                    2.6031e-03, 1.4012e-02, 1.3595e-03])),\n          (['#_meta/TODO/delete', 'NO_TAG'], tensor([ True, False, False, False, False, False, False, False, False, False,\n            False, False, False,  True]), tensor([6.1455e-01, 1.6902e-01, 1.4254e-02, 5.1358e-02, 4.8857e-05, 3.0853e-04,\n            6.0457e-03, 1.2064e-04, 8.5651e-02, 1.3941e-02, 5.2413e-04, 1.3709e-01,\n            9.7726e-06, 0.00, 9.7614e-01])),\n          (['#_meta/concept', '#_meta/proof'], tensor([False, False, False,  True, False, False, False, False, False, False,\n            False,  True, False, False]), tensor([4.0871e-03, 3.6683e-04, 1.6594e-01, 9.7876e-01, 0.00, 6.0281e-05, 8.7817e-06,\n            1.9275e-02, 1.5589e-03, 4.5301e-03, 7.8989e-03, 1.2528e-02, 9.2800e-01, \n            9.4636e-04, 1.4658e-02])),\n          (['NO_TAG'], tensor([ True, False, False, False, False, False, False, False, False, False,\n            False, False, False,  True]), tensor([6.1455e-02, 1.6902e-01, 1.4254e-02, 5.1358e-02, 4.8857e-05, 3.0853e-04,\n            6.0457e-03, 1.2064e-04, 8.5651e-02, 1.3941e-02, 5.2413e-04, 1.3709e-01,\n            9.7726e-06, 0.00, 9.7614e-01])),\n      ]\n      prediction = predict_note_types(mock_learner, mock_vault, mock_notes)\n      correct_value = [['#_meta/TODO/delete', '#_meta/TODO/split', '#_meta/convention', '#_meta/concept'],\n         ['#_meta/narrative'],\n         ['#_meta/TODO/delete'],\n         ['#_meta/proof', '#_meta/concept'],\n         []]\n      test_eq(len(prediction), len(correct_value))\n      for first, second in zip(prediction, correct_value):\n          try:\n              test(first, second, all_equal)\n          except AssertionError:\n               test_shuffled(first, second)\n\n      mock_notes = [None, None]\n      mock_learner.predict.side_effect = [\n          (['#_meta/TODO/delete', 'NO_TAG'], tensor([ True, False, False, False, False, False, False, False, False, False,\n            False, False, False,  True]), tensor([6.1455e-01, 1.6902e-01, 1.4254e-02, 5.1358e-02, 4.8857e-05, 3.0853e-04,\n            6.0457e-03, 1.2064e-04, 8.5651e-02, 1.3941e-02, 5.2413e-04, 1.3709e-01,\n            9.7726e-06, 0.00, 9.7614e-01])),\n          (['NO_TAG'], tensor([ True, False, False, False, False, False, False, False, False, False,\n            False, False, False,  True]), tensor([6.1455e-02, 1.6902e-01, 1.4254e-02, 5.1358e-02, 4.8857e-05, 3.0853e-04,\n            6.0457e-03, 1.2064e-04, 8.5651e-02, 1.3941e-02, 5.2413e-04, 1.3709e-01,\n            9.7726e-06, 0.00, 9.7614e-01])),\n      ]\n\n      prediction = predict_note_types(mock_learner, mock_vault, mock_notes, remove_NO_TAG=False)\n      correct_value = [['NO_TAG', '#_meta/TODO/delete'],\n         ['NO_TAG']]\n      test_eq(len(prediction), len(correct_value))\n      for first, second in zip(prediction, correct_value):\n          try:\n              test(first, second, all_equal)\n          except AssertionError:\n               test_shuffled(first, second)\n\n\nsource\n\n\nautomatically_add_note_type_tags\n\n automatically_add_note_type_tags (learners:fastai.text.learner.TextLearne\n                                   r|list[fastai.text.learner.TextLearner]\n                                   , vault:os.PathLike, notes:list[trouver\n                                   .markdown.obsidian.vault.VaultNote],\n                                   add_auto_label:bool=True,\n                                   overwrite:Optional[str]=None)\n\n*Predict note types and add the predicted types as frontmatter YAML tags in the notes.\nNon-_auto-labeled tags take precedent over auto-labeled tags, unless overwrite='w'.\nRaises\n\nWarning:\n\nIf overwrite=None, a note already has some note type tags, and learn predicts different note types as those in the note.*\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nlearners\nfastai.text.learner.TextLearner | list[fastai.text.learner.TextLearner]\n\nThe ML model(s) predicting note types.\n\n\nvault\nPathLike\n\nThe vault with the notes\n\n\nnotes\nlist\n\n\n\n\nadd_auto_label\nbool\nTrue\nIf True, adds \"_auto\" to the front of the note type tag to indicate that the tags were added via this automated script.\n\n\noverwrite\nOptional\nNone\nEither 'w', 'ws', 'ww', 'a', or None. If 'w' or 'ws', then overwrite any already-existing note type tags (from LABEL_TAGS), whether or not these tags are _auto tags, with the predicted tags. IF 'ww', then overwrite only the _auto tags among the already-existing note type tags with the predicted tags. If 'a', then preserve already-existing note type tags and just append the newly predicted ones; in the case that learn predicts the note type whose tag is already in the note, a new tag of that type is not added, even if add_auto_label=True. If None, then do not make modifications to each note if any note type tags already exist in the note; if the predicted note types are different from the already existing note types, then raise a warning.\n\n\nReturns\nNone\n\n\n\n\n\nIn the below examples, we use mock.patch to test adding note types without testing the ML model itself. In particular, we pretend as though the ML model returns certain predictions (technically, we pretend as though predict_note_types return certain values) to construct these examples.\nThe following example demonstrates a basic use case of adding predicted note type tags to notes without any note type tags:\n\n# Here we just test adding a note type without testing the ML model itself.\nwith (tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir,\n      mock.patch('__main__.predict_note_types') as mock_predict_note_types):\n    temp_vault = Path(temp_dir) / 'test_vault_6'\n    shutil.copytree(_test_directory() / 'test_vault_6', temp_vault)\n\n    # Example where `add_auto_label` is `True`\n    mock_predict_note_types.return_value = [['#_meta/definition'], ['#_meta/concept', '#_meta/proof']]\n    vn1 = VaultNote(temp_vault, name='reference_without_tag_labels_Definition 1')\n    vn2 = VaultNote(temp_vault, name='reference_without_tag_labels_Theorem 1')\n    notes = [vn1, vn2]\n    mock_learn = None\n    automatically_add_note_type_tags(mock_learn, temp_vault, notes)\n\n    # Note that _auto/_meta/definition has been added\n    print(vn1.text())\n    assert (MarkdownFile.from_vault_note(vn1).has_tag('_auto/_meta/definition'))\n    assert (MarkdownFile.from_vault_note(vn2).has_tag('_auto/_meta/concept'))\n    assert (MarkdownFile.from_vault_note(vn2).has_tag('_auto/_meta/proof'))\n\n\n    # Examle where `add_auto_label` is `False`\n    mock_predict_note_types.return_value = [['#_meta/definition', '#_meta/notation']]\n    notes = [VaultNote(temp_vault, name='reference_without_tag_labels_Definition 2')]\n    automatically_add_note_type_tags(mock_learn, temp_vault, notes, add_auto_label=False)\n    assert (MarkdownFile.from_vault_note(notes[0]).has_tag('_meta/definition'))\n    assert (MarkdownFile.from_vault_note(notes[0]).has_tag('_meta/notation'))\n\n---\ncssclass: clean-embeds\naliases: []\ntags: [_meta/literature_note, _auto/_meta/definition]\n---\n# Ring[^1]\n\nA **ring** is a set with binary operators $+$ and $\\cdot$ such that ...\n\n# See Also\n\n# Meta\n## References\n\n## Citations and Footnotes\n[^1]: Kim, Definition 1\n\n\nIn the following example, overwrite is set to 'w' (or 'ws'), so all preexisting note type tags are removed before the predicted ones are added:\n\nwith (tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir,\n      mock.patch('__main__.predict_note_types') as mock_predict_note_types):\n    temp_vault = Path(temp_dir) / 'test_vault_6'\n    shutil.copytree(_test_directory() / 'test_vault_6', temp_vault)\n\n    mock_predict_note_types.return_value = [['#_meta/definition']]\n    vn1 = VaultNote(temp_vault, name='reference_with_tag_labels_Definition 1')\n    notes = [vn1]\n    mock_learn = None\n    automatically_add_note_type_tags(mock_learn, temp_vault, notes, overwrite='w')\n\n    # Note that _meta/definition has been removed and _auto/_meta/definition has been added.\n    print(vn1.text())\n    assert MarkdownFile.from_vault_note(vn1).has_tag('_auto/_meta/definition')\n    assert not MarkdownFile.from_vault_note(vn1).has_tag('_meta/definition')\n\n---\ncssclass: clean-embeds\naliases: []\ntags: [_meta/literature_note, _auto/_meta/definition]\n---\n# Ring[^1]\n\nA **ring** is a set with binary operators $+$ and $\\cdot$ such that ...\n\n# See Also\n\n# Meta\n## References\n\n## Citations and Footnotes\n[^1]: Kim, Definition 1\n\n\nIn the following example, overwrite is set to 'ww', so only the _auto note type tags are removed and the predicted ones are added:\n\n# TODO: change example\nwith (tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir,\n      mock.patch('__main__.predict_note_types') as mock_predict_note_types):\n    temp_vault = Path(temp_dir) / 'test_vault_6'\n    shutil.copytree(_test_directory() / 'test_vault_6', temp_vault)\n\n    mock_predict_note_types.return_value = [['#_meta/definition']]\n    vn1 = VaultNote(temp_vault, name='reference_with_tag_labels_Definition 1')\n    notes = [vn1]\n    mock_learn = None\n    automatically_add_note_type_tags(mock_learn, temp_vault, notes, overwrite='w')\n\n    # Note that _meta/definition has been removed and _auto/_meta/definition has been added.\n    print(vn1.text())\n    assert MarkdownFile.from_vault_note(vn1).has_tag('_auto/_meta/definition')\n    assert not MarkdownFile.from_vault_note(vn1).has_tag('_meta/definition')\n\n---\ncssclass: clean-embeds\naliases: []\ntags: [_meta/literature_note, _auto/_meta/definition]\n---\n# Ring[^1]\n\nA **ring** is a set with binary operators $+$ and $\\cdot$ such that ...\n\n# See Also\n\n# Meta\n## References\n\n## Citations and Footnotes\n[^1]: Kim, Definition 1\n\n\nIn the following example, overwrite is set to 'a', so only newly predicted note type tags are added\n\nwith (tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir,\n      mock.patch('__main__.predict_note_types') as mock_predict_note_types):\n    temp_vault = Path(temp_dir) / 'test_vault_6'\n    shutil.copytree(_test_directory() / 'test_vault_6', temp_vault)\n\n    mock_predict_note_types.return_value = [['#_meta/definition', '#_meta/notation', '#_meta/concept', '#_meta/proof']]\n    vn1 = VaultNote(temp_vault, name='reference_with_tag_labels_Theorem 2')\n    notes = [vn1]\n    mock_learn = None\n    automatically_add_note_type_tags(mock_learn, temp_vault, notes, overwrite='a')\n\n    # Example with `add_auto_label=True`\n    # Note that _auto/_meta/notation has been added, but _meta/definition, _meta/concept,\n    # and #_auto/_meta/proof remain unchanged. Moreover, _auto/_meta/definition and _auto/_meta/cocnept are\n    # NOT added.\n    print(vn1.text())\n    assert MarkdownFile.from_vault_note(vn1).has_tag('_auto/_meta/notation')\n    assert MarkdownFile.from_vault_note(vn1).has_tag('_meta/definition')\n    assert MarkdownFile.from_vault_note(vn1).has_tag('_meta/concept')\n    assert MarkdownFile.from_vault_note(vn1).has_tag('_auto/_meta/proof')\n    assert not MarkdownFile.from_vault_note(vn1).has_tag('_auto/_meta/definition')\n    assert not MarkdownFile.from_vault_note(vn1).has_tag('_auto/_meta/concept')\n\n\nwith (tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir,\n      mock.patch('__main__.predict_note_types') as mock_predict_note_types):\n    temp_vault = Path(temp_dir) / 'test_vault_6'\n    shutil.copytree(_test_directory() / 'test_vault_6', temp_vault)\n\n    mock_predict_note_types.return_value = [['#_meta/definition', '#_meta/notation', '#_meta/concept', '#_meta/proof']]\n    vn1 = VaultNote(temp_vault, name='reference_with_tag_labels_Theorem 2')\n    notes = [vn1]\n    mock_learn = None\n    automatically_add_note_type_tags(mock_learn, temp_vault, notes, overwrite='a', add_auto_label=False)\n\n    # Example with `add_auto_label=False`\n    # Note that _meta/notation has been added, and _auto/_meta/proof is replaced\n    # with _meta/proof, but _meta/definition and _meta/concept remain unchanged.\n    print(vn1.text())\n    assert MarkdownFile.from_vault_note(vn1).has_tag('_meta/notation')\n    assert MarkdownFile.from_vault_note(vn1).has_tag('_meta/proof')\n    assert not MarkdownFile.from_vault_note(vn1).has_tag('_auto/_meta/proof')\n    assert MarkdownFile.from_vault_note(vn1).has_tag('_meta/definition')\n    assert MarkdownFile.from_vault_note(vn1).has_tag('_meta/concept')\n\n---\ncssclass: clean-embeds\naliases: []\ntags: [_meta/literature_note, _meta/concept, _auto/_meta/proof, _meta/definition, _auto/_meta/notation]\n---\n%%Note that this note introduces a notation and hence actually ought to be labeled with the tag _meta/notation as well; but for the sake of example, the job of adding the _meta/notation tag will be left to the `automatically_add_note_type_tags` function.%%\n\n# The polynomial ring of a UFD is a UFD[^1]\nLet $q$ be the power of a prime number. Up to isomorphism, there is a unique field with $q$ elements. This field is denoted **$\\mathbb{F}_q$** and is called the **finite field of $q$ elements**.\n\nProof. Say that $q = p^k$ and let $F$ be a field with $q$ elements. First note that $F$ has a subfield \"generated by $1$\", i.e. the elements $0,1,\\ldots,p-1$ form a subfield of $F$.\n\n# See Also\n\n# Meta\n## References\n\n## Citations and Footnotes\n[^1]: Kim, Theorem 2\n---\ncssclass: clean-embeds\naliases: []\ntags: [_meta/literature_note, _meta/concept, _meta/definition, _meta/proof, _meta/notation]\n---\n%%Note that this note introduces a notation and hence actually ought to be labeled with the tag _meta/notation as well; but for the sake of example, the job of adding the _meta/notation tag will be left to the `automatically_add_note_type_tags` function.%%\n\n# The polynomial ring of a UFD is a UFD[^1]\nLet $q$ be the power of a prime number. Up to isomorphism, there is a unique field with $q$ elements. This field is denoted **$\\mathbb{F}_q$** and is called the **finite field of $q$ elements**.\n\nProof. Say that $q = p^k$ and let $F$ be a field with $q$ elements. First note that $F$ has a subfield \"generated by $1$\", i.e. the elements $0,1,\\ldots,p-1$ form a subfield of $F$.\n\n# See Also\n\n# Meta\n## References\n\n## Citations and Footnotes\n[^1]: Kim, Theorem 2\n\n\nIn the following example, overwrite is set to None. The notes are not modified, but if the note type tags in a note do not match the predicted ones, then a warning is raised\n\n# TODO: add example",
    "crumbs": [
      "markdown.obsidian.personal.machine_learning.information_note_types"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.machine_learning.information_note_types.html#convert-_auto-tags-to-regular-tags",
    "href": "markdown.obsidian.personal.machine_learning.information_note_types.html#convert-_auto-tags-to-regular-tags",
    "title": "markdown.obsidian.personal.machine_learning.information_note_types",
    "section": "Convert _auto/ tags to regular tags",
    "text": "Convert _auto/ tags to regular tags\nAfter checking that the automatically predicted tags are correct, we can convert them to regular tags.\n\nsource\n\nconvert_auto_tags_to_regular_tags_in_notes\n\n convert_auto_tags_to_regular_tags_in_notes\n                                             (notes:list[trouver.markdown.\n                                             obsidian.vault.VaultNote], ex\n                                             clude:list[str]=['links_added\n                                             ', 'notations_added'])\n\nConvert the auto tags into regular tags for the notes.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nnotes\nlist\n\n\n\n\nexclude\nlist\n[‘links_added’, ‘notations_added’]\nThe tags whose _auto/ tags should not be converted. The str should not start with '#' and should not start with '_auto/'.\n\n\nReturns\nNone\n\n\n\n\n\n\nwith (tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir):\n    temp_vault = Path(temp_dir) / 'test_vault_6'\n    shutil.copytree(_test_directory() / 'test_vault_6', temp_vault)\n\n    vn = VaultNote(temp_vault, name='reference_with_tag_labels_Theorem 2')\n    convert_auto_tags_to_regular_tags_in_notes([vn])\n    print(vn.text())\n    mf = MarkdownFile.from_vault_note(vn)\n    assert mf.has_tag('_meta/proof')\n    assert not mf.has_tag('_auto/_meta/proof')\n\n---\ncssclass: clean-embeds\naliases: []\ntags: [_meta/literature_note, _meta/concept, _meta/proof, _meta/definition]\n---\n%%Note that this note introduces a notation and hence actually ought to be labeled with the tag _meta/notation as well; but for the sake of example, the job of adding the _meta/notation tag will be left to the `automatically_add_note_type_tags` function.%%\n\n# The polynomial ring of a UFD is a UFD[^1]\nLet $q$ be the power of a prime number. Up to isomorphism, there is a unique field with $q$ elements. This field is denoted **$\\mathbb{F}_q$** and is called the **finite field of $q$ elements**.\n\nProof. Say that $q = p^k$ and let $F$ be a field with $q$ elements. First note that $F$ has a subfield \"generated by $1$\", i.e. the elements $0,1,\\ldots,p-1$ form a subfield of $F$.\n\n# See Also\n\n# Meta\n## References\n\n## Citations and Footnotes\n[^1]: Kim, Theorem 2",
    "crumbs": [
      "markdown.obsidian.personal.machine_learning.information_note_types"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.machine_learning.information_note_types.html#footnotes",
    "href": "markdown.obsidian.personal.machine_learning.information_note_types.html#footnotes",
    "title": "markdown.obsidian.personal.machine_learning.information_note_types",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nNote that the tag in the YAML frontmatter meta is notated as _meta/definition, which lacks the starting hashtag #.↩︎",
    "crumbs": [
      "markdown.obsidian.personal.machine_learning.information_note_types"
    ]
  },
  {
    "objectID": "helper.definition_and_notation.html",
    "href": "helper.definition_and_notation.html",
    "title": "helper.definition_and_notation",
    "section": "",
    "text": "import operator\nfrom fastcore.test import *",
    "crumbs": [
      "helper.definition_and_notation"
    ]
  },
  {
    "objectID": "helper.definition_and_notation.html#definitions-and-notations",
    "href": "helper.definition_and_notation.html#definitions-and-notations",
    "title": "helper.definition_and_notation",
    "section": "Definitions and notations",
    "text": "Definitions and notations\nI surround definitions and notations by double asterisks **. The double_asterisk_indices method finds strings surrounded by double asterisks, the notation_asterisk_indices method finds notation str, and the definition_asterisk_indices method finds definition str.\n\nsource\n\ndouble_asterisk_indices\n\n double_asterisk_indices (text:str)\n\n*Return the indices in str of text surrounded by double asterisks.\nAssumes there no LaTeX math mode string has double asterisks.\nSee Also\n\nnotation_asterisk_indices\ndefinition_asterisk_indices*\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ntext\nstr\nthe str in which to find the indices of double asterisk surrounded text.\n\n\nReturns\nlist\nEach tuple is of the form (start,end), where text[start:end] is a part in text with double asterisks, including the double asterisks.\n\n\n\n\nsource\n\n\ndefinition_asterisk_indices\n\n definition_asterisk_indices (text:str)\n\n*Return the indices of definition text surrounded by double asterisks.\nA double-asterisk-surrounded-text is a definition almost always when it is not purely LaTeX math mode text.\nAssumes that no LaTeX math mode string has double asterisks and that no LaTeX math mode string has the dollar sign character within it.*\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ntext\nstr\nThe str in which to find the indices of the definitions surrounded by double asterisks.\n\n\nReturns\nlist\nEach tuple is of the form (start,end), where text[start:end] is a substring in text surrounded by double asterisks, including the double asterisks.\n\n\n\n\nsource\n\n\nnotation_asterisk_indices\n\n notation_asterisk_indices (text:str)\n\n*Return the indices of notation text surrounded by double asterisks.\nA double-asterisk-surrounded-text is a notation almost always when it is purely LaTeX math mode text.\nAssumes that no LaTeX math mode string has the dollar sign character within it.*\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ntext\nstr\nthe str in which to find the indices of notations surrounded by double asterisks.\n\n\nReturns\nlist\nEach tuple is of the form (start,end), where text[start:end] is a part in text with LaTeX math mode text with double asterisks, including the double asterisks.\n\n\n\n\nExamples\nIn the following example, scheme and structure sheaf are definitions, whereas $\\mathcal{O}_X$ is a notation:\n\ntext = r'A **scheme** is a... the **structure sheaf** of a scheme $X$ is the sheaf **$\\mathcal{O}_X$**.'\nlisty = double_asterisk_indices(text)\n\nstart, end = listy[0]\ntest_eq(text[start:end], '**scheme**')\n\nstart, end = listy[1]\ntest_eq(text[start:end], '**structure sheaf**')\n\nstart, end = listy[2]\ntest_eq(text[start:end], '**$\\mathcal{O}_X$**')\n\nlisty = notation_asterisk_indices(text)\nstart, end = listy[0]\ntest_eq(text[start:end], '**$\\mathcal{O}_X$**')\ntest_eq(len(listy), 1)\n\nlisty = definition_asterisk_indices(text)\nprint(listy)\ntest_eq(len(listy), 2)\n\n[(2, 12), (25, 44)]\n\n\n&lt;&gt;:11: SyntaxWarning: invalid escape sequence '\\m'\n&lt;&gt;:15: SyntaxWarning: invalid escape sequence '\\m'\n&lt;&gt;:11: SyntaxWarning: invalid escape sequence '\\m'\n&lt;&gt;:15: SyntaxWarning: invalid escape sequence '\\m'\nC:\\Users\\hyunj\\AppData\\Local\\Temp\\ipykernel_9044\\3923368571.py:11: SyntaxWarning: invalid escape sequence '\\m'\n  test_eq(text[start:end], '**$\\mathcal{O}_X$**')\nC:\\Users\\hyunj\\AppData\\Local\\Temp\\ipykernel_9044\\3923368571.py:15: SyntaxWarning: invalid escape sequence '\\m'\n  test_eq(text[start:end], '**$\\mathcal{O}_X$**')\n\n\nThe following example has a definition which starts and ends with dollar sign $ characters:\n\ntext = r'A **$G$-group over a ring $A$** is'\nlisty = notation_asterisk_indices(text)\ntest_eq(len(listy), 0)\n\nlisty = definition_asterisk_indices(text)\ntest(len(listy), 0, operator.ge)\n\nThe following example tests notation_asterisk_indices for LaTeX str with single asterisks in them:\n\n# Tests LaTeX str with asterisks in them:\ntext = (r'''The **direct image of a sheaf $F^{\\prime}$ on $X_{E}^{\\prime}$** '''\n        r'''is defined to be **$\\pi_{*} F^{\\prime}=\\pi_{p} F^{\\prime}$** and the '''\n        r'''**inverse image of a sheaf $F$ on $X_{E}$** is defined to be **$\\pi^{*} F=a\\left(\\pi^{p} F\\right)$**.''')\nlisty = notation_asterisk_indices(text)\ntest_eq(len(listy), 2)\nstart, end = listy[0]\ntest_eq(text[start:end], r'**$\\pi_{*} F^{\\prime}=\\pi_{p} F^{\\prime}$**')\n\nThere are pure LaTeX strings which should be considered definitions, but for the purposes of the code here will be considered notations. For example, Hausdorff spaces in topology are also called \\(T_2\\) spaces:\n\ntext = (r\"A topological space $X$ is called **$T_2$** if for all $x,y \\in X$, \"\n        r\"there exist open neightborhoods $V$ and $W$ around $x$ and $y$ respectively \"\n        r\"such that $V \\cap W = 0$.\")\nlisty = notation_asterisk_indices(text)\ntest_eq(text[listy[0][0]:listy[0][1]], r'**$T_2$**')\n\nUnfortunately, the current implementation of the above methods do not work correctly if there are LaTeX string with double asterisks ** within them.\n\n# TODO: If this is fixed, delete this.\ntext = r'The double dual of $M$ is denoted by **$M^{**}$**.'\nlisty = definition_asterisk_indices(text)\nprint(f\"The `definition_asterisk_indices` function detects the substring {text[listy[0][0]:listy[0][1]]} as a definition. This is incorrect!\")\n\nlisty = notation_asterisk_indices(text)\nprint(f\"The `notation_asterisk_indices` function detects the substring {text[listy[0][0]:listy[0][1]]} as a notation. I guess this is correct.\")\n\nThe `definition_asterisk_indices` function detects the substring **$M^{** as a definition. This is incorrect!\nThe `notation_asterisk_indices` function detects the substring **$M^{**}$** as a notation. I guess this is correct.\n\n\nA workaround is to replace asterisks * with the LaTeX \\ast command:\n\ntext = r'The double dual of $M$ is denoted by **$M^{\\ast\\ast}$**.'\nlisty = definition_asterisk_indices(text)\ntest_eq(len(listy), 0)\n\nlisty = notation_asterisk_indices(text)\ntest_eq(len(listy), 1)\ntest_eq(text[listy[0][0]:listy[0][1]], r'**$M^{\\ast\\ast}$**')\n\n\nsource\n\n\n\ndefs_and_notats_separations\n\n defs_and_notats_separations (text:str)\n\n*Finds the indices in the text where double asterisks occur and categorizes whether each index is for a definition or a notation.\nParameters\n\ntext - str\n\nReturns\n\nlist[tuple[int, bool]]\n\nEach tuple is of the form (start, end, is_notation), where text[start:end] is the double-asterisk surrounded string, including the double asterisks.*\n\n\nIn the following example, the first two double-asterisk-surrounded-strings are definitions, and the third is a notation:\n\ntext = r'A **scheme** is a... the **structure sheaf** of a scheme $X$ is the sheaf **$\\mathcal{O}_X$**.'\nlisty = defs_and_notats_separations(text)\nassert not listy[0][2]\nassert not listy[1][2]\nassert listy[2][2]",
    "crumbs": [
      "helper.definition_and_notation"
    ]
  },
  {
    "objectID": "helper.latex.html",
    "href": "helper.latex.html",
    "title": "helper.latex",
    "section": "",
    "text": "We remark that many of the functions in this module are AI generated or assisted.\nfrom fastcore.test import *",
    "crumbs": [
      "helper.latex"
    ]
  },
  {
    "objectID": "helper.latex.html#validity-of-latex-syntax",
    "href": "helper.latex.html#validity-of-latex-syntax",
    "title": "helper.latex",
    "section": "Validity of latex syntax",
    "text": "Validity of latex syntax\n\nTest latex syntax\nWe require some functions to evaluate whether a latex math mode string is syntactically valid.\n\nassert not _has_invalid_left_right_bracket(r\"\\left( x \\right)\")\nassert not _has_invalid_left_right_bracket(r\"\\left[ x \\right]\")\nassert not _has_invalid_left_right_bracket(r\"\\left\\{ x \\right\\}\")\nassert not _has_invalid_left_right_bracket(r\"\\left&lt; x \\right&gt;\")\nassert not _has_invalid_left_right_bracket(r\"\\left| x \\right|\")\nassert not _has_invalid_left_right_bracket(r\"\\left\\| x \\right\\|\")\nassert not _has_invalid_left_right_bracket(r\"\\left\\| x \\right\\|\")\nassert _has_invalid_left_right_bracket(r\"\\lefta x \\right)\")\nassert _has_invalid_left_right_bracket(r\"\\left( x \\righta\")\nassert _has_invalid_left_right_bracket(r\"\\left x \\right)\")\nassert _has_invalid_left_right_bracket(r\"\\left( x \\right x\")\nassert _has_invalid_left_right_bracket(r\"\\left\\backslash x \\right/\")\nassert not _has_invalid_left_right_bracket(r\"x + y\")\nassert _has_invalid_left_right_bracket(r\"\\left\\\\\")\nassert _has_invalid_left_right_bracket(r\"\\right\\\\\")\n\n\npattern = regex_pattern_detecting_command(('Sur', 0, None, r'\\mathrm{Sur}'))\ntext = r'The number of element of $\\Sur(\\operatorname{Cl} \\mathcal{O}_L, A)$ is ...'\nmatch = pattern.search(text)\nstart, end = match.span()\ntest_eq(text[start:end], r'\\Sur')\n\n\n\n\nextract_commands_from_nodes\n\n extract_commands_from_nodes (commands:list[str],\n                              nodes:list[pylatexenc.latexwalker.LatexNode]\n                              )\n\nThis is a helper function to extract_latex_commands.\n\n\n\nextract_latex_commands\n\n extract_latex_commands (latex_string)\n\n\n# Example usage\nassert extract_latex_commands(r\"\\frac{a}{b}\") == ['frac']\nassert extract_latex_commands(r\"$\\frac{a}{b}$\") == ['frac']\nassert extract_latex_commands(r\"\\sqrt[n]{x}\") == ['sqrt']\nassert extract_latex_commands(r\"\\binom{n}{k}\") == ['binom']\nassert extract_latex_commands(r\"x^2 + y^2\") == []  # No commands, just variables\nassert extract_latex_commands(r\"\\overset{a}{b}\") == ['overset']\n\n# Additional tests\nassert extract_latex_commands(r\"\\sum_{i=1}^{n} i\") == ['sum']\nassert extract_latex_commands(r\"\\int_{0}^{\\infty} e^{-x} dx\") == ['int', 'infty']\nassert extract_latex_commands(r\"\\lim_{x \\to 0} f(x)\") == ['lim', 'to']\nassert extract_latex_commands(r\"\\prod_{i=1}^{n} i\") == ['prod']\nassert extract_latex_commands(r\"\\text{Hello} + \\frac{1}{2}\") == ['text', 'frac']\n\n# Multiple commands in one string\nassert extract_latex_commands(r\"\\frac{a}{b} + \\sqrt{c} + \\binom{n}{k}\") == ['frac', 'sqrt', 'binom']\nassert extract_latex_commands(r\"\\sum_{i=1}^{n} i + \\int_{0}^{\\infty} e^{-x} dx\") == ['sum', 'int', 'infty']\nassert extract_latex_commands(r\"\\lim_{x \\to 0} f(x) = \\frac{1}{x}\") == ['lim', 'to', 'frac']\nassert extract_latex_commands(r\"\\overset{a}{b} + \\underset{c}{d}\") == ['overset', 'underset']\nassert extract_latex_commands(r\"\\text{This is } \\textbf{bold} + \\textit{italic} + \\frac{1}{2}\") == ['text', 'textbf', 'textit', 'frac']\n\n# Complex expressions\ntest_eq(extract_latex_commands(r\"\\frac{\\sum_{i=1}^{n} i}{n} = \\frac{n(n+1)}{2}\"), ['frac', 'sum', 'frac'])\ntest_eq(extract_latex_commands(r\"\\int_{0}^{1} x^2 \\, dx = \\frac{1}{3}\"), ['int', ',', 'frac'])\nassert extract_latex_commands(r\"\\sqrt{\\frac{a}{b}} + \\binom{n}{k}\") == ['sqrt', 'frac', 'binom']\n\n# Incorrect synntax\nassert extract_latex_commands(r\"\\frac{}}\") == ['frac']\nassert extract_latex_commands(r\"\\frac{a}{b}{c}\") == ['frac']  # Extra argument\nassert extract_latex_commands(r\"\\frac{a}{b + \\frac{c}{d}}\") == ['frac', 'frac']  # Nested command\ntest_eq(extract_latex_commands(r\"\\sum_{i=1}^{n} i + \\int_{0}^{\\infty} e^{-x} dx = \\frac{1}{2}\"), ['sum', 'int', 'infty', 'frac'])\n# Comment\nassert extract_latex_commands(r\"%hi\") == []\n# Environment Node\ntest_eq(extract_latex_commands(r\"\\begin{align} \\end{align}\"), ['begin', 'end'])\ntest_eq(extract_latex_commands(r\"\\begin{align}\"), ['begin'])\n# test_eq(extract_latex_commands(r\"\\ begin{align} \\end{align}\"), [' '])\n\ntest_eq(extract_latex_commands(r'\\text\\in'), ['text', 'in'])\n\n\n\n\ndetect_incorrect_latex_commands\n\n detect_incorrect_latex_commands (latex_string:str)\n\n*Return True if there is at least one syntactically incorrect use of a latex command detected in latex_string.\nThis is a helper function to math_mode_string_is_syntactically_valid.*\n\n\n\ndetect_unbalanced_environments\n\n detect_unbalanced_environments (latex_string:str)\n\n\n# Example usage\nlatex_code = r\"\"\"\n\\begin{document}\nThis is a sample document.\n\\begin{itemize}\n    \\item First item\n    \\begin{enumerate}\n        \\item First sub-item\n    \\end{enumerate}\n    \\item Second item\n\\end{itemize}\n\\end{document}\n\\begin{wrongenv}  % This environment is unmatched\n\"\"\"\n\n# Detect unbalanced environments\nunbalanced = detect_unbalanced_environments(latex_code)\n\n# Print the results\n# if unbalanced:\n#     print(\"Unbalanced environments detected:\")\n#     for error in unbalanced:\n#         print(error)\n# else:\n#     print(\"All environments are balanced.\")\n\nassert unbalanced\n\n\nlatex_code = r\"\"\"\n\\begin{document}\nThis is a sample document.\n\\begin{itemize}\n    \\item First item\n    \\begin{enumerate}\n        \\item First sub-item\n    \\end{enumerate}\n    \\item Second item\n\\end{itemize}\n\\end{document}\n\"\"\"\n# Detect unbalanced environments\nunbalanced = detect_unbalanced_environments(latex_code)\nassert not unbalanced\n\n\n\n\nmath_mode_string_is_syntactically_valid\n\n math_mode_string_is_syntactically_valid (text:str)\n\n*Return True if text is determined to be syntactically valid as a latex str.\nThere may be TeX syntax rules beyond the scope of this function.\nSome caveats:\ntext is allowed to have dollar signs $ and is also allowed to not have dollar signs. Even if text does not have dollar signs, this function may return True. Even if text has dollar signs, this function may return False if the entire string is not a singular math mode string or if the dollar signs are not used in a math-mode-valid way.*\n\nassert not math_mode_string_is_syntactically_valid(r'$$n=p_1^{e_1} p_2^{e_2} \\cdots p_k^$$')\nassert not math_mode_string_is_syntactically_valid(r'$x^2 + y^2')\nassert not math_mode_string_is_syntactically_valid(r'$$x^2 + y^2$')\nassert not math_mode_string_is_syntactically_valid(r'$$x^2 + y^2$ $')\nassert math_mode_string_is_syntactically_valid(r'hi')\nassert math_mode_string_is_syntactically_valid(r'$hi$')\nassert not math_mode_string_is_syntactically_valid(r'$hi$$')\nassert math_mode_string_is_syntactically_valid(r'$\\\\dim ^ a$')\nassert not math_mode_string_is_syntactically_valid(r'{ hi')\nassert math_mode_string_is_syntactically_valid(r'\\{ hi')\nassert math_mode_string_is_syntactically_valid(r'\\ [')\nassert math_mode_string_is_syntactically_valid(r'\\left( \\right.')\nassert not math_mode_string_is_syntactically_valid(r'\\left \\right.')\nassert math_mode_string_is_syntactically_valid(r'$$\\left|\\sum_{i=0} \\right|$$')\nassert math_mode_string_is_syntactically_valid(r'$\\\\\\$$')\nassert not math_mode_string_is_syntactically_valid(r'\\begin{enumerate}')\nassert math_mode_string_is_syntactically_valid(r'\\begin{enumerate} asdf \\end{enumerate}')\nassert not math_mode_string_is_syntactically_valid(r'$$R=\\sum_P\\in X\\operatorname length\\left(\\Omega__X / Y\\right)_p\\cdot P$$')\n# TODO there is something to be considered here; the below\n# example would be a syntax error, and yet the functions  implemented\n# above don't really detect as such.\n# assert not detect_incorrect_latex_commands(r'\\sideset{_1^2}{_3^4}')\n\nmath_mode_string_is_syntactically_valid(r'\\text\\in')\n\nFalse\n\n\nThe math_mode_string_is_syntactically_valid experimentally assesses whether a given math mode LaTeX string is syntactically valid. In principal, this should mean that a LaTeX syntax error caused by the string should be detected by the function.\nTODO: consider the following to :\nUnescaped % sign (starts a comment): $x = 50% of y$\nUsing ! (negative space) at the beginning of math mode: $\\!x + y$\nThe following lists some example outputs of the math_mode_string_is_syntactically_valid function along with explanations.\nUnmatched curly braces are a common syntactical error:\n\nassert not math_mode_string_is_syntactically_valid(r'\\sqrt{x}}')\n\nHowever, using \\{ or \\} does not count towards curly bracket matching:\n\nassert math_mode_string_is_syntactically_valid(r'\\{hi')\n\nOn the other hand, a backslash \\ followed by spaces  and then followed by a curly bracket is in itself an invalid syntax.\n\nassert not math_mode_string_is_syntactically_valid(r'\\ {hi')\n\nmath_mode_string_is_syntactically_valid will consider the validity of a string whether or not the string has math mode delimiters.\n\nassert math_mode_string_is_syntactically_valid(r'\\operatorname{Gal}')\nassert math_mode_string_is_syntactically_valid(r'$\\operatorname{Gal}$')\n\nHowever, math_mode_string_is_syntactically_valid returns False if the string has dollar sign delimiters and more than one math mode string is detected in the string (use latex_indices to separate out math mode strings.),\n\n# More than one math mode string is present\nassert not math_mode_string_is_syntactically_valid('$hi$ $bye$')\n# the math mode delimiter `$` is unbalanced.\nassert not math_mode_string_is_syntactically_valid(r'$x^2 + y^2')\n# the math mode delimiters `$$` and `$` are unbalanced.\nassert not math_mode_string_is_syntactically_valid(r'$$x^2 + y^2$')",
    "crumbs": [
      "helper.latex"
    ]
  },
  {
    "objectID": "helper.latex.html#tweak-a-latex-string",
    "href": "helper.latex.html#tweak-a-latex-string",
    "title": "helper.latex",
    "section": "Tweak a latex string",
    "text": "Tweak a latex string\nSometimes, when autogenerating a latex string through an ML model, some minor formatting eyesores occur, such as a curly bracket { or an underscore _ followed by an unncessary space. We provide some functions to fix such formatting.\n\n\nreduce_unnecessary_spaces\n\n reduce_unnecessary_spaces (text:str)\n\nReturn a string modifying text by removing spaces which are unnecessary for the purposes of considering the string as a LaTeX string.\n\n# It might not be necessary or desirable to eliminate the space before the backslash `\\``\ntest_eq(reduce_unnecessary_spaces(r'something something \\  operatorname'), r'something something \\operatorname')\ntest_eq(reduce_unnecessary_spaces(r'\\operatorname{Res}  ^ G_ H (R)'), r'\\operatorname{Res}^G_H(R)')\ntest_eq(reduce_unnecessary_spaces(r'\\operatorname{Res}^{ G}_{ H } (R)'), r'\\operatorname{Res}^{G}_{H}(R)')\ntest_eq(reduce_unnecessary_spaces(r'M_{ f}'), r'M_{f}')\ntest_eq(reduce_unnecessary_spaces(r'h_{ p}'), r'h_{p}')\ntest_eq(reduce_unnecessary_spaces(r'\\zeta (s)'), r'\\zeta(s)')\ntest_eq(reduce_unnecessary_spaces(r'\\mathcal{ H} _{ v}'), r'\\mathcal{H}_{v}')\n\n\nMake fixes to summary\n\n\n\n\nfix_autogen_formatting\n\n fix_autogen_formatting (text:str)\n\nFix some latex formatting issues in an autogenerated text\nCurrently, the model is inclined to decode and format its summarizations in such a way that creates formatting issues either for LaTeX or Obsidian.md. For example, the model would output a str containing\n\n\\ &lt;command_name&gt; instead of \\&lt;command_name&gt;\n{ when { is preferable\n$ &lt;latex_string&gt; $ when $&lt;latex_string&gt;$ is needed for Obsidian.md.\n\nThe fix_summary_formatting function attempts to get around some of these issues.\n\ntext = r'\\ to'\nsample_output = fix_autogen_formatting(text)\nassert r'\\to' in sample_output\n\ntext = r'$d\\ in\\ mathbb{ Z}_{\\ geq 0} $'\nsample_output = fix_autogen_formatting(text)\nassert r'\\in' in sample_output\nassert r'\\mathbb{Z}' in sample_output\nassert r'\\geq 0' in sample_output\n\n\ntext = r'There are some extra spaces in this math mode string: $  5 + 7 = 12 $.'\nsample_output = fix_autogen_formatting(text)\nprint(sample_output)\nassert r'$5' in sample_output\nassert r'12$' in sample_output\n\nThere are some extra spaces in this math mode string: $5 + 7 = 12$ .\n\n\n\ntext=  r'the group of $G$-coinvariants of $A$. It is defined as $$A_{G} :=A / I_\\G} A$$'\nsample_output = fix_autogen_formatting(text)\nprint(sample_output)\n\nthe group of $G$ -coinvariants of $A$ . It is defined as \n\n$$A_{G} :=A / I_\\G} A$$",
    "crumbs": [
      "helper.latex"
    ]
  },
  {
    "objectID": "helper.latex.html#correct-syntax-errors-in-autogenerated-math-mode-strings",
    "href": "helper.latex.html#correct-syntax-errors-in-autogenerated-math-mode-strings",
    "title": "helper.latex",
    "section": "Correct syntax errors in autogenerated math mode strings",
    "text": "Correct syntax errors in autogenerated math mode strings\n\n\ncorrect_latex_syntax_error\n\n correct_latex_syntax_error (summary:str,\n                             replacement_candidates:list[str], syntax_vali\n                             dation:Callable[[str],bool]=&lt;function\n                             math_mode_string_is_syntactically_valid&gt;)\n\n*Attempt to replace within summary a modified version in which the syntactically incorrect latex math mode strings are replaced with the most closely resembling element of replacement_candidates.\nwith a modified version in which the latex math mode strings within summary that are syntactically incorrect\nTODO: consider the possibility that not all math mode str delimiters are formatted correctly.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nsummary\nstr\n\nThe autogenerated summary\n\n\nreplacement_candidates\nlist\n\nA list of candidates to replace. This is expected to be an output of _list_of_candidates_from_math_mode_strings\n\n\nsyntax_validation\nCallable\nmath_mode_string_is_syntactically_valid\nA test to tell whether a math mode string is syntactically valid.\n\n\nReturns\nstr\n\n\n\n\n\n\nsample_summary = r'the group of $G$-coinvariants of $A$. It is defined as $$A_{G} :=A / I_\\G} A$$'\nreplacement_candidates = [\n    'A',\n    'A_',\n    'A_{G}',\n    'A_{G}:=A',\n    'A_{G}:=A',\n    'A_{G}:=A /',\n    'A_{G}:=A / I_{G}',\n    'A_{G}:=A / I_{G} A',\n    'H_{0}(G, A)',\n    'H_{0}(G, A) \\\\simeq',\n    'H_{0}(G, A) \\\\simeq A',\n    'H_{0}(G, A) \\\\simeq A_',\n    'H_{0}(G, A) \\\\simeq A_{G}',\n]\ntest_eq(correct_latex_syntax_error(sample_summary, replacement_candidates), r'the group of $G$-coinvariants of $A$. It is defined as $$A_{G}:=A / I_{G} A$$')\n# replacement_candidates",
    "crumbs": [
      "helper.latex"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.notation.in_standard_information_note.html",
    "href": "markdown.obsidian.personal.notation.in_standard_information_note.html",
    "title": "markdown.obsidian.personal.notation.in_standard_information_note",
    "section": "",
    "text": "from unittest import mock\nimport tempfile\nimport shutil\nfrom fastcore.test import *\nfrom trouver.helper.tests import _test_directory",
    "crumbs": [
      "markdown.obsidian.personal.notation.in_standard_information_note"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.notation.in_standard_information_note.html#find-notations-introduced-in-note",
    "href": "markdown.obsidian.personal.notation.in_standard_information_note.html#find-notations-introduced-in-note",
    "title": "markdown.obsidian.personal.notation.in_standard_information_note",
    "section": "Find notations introduced in note",
    "text": "Find notations introduced in note\n\nBy double asterisks **\nWARNING: The use of double asterisks ** to signify definitions and notations is deprecated.\nIn the legacy method, string surrounded by double asterisks ** were recognized as marking notations\n\nsource\n\n\nnotat_str_from_doub_asts_in_std_info_note\n\n notat_str_from_doub_asts_in_std_info_note\n                                            (info_note:trouver.markdown.ob\n                                            sidian.vault.VaultNote)\n\n*Return the LaTeX str’s with notations in a standard information note.\nFor this function, A LaTeX str is deemed to be a notation if it is surrounded by double asterisks ***\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ninfo_note\nVaultNote\n\n\n\nReturns\nlist\nEach str is a LaTeX str, beginning and trailing dollar signs $ (single or double) included.\n\n\n\nWe can obtain the notation str in an information note:\n\nvault = _test_directory() / 'test_vault_7'\n# A note with just one notation:\nvn = VaultNote(vault, name='galois_group')\nsample_output_1 = notat_str_from_doub_asts_in_std_info_note(vn)\nassert len(sample_output_1) == 1\nassert sample_output_1[0].startswith('$')\nassert sample_output_1[0].endswith('$')\nassert not sample_output_1[0].startswith('$$')\nassert not sample_output_1[0].endswith('$$')\nprint(sample_output_1)\n\n# A note with a notation with double asterisks:\nvn = VaultNote(vault, name='spectrum_of_a_ring')\nsample_output_2 = notat_str_from_doub_asts_in_std_info_note(vn)\nassert len(sample_output_2) == 2\nassert sample_output_2[1].startswith('$$')\nassert sample_output_2[1].endswith('$$')\nprint(sample_output_2)\n\n# A note with no notations:\nassert not notat_str_from_doub_asts_in_std_info_note(VaultNote(vault, name='no_notations_note_about_integral_domains'))\n\n['$\\\\operatorname{Gal}(L/K)$']\n['$\\\\operatorname{Spec} A$', '$$D(f) = \\\\{\\\\mathfrak{p} \\\\in \\\\operatorname{Spec} A: f \\\\not\\\\in \\\\mathfrak{p} \\\\}.$$']\n\n\n\n# hide\n# Test notation str with asterisks.\nvault = _test_directory() / 'test_vault_7'\nvn = VaultNote(vault, name='direct_and_inverse_images_of_sheaves')\nsample_output = notat_str_from_doub_asts_in_std_info_note(vn)\n# sample_output\nassert len(sample_output) == 2\n\n\nBy HTML tags\nNow, HTML tags are used to mark notations\n\nsource\n\n\n\nnotat_str_from_html_tags\n\n notat_str_from_html_tags\n                           (info_note:trouver.markdown.obsidian.vault.Vaul\n                           tNote)\n\n*Return the LaTeX str’s with notations in a standard information note.\nFor this function, HTML tags with the notation attr are deemed to contain (newly introduced) notations. The notation attribute can have multiple strings separated by double semicolons ;; and not surrounded by dollar signs $.\nThe following are some examples of HTML tags with the format described above:\n\n\\(H^i\\)\n\\(h^i := \\dim_k H^i\\)\n$\\(IJ = \\langle ab: a \\in I, b \\in J \\rangle, \\quad I+J = \\{a+b: a \\in I, b \\in J \\}\\)\n\nRaises - UserWarning - If an HTML tag with a notation attr does not surround a pure math mode string.*\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ninfo_note\nVaultNote\n\n\n\nReturns\nlist\nEach str is a LaTeX str, the first of which is the text of and surrounded by the HTML tag and the second of which is a string (without surrounding dollar signs) specifying the actual notation introduced in the first text.\n\n\n\n\ntext = 'Let $K$ be a field. An &lt;b definition=\"Abelian variety over a field\"&gt;Abelian variety over $K$&lt;/b&gt; is a variety that'\nwith mock.patch('__main__.VaultNote.text') as mock_vaultnote_text:\n    mock_vaultnote_text.return_value = text\n    listy = notat_str_from_html_tags(\n        VaultNote('', ''))\n    assert not listy\n\n\ntext = 'Given an ordering, we write &lt;span notation=\"\"&gt;$&lt;$&lt;/span&gt; for the less-than symbol'\nwith mock.patch('__main__.VaultNote.text') as mock_vaultnote_text:\n    mock_vaultnote_text.return_value = text\n    listy = notat_str_from_html_tags(\n        VaultNote('', ''))\n    test_eq(listy, [('$&lt;$', '')])",
    "crumbs": [
      "markdown.obsidian.personal.notation.in_standard_information_note"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.notation.in_standard_information_note.html#notation-notes-listed-in-see-also-section",
    "href": "markdown.obsidian.personal.notation.in_standard_information_note.html#notation-notes-listed-in-see-also-section",
    "title": "markdown.obsidian.personal.notation.in_standard_information_note",
    "section": "Notation notes listed in see also section",
    "text": "Notation notes listed in see also section\n\nsource\n\nnotation_notes_linked_in_see_also_section\n\n notation_notes_linked_in_see_also_section\n                                            (info_note:trouver.markdown.ob\n                                            sidian.vault.VaultNote,\n                                            vault:os.PathLike,\n                                            as_vault_notes:bool=True)\n\n*Return a list of notation notes listed in the See Also section of the standard information note.\nIn the current implementation of this function, only “notation notes” that actually exist are included in the returned list.*\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ninfo_note\nVaultNote\n\n\n\n\nvault\nPathLike\n\nPath to the vault directory.\n\n\nas_vault_notes\nbool\nTrue\nIf True, returns each notation note as a VaultNote object. Otherwise, returns the name of each notation note. Defaults to True.\n\n\nReturns\nUnion\n\nEach entry corresponds to a notation note in the vault.\n\n\n\nThe notation_notes_linked_in_see_also_section method detects the Notation notes listed in bulleted links in the See Also section of a standard information note.\n\nvault = _test_directory() / 'test_vault_7'\nvn = VaultNote(vault, name='twist_of_a_graded_module')\nsample_output = notation_notes_linked_in_see_also_section(vn, vault)\nassert len(sample_output) == 1\nassert isinstance(sample_output[0], VaultNote)\nprint(sample_output[0].name)\nassert sample_output[0].exists()\n\nfoag_notation_M_n_bullet\n\n\nSetting as_vault_notes=False returns the names of the notation notes.\n\nvault = _test_directory() / 'test_vault_7'\nvn = VaultNote(vault, name='twist_of_a_graded_module')\nsample_output = notation_notes_linked_in_see_also_section(vn, vault, as_vault_notes=False)\nassert len(sample_output) == 1\nassert isinstance(sample_output[0], str)\nprint(sample_output[0])\n\nfoag_notation_M_n_bullet\n\n\nIf a “notation note” does not exist, then it is not included in the returned list.\nNote that notation_notes_linked_in_see_also_section uses bulleted_links_of_type_in_section, which is turn uses note_is_of_type to get a list of linked notes of the type NOTATION_NOTE of the PersonalNoteTypeEnum class. In turn, a note file must exist for the note to be considered of any particular type under the current implementation of note_is_of_type.\n\nvault = _test_directory() / 'test_vault_7'\nvn = VaultNote(vault, name='note_with_links_to_non_existent_notation_notes')\nsample_output = notation_notes_linked_in_see_also_section(vn, vault, as_vault_notes=True)\ntest_eq(sample_output, [])\nsample_output = notation_notes_linked_in_see_also_section(vn, vault, as_vault_notes=False)\ntest_eq(sample_output, [])",
    "crumbs": [
      "markdown.obsidian.personal.notation.in_standard_information_note"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.notation.in_standard_information_note.html#find-all-notation-notes-in-a-vault-subdirectory",
    "href": "markdown.obsidian.personal.notation.in_standard_information_note.html#find-all-notation-notes-in-a-vault-subdirectory",
    "title": "markdown.obsidian.personal.notation.in_standard_information_note",
    "section": "Find all notation notes in a vault subdirectory",
    "text": "Find all notation notes in a vault subdirectory\n\nsource\n\nnotations_and_main_notes\n\n notations_and_main_notes (vault:os.PathLike,\n                           subdirectory:Optional[os.PathLike]=None, note:O\n                           ptional[trouver.markdown.obsidian.vault.VaultNo\n                           te]=None)\n\n*Return a dict with all of notation notes in a specified subdirectory of a vault and the names of the main notes of these notation notes.\nReturns - dict\nRaises\n\nValueError\n\nIf subdirectory and note are both None.*\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nvault\nPathLike\n\nPath to the vault directory.\n\n\nsubdirectory\nOptional\nNone\nPath to the subdirectory, relative to vault, to find the notation notes. Searches for all notation notes here and in subdirectories of this subdirectory. If None, then the note parameter is used to determined the subdirectory. Ifsubdirectoryis the empty str, then all notation notes in the vault are searched. Defaults toNone. | | note | Optional | None | A note in the vault. The directory that this note is in determines thesubdirectoryparameter if the argument passed tosubdirectoryis the blank str. This note can usually be an index note, e.g.’_index_silverman’. Defaults toNone, in which casesubdirectorymust be specified. | | **Returns** | **dict** |  | **A key is the unique name of a notation note in the vault and its corresponding value is the name of the main note of the notation note. Each main note may not actually exist, but each notation note definitely exists. If the notation note has no main note (i.e. has no links to other notes), then the value isNone`.**\n\n\n\nThe notations_and_main_notes function returns all the notation notes in a subdirectory of a vault\n\nvault = _test_directory() / 'test_vault_7'\nsample_output = notations_and_main_notes(vault, subdirectory='')\nprint(sample_output)\nassert 'foag_notation_M_n_bullet' in sample_output\nassert 'some_reference_name_notation_O_X_this_file_has_no_links' in sample_output\nassert sample_output['some_reference_name_notation_O_X_this_file_has_no_links'] is None\nassert 'poonen_curves_notation_Z_X_T' in sample_output\n\n{'foag_notation_M_n_bullet': 'twist_of_a_graded_module', 'notation_note_with_main_note_link_but_main_note_does_not_exist': 'nonexistent_note', 'some_reference_name_notation_k_t_formal_power_series_ring': 'some_note', 'some_reference_name_notation_O_X_this_file_has_no_links': None, 'some_reference_name_notation_Pic_C': 'divisor_class_group_of_a_curve', 'some_reference_name_notation_Spec_A': 'spectrum_of_a_ring', 'foag_notation_O_n': 'foag_15.2.1', 'foag_notation_O_text_Proj__S__n': 'foag_15.2.1', 'poonen_curves_notation_zeta_X_s_zeta_function_of_variety': 'poonen_curves_3.4.1 DEFINITION', 'poonen_curves_notation_Z_X_T': 'poonen_curves_3.4.1 DEFINITION', 'some_reference_name_notation_B_R': 'note_with_some_excessive_notation_notes', 'some_reference_name_notation_B_R_1': 'note_with_some_excessive_notation_notes', 'some_reference_name_notation_Jac_C': 'note_with_some_excessive_notation_notes', 'test_notation_note_for_latex_in_original_metadata_1': 'test_note_for_latex_in_original_metadata', 'test_notation_note_for_latex_in_original_metadata_2': 'test_note_for_latex_in_original_metadata', 'foag_notation__otimes_A_quad_obj_Mod_A_times_obj_Mod_A_longarrow_obj_Mod_A_': 'foag_1.3.5', 'notation_note_with_auto_notation_summary_tag': 'main_note_of_notation_note_with_auto_notation_summary_tag'}\n\n\nHere is an example with a subdirectory specified:\n\nvault = _test_directory() / 'test_vault_7'\nsample_output = notations_and_main_notes(vault, subdirectory='some_other_folder')\nprint(sample_output)\nassert 'foag_notation_M_n_bullet' not in sample_output\nassert 'some_reference_name_notation_O_X_this_file_has_no_links' not in sample_output\nassert 'poonen_curves_notation_Z_X_T' in sample_output\n\n{'foag_notation_O_n': 'foag_15.2.1', 'foag_notation_O_text_Proj__S__n': 'foag_15.2.1', 'poonen_curves_notation_zeta_X_s_zeta_function_of_variety': 'poonen_curves_3.4.1 DEFINITION', 'poonen_curves_notation_Z_X_T': 'poonen_curves_3.4.1 DEFINITION', 'some_reference_name_notation_B_R': 'note_with_some_excessive_notation_notes', 'some_reference_name_notation_B_R_1': 'note_with_some_excessive_notation_notes', 'some_reference_name_notation_Jac_C': 'note_with_some_excessive_notation_notes'}\n\n\nAlternatively, we can specify a subdirectory by a VaultNote object; the directory that the VaultNote object is the subdirectory:\n\nvault = _test_directory() / 'test_vault_7'\nvn = VaultNote(vault, name='galois_group')\nsample_output = notations_and_main_notes(vault, subdirectory=None, note=vn)\nprint(sample_output)\nassert 'foag_notation_M_n_bullet' in sample_output\nassert 'some_reference_name_notation_O_X_this_file_has_no_links' in sample_output\nassert sample_output['some_reference_name_notation_O_X_this_file_has_no_links'] is None\nassert 'poonen_curves_notation_Z_X_T' not in sample_output\n\n{'foag_notation_M_n_bullet': 'twist_of_a_graded_module', 'notation_note_with_main_note_link_but_main_note_does_not_exist': 'nonexistent_note', 'some_reference_name_notation_k_t_formal_power_series_ring': 'some_note', 'some_reference_name_notation_O_X_this_file_has_no_links': None, 'some_reference_name_notation_Pic_C': 'divisor_class_group_of_a_curve', 'some_reference_name_notation_Spec_A': 'spectrum_of_a_ring'}",
    "crumbs": [
      "markdown.obsidian.personal.notation.in_standard_information_note"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.notation.in_standard_information_note.html#check-if-there-is-a-notation-link-in-the-see-also-section-of-a-standard-information-note.",
    "href": "markdown.obsidian.personal.notation.in_standard_information_note.html#check-if-there-is-a-notation-link-in-the-see-also-section-of-a-standard-information-note.",
    "title": "markdown.obsidian.personal.notation.in_standard_information_note",
    "section": "Check if there is a notation link in the See Also section of a standard information note.",
    "text": "Check if there is a notation link in the See Also section of a standard information note.\n\nsource\n\nnotation_note_is_linked_in_see_also_section\n\n notation_note_is_linked_in_see_also_section\n                                              (notation_note:trouver.markd\n                                              own.obsidian.vault.VaultNote\n                                              , info_note:Optional[trouver\n                                              .markdown.obsidian.vault.Vau\n                                              ltNote]=None)\n\nReturn True if a notation note is linked in the See Also section of a standard information note.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nnotation_note\nVaultNote\n\n\n\n\ninfo_note\nOptional\nNone\nThe note in which to find the link to notation_note. Defaults to None, in which case the main note is determined to be the first linked note of notation_note.\n\n\nReturns\nbool\n\n\n\n\n\nnotation_note_is_linked_in_see_also_section Returns True if a notation note is linked in the See Also section of an information note:\n\nvault = _test_directory() / 'test_vault_7'\nnotation_note = VaultNote(vault, name='some_reference_name_notation_Pic_C')\ninfo_note = VaultNote(vault, name='divisor_class_group_of_a_curve')\nassert not notation_note_is_linked_in_see_also_section(notation_note, info_note)\n\nnotation_note = VaultNote(vault, name='foag_notation_M_n_bullet')\ninfo_note = VaultNote(vault, name='twist_of_a_graded_module')\nassert notation_note_is_linked_in_see_also_section(notation_note, info_note)\n\nIf info_note is not specified or if info_note=None, then the info note in question is the first note which the notation note links to, see the main_of_notation function:\n\nvault = _test_directory() / 'test_vault_7'\nnotation_note = VaultNote(vault, name='some_reference_name_notation_Pic_C')\nassert not notation_note_is_linked_in_see_also_section(notation_note)\n\nnotation_note = VaultNote(vault, name='foag_notation_M_n_bullet')\nassert notation_note_is_linked_in_see_also_section(notation_note)",
    "crumbs": [
      "markdown.obsidian.personal.notation.in_standard_information_note"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.notation.in_standard_information_note.html#add-notation-links-to-the-see-also-section",
    "href": "markdown.obsidian.personal.notation.in_standard_information_note.html#add-notation-links-to-the-see-also-section",
    "title": "markdown.obsidian.personal.notation.in_standard_information_note",
    "section": "Add notation links to the See Also section",
    "text": "Add notation links to the See Also section\n\nAdd links to individual notation notes\n\nsource\n\n\nadd_notation_note_to_see_also\n\n add_notation_note_to_see_also\n                                (notation_note:trouver.markdown.obsidian.v\n                                ault.VaultNote, info_note:Optional[trouver\n                                .markdown.obsidian.vault.VaultNote]=None,\n                                do_not_repeat:bool=True)\n\n*Add a link to a notation note in the See Also section of a standard information note.\nRaises\n\nNoteDoesNotExistError\n\nIf the information note to link to does not exist.*\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nnotation_note\nVaultNote\n\n\n\n\ninfo_note\nOptional\nNone\nThe note in which to link notation_note. Defaults to None, in which case the main note is determined to be the first linked note of notation_note.\n\n\ndo_not_repeat\nbool\nTrue\nIf True, do not add a link to notation_note in if there is already a such a link.\n\n\nReturns\nNone\n\n\n\n\n\nThe add_notation_note_to_see_also method adds a link to the specified notation note to the specified standard information note.\n\nwith tempfile.TemporaryDirectory(prefix='tmp_dir_', dir=os.getcwd()) as tmp_dir:\n    tmp_dir = Path(tmp_dir)\n    temp_vault = tmp_dir / 'test_vault_7'\n    shutil.copytree(_test_directory() / 'test_vault_7', temp_vault)\n\n    notation_note = VaultNote(temp_vault, name='some_reference_name_notation_Pic_C')\n    info_note = VaultNote(temp_vault, name='divisor_class_group_of_a_curve')\n    assert not notation_note_is_linked_in_see_also_section(notation_note, info_note)    \n    print(\"The note's text before adding the link:\")\n    print(info_note.text(), '\\n\\n')\n\n    add_notation_note_to_see_also(notation_note, info_note)\n    assert notation_note_is_linked_in_see_also_section(notation_note, info_note)\n    print(\"The note's text after adding the link:\")\n    print(info_note.text())\n\nThe note's text before adding the link:\n---\ncssclass: clean-embeds\naliases: []\ntags: [_meta/literature_note, _meta/definition, _meta/notation]\n---\n# Divisor class group of a curve[^1]\nLet $C/k$ be a curve.\n\nThe **divisor class group** of $C$, denoted **$\\operatorname{Pic} C$**, is defined as $\\operatorname{Div} C / \\operatorname{Princ} C$.  \n\n# See Also\n\n# Meta\n## References\n\n## Citations and Footnotes\n[^1]: Citation\n \n\n\nThe note's text after adding the link:\n---\ncssclass: clean-embeds\naliases: []\ntags: [_meta/literature_note, _meta/definition, _meta/notation]\n---\n# Divisor class group of a curve[^1]\nLet $C/k$ be a curve.\n\nThe **divisor class group** of $C$, denoted **$\\operatorname{Pic} C$**, is defined as $\\operatorname{Div} C / \\operatorname{Princ} C$.  \n\n# See Also\n- [[some_reference_name_notation_Pic_C]]\n\n# Meta\n## References\n\n## Citations and Footnotes\n[^1]: Citation\n\n\n\nIf info_note is not specified or is None, then the information note to add the link is determined to be the first note that notation_note links to:\n\nwith tempfile.TemporaryDirectory(prefix='tmp_dir_', dir=os.getcwd()) as tmp_dir:\n    tmp_dir = Path(tmp_dir)\n    temp_vault = tmp_dir / 'test_vault_7'\n    shutil.copytree(_test_directory() / 'test_vault_7', temp_vault)\n\n    notation_note = VaultNote(temp_vault, name='some_reference_name_notation_Pic_C')\n    assert not notation_note_is_linked_in_see_also_section(notation_note)\n    add_notation_note_to_see_also(notation_note)\n    assert notation_note_is_linked_in_see_also_section(notation_note)\n\nIf the information note to add the link does not exist, then a NoteDoesNotExistError is raised:\nIf do_not_repeat is not specified or is True, then the link to the notation note is added only if such a link is not already present:\n\nwith tempfile.TemporaryDirectory(prefix='tmp_dir_', dir=os.getcwd()) as tmp_dir:\n    tmp_dir = Path(tmp_dir)\n    temp_vault = tmp_dir / 'test_vault_7'\n    shutil.copytree(_test_directory() / 'test_vault_7', temp_vault)\n\n    notation_note = VaultNote(temp_vault, name='foag_notation_M_n_bullet')\n    info_note = VaultNote(temp_vault, name='twist_of_a_graded_module')\n    assert notation_note_is_linked_in_see_also_section(notation_note, info_note)\n    original_text = info_note.text()\n    add_notation_note_to_see_also(notation_note, do_not_repeat=True)\n    new_text = info_note.text()\n    assert original_text == new_text\n    assert notation_note_is_linked_in_see_also_section(notation_note, info_note)\n\n    # notation_note = VaultNote(temp_vault, name='some_reference_name_notation_Pic_C')\n    # add_notation_note_to_see_also(notation_note)\n    # assert notation_note_is_linked_in_see_also_section(notation_note)\n\nOtherwise, the link to the notation note is added even if such a link is already present:\n\nwith tempfile.TemporaryDirectory(prefix='tmp_dir_', dir=os.getcwd()) as tmp_dir:\n    tmp_dir = Path(tmp_dir)\n    temp_vault = tmp_dir / 'test_vault_7'\n    shutil.copytree(_test_directory() / 'test_vault_7', temp_vault)\n\n    notation_note = VaultNote(temp_vault, name='foag_notation_M_n_bullet')\n    info_note = VaultNote(temp_vault, name='twist_of_a_graded_module')\n    original_text = info_note.text()\n    add_notation_note_to_see_also(notation_note, do_not_repeat=False)\n    new_text = info_note.text()\n    assert original_text != new_text\n    assert notation_note_is_linked_in_see_also_section(notation_note, info_note)\n    print(new_text)\n\n---\ncssclass: clean-embeds\naliases: []\ntags: [_meta/literature_note]\n---\n# Twist of graded module[^1]\n\nSuppose $M_\\bullet$ is a graded $S_\\bullet$-module. Define the graded module **$M(n)_\\bullet$** by $M(n)_{m}:=M_{n+m}$. Thus the quasicoherent sheaf $M(n)_\\bullet$ satisfies\n\n$$ \\Gamma\\left(D(f), \\widetilde{M(n)}_{\\bullet}\\right)=\\left(\\left(M_{\\bullet}\\right)_{f}\\right)_{n} $$\n\nwhere here the subscript means we take the nth graded piece.\n\n# See Also\n- [[foag_notation_M_n_bullet]]\n- [[foag_notation_M_n_bullet]]\n# Meta\n## References\n![[_reference_foag]]\n\n## Citations and Footnotes\n[^1]: Vakil, Invertible 15.2, Page 412\n\n\n\nIf a link to the notation note is not already present, then add_notation_note_to_see_also adds such a link to the info note whether or not do_not_repeat is True:\n\nwith tempfile.TemporaryDirectory(prefix='tmp_dir_', dir=os.getcwd()) as tmp_dir:\n    tmp_dir = Path(tmp_dir)\n    temp_vault = tmp_dir / 'test_vault_7'\n    shutil.copytree(_test_directory() / 'test_vault_7', temp_vault)\n\n    notation_note = VaultNote(temp_vault, name='some_reference_name_notation_Pic_C')\n    info_note = VaultNote(temp_vault, name='divisor_class_group_of_a_curve')\n    assert not notation_note_is_linked_in_see_also_section(notation_note, info_note)    \n\n    add_notation_note_to_see_also(notation_note, info_note, do_not_repeat=False)\n    assert notation_note_is_linked_in_see_also_section(notation_note, info_note)\n\n\nAdd links to notation notes for all notation notes in a specified subdirectory.\n\nsource\n\n\n\nadd_missing_notation_links_to_information_notes\n\n add_missing_notation_links_to_information_notes (vault:os.PathLike,\n                                                  subdirectory:Optional[os\n                                                  .PathLike]=None, note:Op\n                                                  tional[trouver.markdown.\n                                                  obsidian.vault.VaultNote\n                                                  ]=None)\n\n*For each notation note in a specified subdirectory, Add links to notation notes in their main information notes if the notation links are not already present.\nRaises\n\nValueError\n\nIf subdirectory and note are both None.*\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nvault\nPathLike\n\nPath to the vault directory.\n\n\nsubdirectory\nOptional\nNone\nPath to the subdirectory, relative to vault, to find the notation notes and their main notes. Searches for all notation notes here and in subdirectories of this subdirectory. If None, then the note parameter is used to determine subdirectory. Defaults to None.\n\n\nnote\nOptional\nNone\nA note in the vault. The directory that this note is in determines the subdirectory parameter if it is None. Defaults to None, in which case subdirectory must be specified.\n\n\nReturns\nNone\n\n\n\n\n\nThe add_missing_notation_links_to_information_notes method adds links to notation notes of a specified directory to their main notes if these links are not already present. Note that nonexisting information notes which are the “main” notes of notation notes are ignored.\n\nwith tempfile.TemporaryDirectory(prefix='tmp_dir_', dir=os.getcwd()) as tmp_dir:\n    tmp_dir = Path(tmp_dir)\n    temp_vault = tmp_dir / 'test_vault_7'\n    shutil.copytree(_test_directory() / 'test_vault_7', temp_vault)\n\n    notation_note_1 = VaultNote(temp_vault, name='some_reference_name_notation_Pic_C')\n    main_note_1 = VaultNote(temp_vault, name='divisor_class_group_of_a_curve')\n    notation_note_2 = VaultNote(temp_vault, name='some_reference_name_notation_Spec_A')\n    main_note_2 = VaultNote(temp_vault, name='spectrum_of_a_ring')\n    notation_note_3 = VaultNote(temp_vault, name='foag_notation_O_n')\n    main_note_3 = VaultNote(temp_vault, name='foag_15.2.1')\n\n    assert not notation_note_is_linked_in_see_also_section(notation_note_1, main_note_1)\n    assert not notation_note_is_linked_in_see_also_section(notation_note_2, main_note_2)\n    assert not notation_note_is_linked_in_see_also_section(notation_note_3, main_note_3)\n    add_missing_notation_links_to_information_notes(temp_vault, '')\n    assert notation_note_is_linked_in_see_also_section(notation_note_1, main_note_1)\n    assert notation_note_is_linked_in_see_also_section(notation_note_2, main_note_2)\n    assert notation_note_is_linked_in_see_also_section(notation_note_3, main_note_3)",
    "crumbs": [
      "markdown.obsidian.personal.notation.in_standard_information_note"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.note_processing.html",
    "href": "markdown.obsidian.personal.note_processing.html",
    "title": "markdown.obisidian.personal.note_processing",
    "section": "",
    "text": "from trouver.helper.tests import _test_directory\nfrom fastcore.test import *\n\ntrouver assumes that the notes in the Obsidian.md math vaults are are roughly of the following format:\n\nvault = _test_directory() / 'test_vault_5'\ntemplate_note = VaultNote(vault, name='_template_common')\nprint(template_note.text())\n\n---\ncssclass: clean-embeds\naliases: []\ntags: [_meta/literature_note]\n---\n# Topic[^1]\n\n# See Also\n\n# Meta\n## References\n\n## Citations and Footnotes\n[^1]: Citation\n\n\nThe functions in this module extract information about such notes. For example, they extract the main text (without the metadata, links, footnotes, etc.) to obtain the “raw” text of the note.\n\nsource\n\nremove_double_asterisks_in_markdown_file\n\n remove_double_asterisks_in_markdown_file\n                                           (markdown_file:trouver.markdown\n                                           .markdown.file.MarkdownFile)\n\n*Remove double asterisks in MarkdownFile object.\nThe author of trouver chose to implement this function outside of the MarkdownFile class because its use seems specific - this function is mostly intended to remove double asterisks marking definitions and notations introduced in LaTeX text.*\n\nmf = MarkdownFile.from_string('Hi. Here are some double asterisks: **')\n\nremove_double_asterisks_in_markdown_file(mf)\ntest_eq(str(mf), 'Hi. Here are some double asterisks: ')\n\nmf = MarkdownFile.from_string(\n    'I want to use double asterisks to surround definitions and notations:'\n    ' the **Galois group** **$\\operatorname{Gal}(L/K)$** of a Galois extension'\n    ' $L/K$ is...')\nremove_double_asterisks_in_markdown_file(mf)\ntest_eq(str(mf), 'I want to use double asterisks to surround definitions and notations: the Galois group $\\operatorname{Gal}(L/K)$ of a Galois extension $L/K$ is...')\n\n\nsource\n\n\nprocess_standard_information_note\n\n process_standard_information_note\n                                    (markdown_file:Union[trouver.markdown.\n                                    markdown.file.MarkdownFile,str],\n                                    vault:os.PathLike,\n                                    remove_frontmatter_meta:bool=True,\n                                    remove_see_also_section:bool=True,\n                                    remove_meta_section:bool=True,\n                                    remove_references_section:bool=True,\n                                    remove_double_asterisks:bool=True,\n                                    remove_html_tags:bool=True,\n                                    remove_links:bool=True,\n                                    remove_in_line_tags:bool=True, remove_\n                                    footnotes_to_embedded:bool=True,\n                                    remove_headers:bool=True,\n                                    remove_citation_footnotes:bool=True, r\n                                    eplace_embedded_links_with_content:boo\n                                    l=True,\n                                    merge_display_math_mode:bool=True, mer\n                                    ge_display_math_mode_into_text:Optiona\n                                    l[str]=None,\n                                    no_double_blank_lines:bool=True)\n\n*Process/modify a str/MarkdownFile of a standard information note.\nTODO: implement remove_citation_footnote properly.\nEven if remove_html_tags is set to True, only the HTML tags which are written within a single line of text are removed.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nmarkdown_file\nUnion\n\n\n\n\nvault\nPathLike\n\n\n\n\nremove_frontmatter_meta\nbool\nTrue\nIf True, removes the frontmatter meta. Defaults to True\n\n\nremove_see_also_section\nbool\nTrue\nIf True, removes the # See also section. Defaults to True.\n\n\nremove_meta_section\nbool\nTrue\nIf True, remove the # Meta section. Defaults to True.\n\n\nremove_references_section\nbool\nTrue\nIf True, removes the ## References section. Defaults to True.\n\n\nremove_double_asterisks\nbool\nTrue\nIf True, removes double asterisks. Defaults to True.\n\n\nremove_html_tags\nbool\nTrue\nIf True, remove HTML tags. Defaults to True`` | | remove_links | bool | True | IfTrue, removes nonembedded links and replaces them with their display text. Defaults toTrue. | | remove_in_line_tags | bool | True | IfTrue, removes in-line tags (the lines that start with a tag).  Defaults toTrue. | | remove_footnotes_to_embedded | bool | True | IfTrue, removes footnotes to embedded notes. Defaults toTrue. | | remove_headers | bool | True | IfTrue, removes headers. Defaults toTrue. | | remove_citation_footnotes | bool | True | IfTrue, removes the citation footnote. Defaults toTrue. | | replace_embedded_links_with_content | bool | True | IfTrue, replaces embedded links with their content.  Defaults toTrue. | | merge_display_math_mode | bool | True | IfTrue, merge each group of display math mode latex lines into single lines.  Defaults toTrue. | | merge_display_math_mode_into_text | Optional | None | If notNone, merge each group of display math mode latex lines into single lines and merge those groups into the text that precedes them with the specified str. Defaults toNone.  The blank character and the new-line characterare recommended as arguments. | | no_double_blank_lines | bool | True | IfTrue, removes escape characters‘’to make it so that there are no double blank lines. Defaults toTrue. | | **Returns** | **MarkdownFile** |  | **Ifmarkdown_fileis a [MarkdownFile](https://hyunjongkimmath.github.io/trouver/markdown.markdown.file.html#markdownfile) object, then the output ismarkdown_fileitself (not a copy) with modifications. Ifmarkdown_fileis astr, then the output is a [MarkdownFile`](https://hyunjongkimmath.github.io/trouver/markdown.markdown.file.html#markdownfile) object with the modifications.**\n\n\n\n\n# TODO: add examples",
    "crumbs": [
      "markdown.obisidian.personal.note_processing"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.vault.html",
    "href": "markdown.obsidian.personal.vault.html",
    "title": "markdown.obsidian.personal.vault",
    "section": "",
    "text": "import shutil\nimport tempfile\nfrom unittest import mock\n\nfrom fastcore.test import *\n\nfrom trouver.helper.tests import _test_directory",
    "crumbs": [
      "markdown.obsidian.personal.vault"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.vault.html#footnotes",
    "href": "markdown.obsidian.personal.vault.html#footnotes",
    "title": "markdown.obsidian.personal.vault",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nMost representatively, trouver curreently requires the vault to have a directories called _references and _templates in the root directory of the vault. These directories, need to have subdirectories named A-E, F-J, K-O, P-T, U-Z, each of which need to have further subdirectories whose names are single letter alphabets in the ranges of their own names, e.g. A-E has subdirectories named A, B, C, D, and E.\nThese directories store reference notes and template notes, see 14_markdown.obsidian.personal.note_type↩︎",
    "crumbs": [
      "markdown.obsidian.personal.vault"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.machine_learninig.database_update.html",
    "href": "markdown.obsidian.personal.machine_learninig.database_update.html",
    "title": "markdown.obisidian.personal.machine_learning.database_update",
    "section": "",
    "text": "NOTE: This module is effectively deprecated\n\nfrom fastcore.test import *\n\n\nsource\n\nmax_ID\n\n max_ID (df:pandas.core.frame.DataFrame)\n\nReturn the largest value of ID in df\n\ndf = pd.DataFrame([{'ID': 1}, {'ID': 2}, {'ID': 4}])\ntest_eq(max_ID(df), 4)\n\n\nsource\n\n\nappend_to_database\n\n append_to_database (file:os.PathLike,\n                     df_to_append:pandas.core.frame.DataFrame,\n                     cols:list[str], pivot_column:str,\n                     columns_to_update:list[str], backup:bool=True)\n\n*Either create a csv file containing data or append to an existing csv file.\nThe columns of the database file should contain:\n\nTime added - The time when the row was added.\nTime modified - The time when the labels of the row was derived.\n\nAll timestamps are in UTC time and specify time to minutes (i.e. no seconds/microseconds).\nIf df_to_append contains a row with the same entry in pivot_column as an existing row, then only a single row with the entry in pivot_column should remain and the reset of the row should be updated appropriately.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nfile\nPathLike\n\nThe path to a csv file\n\n\ndf_to_append\nDataFrame\n\nThe DataFrame to append\n\n\ncols\nlist\n\nAll columns of the dataframe in the order that they should be presented.\n\n\npivot_column\nstr\n\nIf there are multiple rows with the same entry in this column, then only a single row with that entry should remain and that row should be updated appropraitely.\n\n\ncolumns_to_update\nlist\n\nThe columns that should be updated if there are multiple rows with the same entry in the column pivot_column.\n\n\nbackup\nbool\nTrue\nIf True, makes a copy of file in the same directory and with the same name, except with an added extension of .bak.\n\n\nReturns\nNone\n\n\n\n\n\n\n# TODO: test\n# TODO: test that rows are properly apended.",
    "crumbs": [
      "markdown.obisidian.personal.machine_learning.database_update"
    ]
  },
  {
    "objectID": "latex.formatting.html",
    "href": "latex.formatting.html",
    "title": "latex.formatting",
    "section": "",
    "text": "See helper.latex.macros_and_commands, which contains some functions originally written for this module.",
    "crumbs": [
      "latex.formatting"
    ]
  },
  {
    "objectID": "latex.formatting.html#numbers",
    "href": "latex.formatting.html#numbers",
    "title": "latex.formatting",
    "section": "Numbers",
    "text": "Numbers\n\nsource\n\nis_number\n\n is_number (x:Union[float,int,complex,str])\n\n*Return True if the input x represents a number.\nThis function is different from Python’s built-in is_numeric function, which returns True when all characters of a string are digits.*\n\nassert is_number(\"3.45\")\nassert is_number(1 + 5j)\nassert is_number(5)\nassert is_number(0.0)\nassert not is_number(\"3.43.55\")\nassert not is_number(\"hie\")\nassert not is_number(\"[^1]\")\nassert not is_number(None)\n\n\nfrom fastcore.test import test_eq\n\nfrom trouver.helper.tests import _test_directory# , non_utf8_chars_in_file",
    "crumbs": [
      "latex.formatting"
    ]
  },
  {
    "objectID": "latex.formatting.html#formatting-modifications-from-latex-to-obsidian.md-style-markdown",
    "href": "latex.formatting.html#formatting-modifications-from-latex-to-obsidian.md-style-markdown",
    "title": "latex.formatting",
    "section": "Formatting modifications (from LaTeX to Obsidian.md style Markdown)",
    "text": "Formatting modifications (from LaTeX to Obsidian.md style Markdown)\n\nIdentify macros and commands to replace\nAuthors usually define a lot of custom commands and macros in their LaTeX files. Such customizations vary from author to author and most customized commands are not recognized by Obsidian.\nSee nbs/_tests/latex_examples/commands_example/main.tex for some examples of custom commands.\n\nsource\n\n\nreplace_command_in_text\n\n replace_command_in_text (text:str,\n                          command_tuple:tuple[str,int,typing.Optional[str]\n                          ,str])\n\n*Replaces all invocations of the specified command in text with the display text with the arguments used in the display text.\nAssumes that ‘\u0001’, ‘\u0002’, ‘\u0003’, etc. are not part of the display text.*\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ntext\nstr\n\n\n\ncommand_tuple\ntuple\nConsists of 1. the name of the custom command 2. the number of parameters 3. The default argument if specified or None otherwise, and 4. the display text of the command.\n\n\n\n\n# Basic\ncommand_tuple = ('Sur', 0, None, r'\\mathrm{Sur}')\n# pattern = regex_pattern_detecting_command(command_tuple)\ntext = r'The number of element of $\\Sur(\\operatorname{Cl} \\mathcal{O}_L, A)$ is ... Perhaps $\\Sur$ is nonempty.'\ntest_eq(replace_command_in_text(text, command_tuple), r'The number of element of $\\mathrm{Sur}(\\operatorname{Cl} \\mathcal{O}_L, A)$ is ... Perhaps $\\mathrm{Sur}$ is nonempty.')\n\n\n# One parameter\ncommand_tuple = ('field', 1, None, r'\\mathbb{#1}')\n# pattern = regex_pattern_detecting_command(command_tuple)\ntext = r'$\\field{Q}$ is the field of rational numbers. $\\field{C}$ is the field of complex numbers'\ntest_eq(replace_command_in_text(text, command_tuple), r'$\\mathbb{Q}$ is the field of rational numbers. $\\mathbb{C}$ is the field of complex numbers')\n\n# Multiple parameters\ncommand_tuple = ('mat', 4, None, r'\\left[\\begin{array}{cc}#1 & #2 \\\\ #3 & #4\\end{array}\\right]')\n# pattern = regex_pattern_detecting_command(command_tuple)\ntext = r'\\mat{{123}}{asdfasdf{}{}}{{{}}}{{asdf}{asdf}{}}' # This is a balanced str.\ntest_eq(replace_command_in_text(text, command_tuple), r'\\left[\\begin{array}{cc}{123} & asdfasdf{}{} \\\\ {{}} & {asdf}{asdf}{}\\end{array}\\right]')\n\n# Multiple parameters, one of which is optional parameter\ncommand_tuple = ('plusbinomial', 3, '2', r'(#2 + #3)^#1')\n# pattern = regex_pattern_detecting_command(command_tuple)\n# When the optional parameter is used\ntext = r'\\plusbinomial{x}{y}'\ntest_eq(replace_command_in_text(text, command_tuple), r'(x + y)^2')\n\n# When the optional parameter is not used\ntext = r'\\plusbinomial[4]{x}{y}'\ntest_eq(replace_command_in_text(text, command_tuple), r'(x + y)^4')\n\n\n# One parameter that is optional.\ncommand_tuple = ('greet', 1, 'world', r'Hello #1!')\n# pattern = regex_pattern_detecting_command(command_tuple)\n# When the optional parameter is used\ntext = r'\\greet'\ntest_eq(replace_command_in_text(text, command_tuple), r'Hello world!')\n\n# When the optional parameter is not used\ntext = r'\\greet[govna]'\ntest_eq(replace_command_in_text(text, command_tuple), r'Hello govna!')\n\n# In the following example, `\\del` is a command defined as `\\delta`.\n# Any invocation `\\delta` should NOT be replaced into `\\deltata` should NOT be replaced into `\\deltata`\ncommand_tuple = (r'del', 0, None, r'\\delta')\n# pattern = regex_pattern_detecting_command(command_tuple)\ntext = r'\\del should be replaced. \\delta should not.'\ntest_eq(replace_command_in_text(text, command_tuple), r'\\delta should be replaced. \\delta should not.')\n\n\nsource\n\n\nreplace_commands_in_text\n\n replace_commands_in_text (text:str,\n                           command_tuples:list[tuple[str,int,typing.Option\n                           al[str],str]], repeat:int=1)\n\n*Replaces all invocations of the specified commands in text with the display text with the arguments used in the display text.\nAssumes that ‘\u0001’, ‘\u0002’, ‘\u0003’, etc. are not part of the display text.\nIf repeat is set to -1, then this function attempts to replace custom commands until no commands to replace are found. However, this might cause infinite loops for some documents.*\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ntext\nstr\n\nThe text in which to replace the commands. This should not include the preamble of a latex document.\n\n\ncommand_tuples\nlist\n\nAn output of custom_commands. Each tuple Consists of 1. the name of the custom command 2. the number of parameters 3. The default argument if specified or None otherwise, and 4. the display text of the command.\n\n\nrepeat\nint\n1\nThe number of times to repeat replacing the commands throughout the text; note that some custom commands could be “nested”, i.e. the custom commands are defined in terms of other custom commands. Defaults to 1, in which custom commands are replaced throughout the entire document once. If set to -1, then this function attempts to replace custom commands until no commands to replace are found.\n\n\nReturns\nstr\n\n\n\n\n\nThe replace_comands_in_text function replaces custom commands from a (the main part of) a LaTeX document.\n\ntext = r'''Here is a matrix over $\\field{Q}$: $\\mat{1/2}{2}{-1}{5/7}$.\n           Note that it is not over $\\field{F}_7$ and not over $\\field{F}_2$.'''\n\ncommand_tuples = [\n    ('field', 1, None, r'\\mathbb{#1}'),\n    ('mat', 4, None, r'\\left[\\begin{array}{cc}#1 & #2 \\\\ #3 & #4\\end{array}\\right]')]\n\nsample_output = replace_commands_in_text(text, command_tuples)\n\ntest_eq(sample_output, \n        r'''Here is a matrix over $\\mathbb{Q}$: $\\left[\\begin{array}{cc}1/2 & 2 \\\\ -1 & 5/7\\end{array}\\right]$.\n           Note that it is not over $\\mathbb{F}_7$ and not over $\\mathbb{F}_2$.''')\n\nNote that some writers define custom commands using other custom commands. By default, the replace_commands_in_text function replaces custom commands just once. In the following example, there is a custom command that is defined using another custom command and the function replace the “outer” custom command:\n\n# TODO: continue this example\ntext = r'''$\\Gm$'''\n\ncommand_tuples = [\n    ('Gm', 0, None, r'\\bG_\\mult'),\n    ('bG', 0, None, r'\\mathbb{G}'),\n    ('mult', 0, None, r'\\times'),\n]\n\nsample_output = replace_commands_in_text(text, command_tuples)\ntest_eq(sample_output, \n        r'''$\\mathbb{G}_\\times$''')\n\n\nsource\n\n\nreplace_commands_in_latex_document\n\n replace_commands_in_latex_document (document:str, repeat:int=1)\n\n*Return the latex document (with the preamble) with invocations of custom commands/operators replaced with their display text.\nAssumes that all custom commands and operators are defined in the preamble.\nAssumes that, if commands with the same name are defined multiple times, only the finally defined command is used.\nThis function does not replace \\input’s and \\include’s with the code of the corresponding files. See replace_input_and_include, which accomplishes this.\nEven replaces these invocations incommented out text.*\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndocument\nstr\n\n\n\n\nrepeat\nint\n1\nThe number of times to repeat replacing the commands throughout the text; note that some custom commands could be “nested”, i.e. the custom commands are defined in terms of other custom commands. Defaults to 1, in which custom commands are replaced throughout the entire document once. If set to -1, then this function attempts to replace custom commands until no commands to replace are found. See also replace_commands_in_text\n\n\nReturns\nstr\n\n\n\n\n\n\nfile = _test_directory() / 'latex_examples' / 'commands_recursive_example' / 'main.tex'\ndocument = text_from_file(file)\ncommands_replaced = replace_commands_in_latex_document(document)\nassert commands_replaced.startswith(r'\\begin{document}')\nassert commands_replaced.endswith(r'\\end{document}')\nassert r'\\S' not in commands_replaced\nassert r'\\mathbb{S}1' in commands_replaced  # Note that $\\S$ is defined twice in the preamble; only the latter definition is used.\nassert r'\\field{Q}$' not in commands_replaced\nassert r'\\mathbb{Q}$' in commands_replaced\nassert r'\\commentedout' not in commands_replaced\nassert r'This is actually a command that is commented out, but it is also replaced!' in commands_replaced\nprint(commands_replaced)\n\n\\begin{document}\n\n$\\mathbb{S}1$\n%$\\mathbf{Q}$\n%$\\mathbf{Q}$\n%This is actually a command that is commented out, but it is also replaced!\n$\\mathbb{Q}$\n\n\\end{document}\n\n\n\n\nReplace commonly used syntax\nObsidian does not compile all LaTeX syntax. For example\n\n\\( \\) and \\[ \\] are not recognized as math mode delimiters.\n\\begin{equation} \\end{equation} and \\begin{align} \\end{align} (as well as their unnumbered versions with *) require surrounding $$.\n\nThe adjust_common_syntax_to_markdown function gives options to modify formatting from LaTeX text to fit markdown better.\n\nsource\n\n\nadjust_common_syntax_to_markdown\n\n adjust_common_syntax_to_markdown (text:str,\n                                   options:list[str]=['math_mode_delimiter\n                                   s', 'begin_end_equationlike_env', 'repl\n                                   ace_backtick_and_apostrophe_quotes',\n                                   'remove_comments',\n                                   'inline_mathmode_to_own_paragraph',\n                                   'merge_multiline_paragraph',\n                                   'remove_xspace', 'remove_ensuremath'])\n\n*Adjust some common syntax, such as math mode delimiters and equation/align environments, for Markdown.\nAssumes that the tokens for math mode delimiters (e.g. \\( \\) and \\[ \\]) are not used otherwise.\nThe following lists admissible parameters in the options parameter and the effects that including them have:\n\n\"math_mode_delimiters\"\n\nReplace \\( \\) as math mode delimiters with $ $.\nReplace \\[ \\] as math mode delimiters with $$ $$.\n\n\"begin_end_equationlike_env\"\n\nReplace \\\\begin{...} \\end{...} with $$\\\\begin{...} \\end{...}$$ and \\\\begin{...*} \\end{...*} with $$\\\\begin{...*} \\end{...*}$$ for the following environments:\n\nalign\ndisplaymath\nequation\neqnarray\n\n\n\"replace_backtick_and_apostrophe_quotes\"\n\nreplace `` '' as quotation delimiters with \" \".\n\n\"remove_comments\"\n\nremove LaTeX comments.\n\n\"inline_mathmode_to_own_paragraph\"\n\nMake it so that each inline-math mode string (of the form $$...$$) has at least one newline before and after it. Also delete one blank space character ' ' from the text immediately before and after the in-line math mode string if they exist.\n\n\"merge_multiline_paragraph\"\n\nSome writers will type paragraphs in multiple lines, likely because their LaTeX editor of choice does not wrap text within a single line. Including this option merges “normal” paragraphs into a single line.\n\nInline-mathmode text are not affected by this option.\n\n\n\"remove_xspace\"\n\nSome writiers include \\\\xspace in their code (such as in their custom commands) Obsidian does not render these.\n\n\"remove_ensuremath\"\n\nSome writiers include \\\\ensuremath in their code (such as in their custom commands) Obsidian does not render these.*\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ntext\nstr\n\nThe LaTeX code to adjust to Markdown.\n\n\noptions\nlist\n[‘math_mode_delimiters’, ‘begin_end_equationlike_env’, ‘replace_backtick_and_apostrophe_quotes’, ‘remove_comments’, ‘inline_mathmode_to_own_paragraph’, ‘merge_multiline_paragraph’, ‘remove_xspace’, ‘remove_ensuremath’]\n\n\n\nReturns\nstr\n\nEach str specifies what formatting should be done.\n\n\n\n\ntext = r'''\nare cellular and the DG category one gets by replacing the\ntopological spaces ${Mor}_{{\\mathcal K}_{{top}}}(X_i,X_j)$ by their\ncellular chain complexes equals ${\\mathcal K}$.\n'''\nprint(_merge_multilines(text))\n\n\nare cellular and the DG category one gets by replacing the topological spaces ${Mor}_{{\\mathcal K}_{{top}}}(X_i,X_j)$ by their cellular chain complexes equals ${\\mathcal K}$.\n\n\n\nHere is a basic example:\n\ntext = r'''I want to talk about \\(\\mathbb{Z}[i]\\). It is the ring whose elements are of the form $a+bi$ where $a,b \\in \\mathhbb{Z}$.\nIt has a multiplication structure:\n\\[ (a+bi) (c+di) = (ac-bd) + (ad+bc)i.\\]\n\nHere is an equation:\n\\begin{equation}\n5+7 = 12\n\\end{equation}\n\nHere is another:\n\\begin{equation*}\n5+6 = 11\n\\end{equation*}\n\nHere is an align:\n\\begin{align}\n5+7 = 12\n\\end{align}\n\nHere is another:\n\\begin{align*}\n5+6 = 11\n\\end{align*}\n\n\\begin{eqnarray}\nasdf\n\\end{eqnarray}\n\n\\begin{displaymath}\nasdf\n\\end{displaymath}\n\nasdf ``hello''\n\n``a multiline\nquotation'' % Sneak comment!\n\n'''\nsample_output = adjust_common_syntax_to_markdown(text)\nprint(sample_output)\nassert r'\\(' not in sample_output\nassert r'\\)' not in sample_output\nassert r'\\[' not in sample_output\nassert r'\\]' not in sample_output\nassert r'$$\\begin{align}' in sample_output\nassert r'\\end{align}$$' in sample_output\nassert r'$$\\begin{equation}' in sample_output\nassert r'\\end{equation}$$' in sample_output\nassert r'$$\\begin{align*}' in sample_output\nassert r'\\end{align*}$$' in sample_output\nassert r'$$\\begin{equation*}' in sample_output\nassert r'\\end{equation*}$$' in sample_output\nassert r'$$\\begin{eqnarray}' in sample_output\nassert r'\\end{eqnarray}$$' in sample_output\nassert r'$$\\begin{displaymath}' in sample_output\nassert r'\\end{displaymath}$$' in sample_output\nassert r\"``hello''\" not in sample_output\nassert r'\"hello\"' in sample_output\nassert '\"a multiline quotation\"' in sample_output\nassert ' \"a multiline quotation\"' not in sample_output\nassert '``' not in sample_output\nassert r'%' not in sample_output\nassert r'Sneak comment' not in sample_output\n\nI want to talk about $\\mathbb{Z}[i]$. It is the ring whose elements are of the form $a+bi$ where $a,b \\in \\mathhbb{Z}$. It has a multiplication structure:\n\n$$ (a+bi) (c+di) = (ac-bd) + (ad+bc)i.$$\n\nHere is an equation:\n\n$$\\begin{equation}\n5+7 = 12\n\\end{equation}$$\n\nHere is another:\n\n$$\\begin{equation*}\n5+6 = 11\n\\end{equation*}$$\n\nHere is an align:\n\n$$\\begin{align}\n5+7 = 12\n\\end{align}$$\n\nHere is another:\n\n$$\\begin{align*}\n5+6 = 11\n\\end{align*}$$\n\n$$\\begin{eqnarray}\nasdf\n\\end{eqnarray}$$\n\n$$\\begin{displaymath}\nasdf\n\\end{displaymath}$$\n\nasdf \"hello\"\n\n\"a multiline quotation\" \n\n\n\n\nWe test the removal of \\xspace and \\ensuremath\n\ntext = r'\\ensuremath{\\operatorname{GL}_n}\\xspace'\ntest_eq(adjust_common_syntax_to_markdown(text), '\\\\operatorname{GL}_n')",
    "crumbs": [
      "latex.formatting"
    ]
  },
  {
    "objectID": "latex.formatting.html#formatting-irregularities",
    "href": "latex.formatting.html#formatting-irregularities",
    "title": "latex.formatting",
    "section": "Formatting irregularities",
    "text": "Formatting irregularities\nSince writers use their own formatting for LaTeX documents, there will be formatting practices that the functions in this module do not account for or do not fully account for. The following parses the LaTeX document to warn the user of formatting choices that trouver does not account for.\n\ndef warn_for_formatting_irregularities(\n        document: str\n        ):\n    # TODO: Go through assumptions made by various functions\n    # TODO: custom command for section\n    # TODO: custom command is invoked, but does not match explicit formatting, e.g. {\\tilde M}\n    # TODO: warn about \\docuemntclass; the most common are `amsart` and `article`, but some writers will use other classes, such as `standalone, svmult, icmart, compositio`\n    # TODO: warn about \\newcounter, cf https://www.overleaf.com/learn/latex/Counters#LaTeX_commands_for_working_with_counters.\n    # TODO: warn about newcomand and DeclareOperator being declared as custom commands of their own. cf. arinkin_gaitsgory_sscsglc\n    # TODO: warn about section/subsection/subsubsetion being wrapped around some custom commands.\n    return",
    "crumbs": [
      "latex.formatting"
    ]
  },
  {
    "objectID": "latex.formatting.html#replace-input-and-include",
    "href": "latex.formatting.html#replace-input-and-include",
    "title": "latex.formatting",
    "section": "Replace \\input and \\include",
    "text": "Replace \\input and \\include\nWriters oftentimes opt to use separate their writings in multiple parts and then incorporate these parts using \\input or \\include. The following functions account for these to put together all the latex code in one place\n\nsource\n\nreplace_input_and_include\n\n replace_input_and_include (document:str, dir:os.PathLike,\n                            commands:list[tuple[str,int,typing.Optional[st\n                            r],str]], repeat_replacing_commands:int=-1)\n\nSequentially replace invocations of \\input or \\include with the contents of the corresponding files, updating and applying custom commands as needed.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndocument\nstr\n\n\n\n\ndir\nPathLike\n\nThe directory containing the .tex files which are to be included.\n\n\ncommands\nlist\n\n\n\n\nrepeat_replacing_commands\nint\n-1\nthis is passed as the repeat argument into the invocation of replace_commands_in_text.\n\n\nReturns\nstr\n\n\n\n\n\nThe following is a basic example\n\nlatex_folder = _test_directory() / 'latex_examples' / 'latex_example_with_inputs_and_includes'\nmain_file = latex_folder / 'main.tex'\nwith open(main_file, 'r', encoding='utf-8') as file:\n    document = file.read()\npreamble, body = divide_preamble(document)\ncommands = custom_commands(preamble)\noutput = replace_input_and_include(body, latex_folder, commands)\n\n\nprint(output)\n\n\\begin{document}\n\n\\section*{\\underline{Introduction}}\nThis is the main document. We use {\\bf custom commands} here.\n\n% This file defines new commands\n\n\nNow we can use {\\it input command}.\n\n\n\\section*{\\underline{Chapter 1}}\n\nThis is content from chapter 1. We define {\\large new commands} here too.\n\nThis function is related to the main document\n\n\nLet's use {\\large include command} from chapter1.\n\n\n\\subsection{A Subsection}\n\nThis content is from a subsection file. We use {\\small\\textsc{local commands}} here.\n\nWe also use {\\bf main document commands} and {\\it input file commands}.\n\n\nFinally, we use {\\small\\textsc{another input}}.\n\n\\end{document}",
    "crumbs": [
      "latex.formatting"
    ]
  },
  {
    "objectID": "latex.formatting.html#formatting-modifications-from-obsidian.md-style-markdown-to-latex",
    "href": "latex.formatting.html#formatting-modifications-from-obsidian.md-style-markdown-to-latex",
    "title": "latex.formatting",
    "section": "Formatting modifications (from Obsidian.md style Markdown to LaTeX)",
    "text": "Formatting modifications (from Obsidian.md style Markdown to LaTeX)\nAs written previously displaymath/equationlike environments (e.g. \\begin{equation} \\end{equation}) used in Markdown require surrounding $$.\nThe remove_dollar_signs_around_equationlike_envs function is one function used to revert such markdown-formatted code into code better suited for LaTeX.\n\nsource\n\nremove_dollar_signs_around_equationlike_envs\n\n remove_dollar_signs_around_equationlike_envs (text:str)\n\n*Remove dollar signs preceding and following displaymath/equation-like environments.\nSuch dollar signs are in place to make the code renderable as Markdown code in Obsidian.md.\nThis function is essentially the reverse of _replace_equationlike_envs.*\n\noutput = remove_dollar_signs_around_equationlike_envs(\nr'''$$\\begin{align*}asdf\\end{align*}$$''')\nprint(output)\nassert '$' not in output\n\n\\begin{align*}asdf\\end{align*}",
    "crumbs": [
      "latex.formatting"
    ]
  },
  {
    "objectID": "markdown.markdown.file.html",
    "href": "markdown.markdown.file.html",
    "title": "markdown.markdown.file",
    "section": "",
    "text": "from collections import OrderedDict\nimport os\nfrom pathlib import Path \nimport tempfile\nimport shutil\n\nfrom fastcore.test import *\nfrom nbdev.showdoc import show_doc",
    "crumbs": [
      "markdown.markdown.file"
    ]
  },
  {
    "objectID": "markdown.markdown.file.html#frontmatter-meta",
    "href": "markdown.markdown.file.html#frontmatter-meta",
    "title": "markdown.markdown.file",
    "section": "Frontmatter meta",
    "text": "Frontmatter meta\n/opt/hostedtoolcache/Python/3.10.15/x64/lib/python3.10/site-packages/fastcore/docscrape.py:230: UserWarning: potentially wrong underline length... \n```markdown \n--- in \nReturn ranges in the markdown text string where front matter meta occurs.\n...\n  else: warn(msg)\n\nsource\n\nfind_front_matter_meta_in_markdown_text\n\n find_front_matter_meta_in_markdown_text (text:str)\n\n*Return ranges in the markdown text string where front matter meta occurs.\ntext is assumed to start with the front matter meta. The front matter meta is of the following YAML format.\n---\nkey: entry\n---\n```*\n\n|    | **Type** | **Details** |\n| -- | -------- | ----------- |\n| text | str |  |\n| **Returns** | **Optional** | **Each tuple is of the form `(a,b)` where `text[a:b]` is a markdown front matter. This list will be of length at most 1 because the front matter must come at the start of the markdown document.** |\n\n\nThe frontmatter meta in an Obsidian Markdown note is surrounded by `---` and must be at the top. We can identify the frontmatter meta in some text:\n\n::: {#cell-6 .cell}\n``` {.python .cell-code}\nsample_text = r'''---\ncssclass: clean-embeds\naliases: []\ntags: [_meta/TODO/change_title, _meta/definition, _meta/literature_note]\n---\n# Topic[^1]\n\nThis is some text. Lalalalala\n\n# See Also\n\n# Meta\n## References\n![[_reference_foag]]\n\n## Citations and Footnotes\n[^1]: Some citation'''\n\nstart, end = find_front_matter_meta_in_markdown_text(sample_text)\njust_frontmatter = sample_text[start:end]\nprint(just_frontmatter)\nassert just_frontmatter.startswith('---')\nassert just_frontmatter.endswith('---')\nassert 'cssclass:' in just_frontmatter\nassert 'aliases:' in just_frontmatter\nassert 'tags:' in just_frontmatter\n\n---\ncssclass: clean-embeds\naliases: []\ntags: [_meta/TODO/change_title, _meta/definition, _meta/literature_note]\n---\n\n:::\nIf there is no frontmatter meta, then find_front_matter_meta_in_markdown_text returns None.\n\nsample_text = r'''\nThere is no frontmatter meta here.\n'''\n\nassert find_front_matter_meta_in_markdown_text(sample_text) is None\n\n\nsample_text = r'''\n---\naliases: []\n--\nNotice that the front matter meta is incorrectly formatted!\n'''\n\nassert find_front_matter_meta_in_markdown_text(sample_text) is None\n\n\n# hide \n# Some additional tests\nsample_text_1 = ''\nassert find_front_matter_meta_in_markdown_text(sample_text_1) is None\nsample_text_2 = \"hello I know a song that gets on everybody\\'s nose\"\nassert find_front_matter_meta_in_markdown_text(sample_text_2) is None\nsample_text_3 = '---\\n---'\nstart, end = find_front_matter_meta_in_markdown_text(sample_text_3)\nassert sample_text_3[start:end] == sample_text_3\nsample_text_4 = '---\\n---\\n---'\nstart, end = find_front_matter_meta_in_markdown_text(sample_text_4)\nassert sample_text_4[start:end] == '---\\n---'\n\n\nsource\n\n\ndict_to_metadata_lines\n\n dict_to_metadata_lines (data:dict[str,typing.Union[str,list[str]]],\n                         enquote_entries_in_fields=list[str])\n\n*Convert a dict to a list of str of yaml frontmatter metadata that Obsidian recognizes.\nThis function is used in MarkdownFile.replace_metadata.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndata\ndict\n\nThe keys are str of the labels/names of the metadata. The values are the metadata, which are usually str or list.\n\n\nenquote_entries_in_fields\nGenericAlias\nlist\nA list of str of fields in the YAML metadata whose entries need to be enquoted. If there is a string that is not a key of new_metadata, then that string is essentially ignored (in particular, no errors are raised).\n\n\nReturns\nlist\n\nEach str entry is the line for the yaml frontmatter metadata of an Obsidian Markdown note.\n\n\n\ndict_to_metadata_lines takes a dictionary and converts it to a string usable as Obsidian Markdown frontmatter meta.\n\nsample_dict = OrderedDict([\n            ('cssclass', 'clean-embeds'),\n            ('aliases', []),\n            ('tags', ['_meta/literature_note', '_meta/research', '_meta/self_written'])])\nsample_output = dict_to_metadata_lines(sample_dict, [])\ntest_eq(sample_output,\n    ['cssclass: clean-embeds', 'aliases: []', 'tags: [_meta/literature_note, _meta/research, _meta/self_written]'])\n\n# sample_lines = dict_to_metadata_lines(sample_dict)\n# sample_output = \n# print('\\n'.join(sample_lines))\n# assert sample_lines == sample_output\n\nWe can specify entries of fields to be enquoted. This might be necessary if a string needs to be escaped (because it has a character such as the backslash r'\\', the mid slash r'|', a square bracket r'[', etc.). For example, if a field is expected to have LaTeX strings, then it is good practice to specify such strings to be enquoted:\n\nsample_dict = OrderedDict([\n    ('latex_in_original', [r'\\\\mathscr{O}_{\\\\text {Proj } S_{*}}(n)'])\n])\nsample_output = dict_to_metadata_lines(sample_dict, enquote_entries_in_fields=['latex_in_original'])\ntest_eq(sample_output, ['latex_in_original: [\"\\\\\\\\\\\\\\\\mathscr{O}_{\\\\\\\\\\\\\\\\text {Proj } S_{*}}(n)\"]'])\n\n# An example of an entry that is not a string\nsample_dict = OrderedDict([\n    ('latex_in_original', [1])\n])\nsample_output = dict_to_metadata_lines(sample_dict, enquote_entries_in_fields=['latex_in_original'])\ntest_eq(sample_output, ['latex_in_original: [\"1\"]'])\n\n\nsource\n\n\nparse_metadata_string\n\n parse_metadata_string (metadata_str:str, raise_error:bool=True,\n                        raise_warning:bool=True)\n\n*Attempt to parse the string for YAML frontmatter metadata of an Obsidian Markdown note.\nRaises\n\nValueError\n\nIf raise_error is True and if any yaml.YAMLError exceptions are raised when reading (i.e. parsing or scanning the YAML metadata. In doing so, metadata_str is printed. Moreover, the appropriate yaml.YAMLError (e.g. a yaml.parser.ParserError, yaml.scanner.ScannerError, or yaml.reader.ReaderError) is also raised.\n\nWarning\n\nIf raise_error is False and raise_warning is True and if any yaml.YAMLError exceptions are raise when reading.*\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nmetadata_str\nstr\n\nThe string for YAML frontmatter metadata of an Obsidian Markdown note\n\n\nraise_error\nbool\nTrue\nIf True, then raise an Error.\n\n\nraise_warning\nbool\nTrue\nIf raise_error is false and raise_warning is True, then raise a warning message.\n\n\nReturns\nOptional\n\nThe keys are str of the labels/names of the metadata. The values are the metadata, which are usually str or list. If the YAML metadata string cannot be parsed, then this return value is None.\n\n\n\nThe parse_metadata_string function attempts to parse the string for YAML frontmatter metadata of an Obsidian Markdown note. If the argument can be parsed via the yaml.safe_load function, then the output of the yaml.safe_load invocation is returned:\n\ngood_metadata_str = r\"\"\"\nfield: [hi, bye]\nfieldy: ooh\n\"\"\"\n\nmetadata_output = parse_metadata_string(good_metadata_str)\nassert type(metadata_output) == dict\ntest_eq(metadata_output, {'field': ['hi', 'bye'], 'fieldy': 'ooh'})\n\nIf the YAML frontmatter metadata string cannot be parsed, by the yaml.safe_load function, then an error or a warning can be optionally raised. If raise_error is False, then parse_metadata_string returns None.\n\nbad_metadata_str = \"some_metadata_field: [\\badly_formatted_string]\"  # ReaderError\nwith (ExceptionExpected(ValueError)):\n    metadata_output = parse_metadata_string(bad_metadata_str, raise_error=True)\n# bad_metadata_str = \"field: field2:\" # ScannerError\n\ntest_warns(lambda: parse_metadata_string(bad_metadata_str, raise_error=False, raise_warning=True))\n\nmetadata_output = parse_metadata_string(bad_metadata_str, raise_error=False, raise_warning=False)\ntest_eq(metadata_output, None)\n\n\nyaml_string = 'latex_from_original: [\"[t]\", \"hi\"]'\ndata = yaml.safe_load(yaml_string)\nyaml.dump(data, default_flow_style=True)\n\n\"{latex_from_original: ['[t]', hi]}\\n\"\n\n\n\nyaml.dump(r'\\begin{align*}  \\end{align*}')\n\n'\\\\begin{align*}  \\\\end{align*}\\n...\\n'\n\n\n\nyaml.dump('[t]')\n\n\"'[t]'\\n\"",
    "crumbs": [
      "markdown.markdown.file"
    ]
  },
  {
    "objectID": "markdown.markdown.file.html#replace-embedded-links-with-text",
    "href": "markdown.markdown.file.html#replace-embedded-links-with-text",
    "title": "markdown.markdown.file",
    "section": "Replace embedded links with text",
    "text": "Replace embedded links with text\n\nsource\n\nreplace_embedded_links_with_text\n\n replace_embedded_links_with_text (text:str, vault:os.PathLike)\n\n*Return the text with all embedded links replaced with the text of the corresponding notes\nAssumes that the notes of the links exist in the vault and have unique names in the vault. Note that embedded links are not always to notes (e.g. they can point to images), or even to existing notes. In such cases, the embedded link will be replaced with blank text.*",
    "crumbs": [
      "markdown.markdown.file"
    ]
  },
  {
    "objectID": "markdown.markdown.file.html#markdownfile-class",
    "href": "markdown.markdown.file.html#markdownfile-class",
    "title": "markdown.markdown.file",
    "section": "MarkdownFile class",
    "text": "MarkdownFile class\n\nsource\n\nMarkdownLineEnum\n\n MarkdownLineEnum (value, names=None, module=None, qualname=None,\n                   type=None, start=1)\n\nAn enumeration.\nThe following are the members of the MarkdownLineEnum class:\n\nfor line_type in MarkdownLineEnum:\n    print(line_type.name)\n\nDEFAULT\nHEADING\nCODE_BLOCK\nMETA\nORDERED_LIST\nUNORDERED_LIST\nBLOCKQUOTE\nHORIZONTAL_RULE\nCOMMENT\nBLANK_LINE\nUNKNOWN\nFOOTNOTE_DESCRIPTION\nDISPLAY_LATEX_SINGLE\nDISPLAY_LATEX_START\nDISPLAY_LATEX_END\nDISPLAY_LATEX\n\n\n\nsource\n\n\nMarkdownFile\n\n MarkdownFile\n               (parts:list[dict[str,typing.Union[__main__.MarkdownLineEnum\n               ,str]]])\n\n*Parses and represents the contents of an Obsidian styled Markdown file.\nThe Markdown file must be formatted in certain ways. In general, text components of different types (see MarkdownLineEnum) must be on different lines - no text components of different types may occupy the same line. In particular,\n\nComments (surrounded by %%) must not be on the same line as non-comments.\nDisplay math mode LaTeX (surrounded by $$) must not be on the same line as non-In line LaTeX.\n\nAttributes\n\ntext - str\nparts - list[dict[str, Union[MarkdownLineEnum, str]]]\n\nRepresents the lines of the markdown file. Each dict has two keys, 'type' and 'line', which respectively hold a MarkdownLineEnum and a str as values. While a value of 'line' may have new line characters '\\n', it does not need to — more specifically, the __str__ method (and the text_of_lines method) adds new line characters '\\n' in between lines.*",
    "crumbs": [
      "markdown.markdown.file"
    ]
  },
  {
    "objectID": "markdown.markdown.file.html#example-text-and-example-vault-used-in-the-rest-of-the-page",
    "href": "markdown.markdown.file.html#example-text-and-example-vault-used-in-the-rest-of-the-page",
    "title": "markdown.markdown.file",
    "section": "Example text and example vault used in the rest of the page",
    "text": "Example text and example vault used in the rest of the page\nThe examples demonstrated for the MarkdownFile class here will be based upon the following text:\n\ntemplate_text = \"\"\"---\ncssclass: clean-embeds\naliases: []\ntags: [_meta/literature_note]\n---\n# Topic[^1]\n\n# See Also\n\n# Meta\n## References\n\n## Citations and Footnotes\n[^1]: Citation\"\"\"\n\n\ntext_1 = \"\"\"\n# Section 1\nsome text \n\nasdfasdf\n\n## Subsection a\nDidididi\nDododododo\n# Section 2\n\"\"\"\n\ntext_2 = \"\"\"---\ntags: [_meta/definition, _meta/concept, _auto/_meta/notation, this_tag_will_be_removed]\n---\n# Topic\nThis is some note with some stuff.\n\"\"\"\n\ntext_3 = \"\"\"\n# Section 1\nSome stuff\n\n#_meta/question Will `remove_in_line_tags` remove this line? Yes it will!\n\n# Hello\n\n #tag Will `remove_in_line_tags` remove this line? Yes it will!\n\"\"\"\n\ntext_4 = \"\"\"\n# Some thing\n\nI have a [[this is a note#this is an anchor in the note|link]]\n\n## Another topic\nThis is a link without a specified display text: [[some_kind_of_note]].\n\nThis is a link to an anchor without a specified display text: [[another_note#another anchor]].\n\"\"\"\n    \ntext_5 = \"\"\"# A header\n![[This note is embedded]].\n\nThe link above should will not be replaced by `replace_links_with_display_text`,\nunless `remove_embedded_note_links` is set to `True`.\"\"\"\n    \ntext_6 = \"\"\"\n# Header\n\nI want to link to some embedded note[^1]\n\n[^1]: ![[link_to_embedded_note_1]]\n\nYou can also let the footnote mention be alphanumeric[^1][^note]\n\n[^note]: ![[link_to_embedded_note_2]]\n\"\"\"\n    \ntext_7 = r\"\"\"---\ncssclass: clean-embeds\naliases: []\ntags: [_meta/concept, _meta/literature_note]\n---\n# Grothendieck-Witt ring elements of a finite field are given by rank and discriminant up to squares[^1]\n\n$\\operatorname{GW}(\\mathbb{F}_q)\\cong \\mathbb{Z}\\times \\mathbb{F}_q^{\\times}/(\\mathbb{F}_q^{\\times})^2$[^2] where the isomorphism is given by the rank and discriminant.\n\n\n[^2]: ![[notation_GW_k_Grothendieck_Witt_ring_of_a_field]]\n\n\n# See Also\n- [[grothendieck_witt_ring_of_a_polynomial_ring_over_a_field_is_isomorphic_to_that_of_the_field]]\n\n# Meta\n## References\n![[_reference_pauli_wickelgren_aa1]]\n\n\n## Citations and Footnotes\n[^1]: Pauli, Wickelgren, Example 3.7, Page 4\"\"\"\n\n\ntext_8 = r\"\"\"---\ncssclass: clean-embeds\n---\n# Topic[^1]\nHere is a LaTeX Equation:\n\n$$ 5 \\neq 7$$\nHey\nOkay, now here is another one:\n$$\\begin{align*}\n\\sum_{k=1}^n k = \\frac{n(n+1)}{2}\n\\end{align*}$$\n\nThe comment is not visible.\nThis is the end of the comment %%\n\nThis is the end of this note. This is visible.\n\"\"\"\n\ntext_9 = r\"\"\"\nThis LaTeX Equation has `**` surrounding it:\n**$$\\mathcal{O}_X$$**\n\nThis LaTeX Equation has an id:\n$$5 \\neq 7$$ ^221b51\n\nThis LaTeX Equation also has an id:\n$$5 \\neq 7\n$$ ^221b51\nThis is the end\n\"\"\"\n\ntext_10 = r\"\"\"This is a single line display math mode LaTeX equation:\n\n$$\\mathcal{O}_X$$\n\nThis is a single multi-line display math mode LaTeX equation:\n\n$$\n5 + 2 = 7\n$$\n\nThese are multiple consecutive display math mode LaTeX equations:\n\n$$1+1 = 2\n$$\n$$5 + 7 = 14$$\n$$\n\n8 + 4 = 12\n\n$$\n\"\"\"\n\ntext_11 = r\"\"\"$$asdf$$\n$$asdf$$\n$$asdf$$\nAfter text.\"\"\"\n\ntext_12 = r\"\"\"\n\n\"\"\"\n\nWe also use the multiple example vaults.\nThe following vault will be used mainly for some basic file interactions of the MarkdownFile class.\n.\n└── algebraic_geometry\n    ├── a1_homotopy_theory\n    │   ├── pauli_wickelgren_aa1\n    │   │   ├── 3_the_grothendieck_witt_ring_of_k\n    │   │   │   └── pauli_wickelgren_aa1_example 3.7.md\n    │   │   └── _index_pauli_wickelgren_aa1.md\n    |   └── _index_a1_homotopy_theory.md\n    └── _index_algebraic_geometry.md\npauli_wickelgren_aa1_example 3.7.md will contain the contents of text_7.\n\ndef make_example_vault(temp_dir: PathLike):\n    temp_dir = Path(temp_dir)\n    os.mkdir(temp_dir / 'algebraic_geometry')\n    os.mkdir(temp_dir / 'algebraic_geometry' / 'a1_homotopy_theory')\n    os.mkdir(temp_dir / 'algebraic_geometry' / 'a1_homotopy_theory' / 'pauli_wickelgren_aa1')\n    os.mkdir(temp_dir / 'algebraic_geometry' / 'a1_homotopy_theory' / 'pauli_wickelgren_aa1' / '3_the_grothendieck_witt_ring_of_k')\n\n    (temp_dir / 'algebraic_geometry' / '_index_algebraic_geometry.md').touch()\n    (temp_dir / 'algebraic_geometry' / 'a1_homotopy_theory' / '_index_a1_homotopy_theory.md').touch()\n    (temp_dir / 'algebraic_geometry' / 'a1_homotopy_theory' / 'pauli_wickelgren_aa1' / '_index_pauli_wickelgren_aa1.md').touch()\n    (temp_dir / 'algebraic_geometry' / 'a1_homotopy_theory' / 'pauli_wickelgren_aa1' / '3_the_grothendieck_witt_ring_of_k' / 'pauli_wickelgren_aa1_example 3.7.md').touch()\n\n    with open((temp_dir / 'algebraic_geometry' / 'a1_homotopy_theory' / 'pauli_wickelgren_aa1' / '3_the_grothendieck_witt_ring_of_k' / 'pauli_wickelgren_aa1_example 3.7.md'), 'w') as writer:\n        writer.write(\n            text_7\n        )\n\n# with tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n#     make_example_vault(temp_dir)\n#     os.startfile(os.getcwd())\n#     input()\n\nWe use the following example vault to demonstrate examples of embedded notes and other functionalities:\n.\n├── note_which_becomes_entirely_embedded_1.md\n├── note_with_embedded_links_1.md\n└── note_with_paragraphs_that_are_embedded_1.md\n\ndef make_example_vault_2(temp_dir: PathLike):\n    temp_dir = Path(temp_dir)\n\n    file_1 = temp_dir / 'note_which_becomes_entirely_embedded_1.md'\n    file_2 = temp_dir / 'note_with_embedded_links_1.md'\n    file_3 = temp_dir / 'note_with_paragraphs_that_are_embedded_1.md'\n\n    file_1.touch()\n    file_2.touch()\n    file_3.touch()\n\n    with open(file_1, 'w') as writer:\n        writer.write(\n            r\"\"\"Hello, this is a note which becomes entirely embedded.\n\nThe comment is not visible.\nThis is the end of the comment %%\"\"\"\n        )\n        \n    with open(file_2, 'w') as writer:\n        writer.write(\n            r\"\"\"This is a note.\n\nThere are some embedded text here:\n\n![[note_which_becomes_entirely_embedded_1]]\n\n\n![[note_with_paragraphs_that_are_embedded_1#^65809f]]\n\n![[note_with_paragraphs_that_are_embedded_1#^221b51]]\n\n![[note_with_paragraphs_that_are_embedded_1#Section]]\"\"\"\n        )\n\n    \n    with open(file_3, 'w') as writer:\n        writer.write(\n            r\"\"\"This paragraph becomes embedded.\n\n# Thank you for watching \ncheese \nbandit\n$$asdf$$\nasdf \n^65809f\n\n\n\nThis paragraph has not id.\n\n$$5 \\neq 7\n$$ \n^221b51\n\n# This section has an id ^123456\n\n# This section has no id \n^fff123\n\n$$\\mathcal{O}_X$$  ^latexthing\n\n# Section\nSome kind of section?\n\nLalalala\n## Subsection\nargonaut\n# Section\nMaybe?\n\"\"\")",
    "crumbs": [
      "markdown.markdown.file"
    ]
  },
  {
    "objectID": "markdown.markdown.file.html#constructing-a-markdownfile-object",
    "href": "markdown.markdown.file.html#constructing-a-markdownfile-object",
    "title": "markdown.markdown.file",
    "section": "Constructing a MarkdownFile object",
    "text": "Constructing a MarkdownFile object\n\nsource\n\nMarkdownFile.from_vault_note\n\n MarkdownFile.from_vault_note\n                               (vn:trouver.markdown.obsidian.vault.VaultNo\n                               te)\n\n*Return a MarkddownFile object from a VaultNote object.\nRaises - FileNotFoundError - If vn represents a note file which does not exist.*\n\nsource\n\n\nMarkdownFile.from_file\n\n MarkdownFile.from_file (file_path:os.PathLike)\n\n*Return a MarkdownFile object from a specified file.\nRaises - FileNotFoundError - If file_path points to a file which does not exist.*\n\nsource\n\n\nMarkdownFile.from_list\n\n MarkdownFile.from_list (list_of_lines:list[str])\n\n*Return a MarkdownFile object from a list of lines.\nThis may not work correctly if the markdown text is not sufficiently well-formatted. These formattings include: - comments must start the line with '%%'. - comments must end with '%%' followed by whitespaces and nothing else. - indents should be done with tabs?*\n\nsource\n\n\nMarkdownFile.from_string\n\n MarkdownFile.from_string (text:str)\n\nReturn a MarkdownFile object from a str.\nThe most convenient way to construct a MarkdownFile object is by the MarkdownFile.from_vault_note factory method.\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir_', dir=os.getcwd()) as temp_dir:\n    make_example_vault(temp_dir)\n\n    vault_note = VaultNote(temp_dir, name='pauli_wickelgren_aa1_example 3.7')\n    mf = MarkdownFile.from_vault_note(vault_note)\n    test_eq(str(mf), text_7)\n\n    vault_note = VaultNote(temp_dir, rel_path='does_not_exist.md')\n    assert not vault_note.exists()\n    with ExceptionExpected(ex=FileNotFoundError):\n        mf = MarkdownFile.from_vault_note(vault_note)\n\nWe can similarly construct a MarkdownFile by the MarkdownFile.from_file factory method without having to use a VaultNote object.\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir_', dir=os.getcwd()) as temp_dir:\n    make_example_vault(temp_dir)\n\n    temp_dir = Path(temp_dir)\n    mf = MarkdownFile.from_file(temp_dir / 'algebraic_geometry' / 'a1_homotopy_theory' / 'pauli_wickelgren_aa1' / '3_the_grothendieck_witt_ring_of_k' / 'pauli_wickelgren_aa1_example 3.7.md')\n\n    assert not os.path.exists(temp_dir / 'does_not_exist.md')\n    with ExceptionExpected(ex=FileNotFoundError):\n        mf = MarkdownFile.from_file(temp_dir / 'does_not_exist.md')\n\nIf the list of lines of the Markdown file are available, then the MarkdownFile.from_list factory method can be used.\nSimilarly, if the entire string of the Markdown file is available, then the MarkdownFile.from_str factory method can be used.\n\nlist_of_lines = template_text.splitlines()\ntemplate_mf_1 = MarkdownFile.from_list(list_of_lines)\ntemplate_mf_2 = MarkdownFile.from_string(template_text)\n\nprint(str(template_mf_1))\ntest_eq(str(template_mf_1), str(template_mf_2))\n\n---\ncssclass: clean-embeds\naliases: []\ntags: [_meta/literature_note]\n---\n# Topic[^1]\n\n# See Also\n\n# Meta\n## References\n\n## Citations and Footnotes\n[^1]: Citation",
    "crumbs": [
      "markdown.markdown.file"
    ]
  },
  {
    "objectID": "markdown.markdown.file.html#getting-headings-of-a-markdownfile-object",
    "href": "markdown.markdown.file.html#getting-headings-of-a-markdownfile-object",
    "title": "markdown.markdown.file",
    "section": "Getting headings of a MarkdownFile object",
    "text": "Getting headings of a MarkdownFile object\nIn a Markdown file, one can set headings. In fact, you can consider the text here as text rendered with Markdown! More generally, you can type Markdown in Jupyter notebooks.\nFor example, typing the following text\nThere are multiple methods in the MarkdownFile class which retrieve the headings of a Markdown file and their locations.\n\ntemplate_mf = MarkdownFile.from_string(template_text)\n\n\nsource\n\nMarkdownFile.get_headings\n\n MarkdownFile.get_headings (levels:Union[int,Iterator[int],NoneType]=None,\n                            include_start:bool=True)\n\nReturn a list of heading titles in the markdown file.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nlevels\nUnion\nNone\nThe levels of the headings to search for. Each int is between 1 and 6 inclusive, as each heading can be of levels 1 to 6. Defaults to None, in which case all heading-levels are searched.\n\n\ninclude_start\nbool\nTrue\nIf True and if this object contains text that is not under a heading (i.e. the text does not start with a heading), then include -1 as a key with the empty str as value.\n\n\nReturns\nlist\n\nEach str is the heading, including leading sharps '#'.\n\n\n\nThe get_headings function returns only a list of headings.\n\nprint(template_mf.get_headings())\nassert template_mf.get_headings() == [\n    '# Topic[^1]', '# See Also', '# Meta', '## References', '## Citations and Footnotes', '']\n\nassert template_mf.get_headings((3,4,6), include_start=True) == ['']\n\n['# Topic[^1]', '# See Also', '# Meta', '## References', '## Citations and Footnotes', '']\n\n\nThe empty heading '' is returned when include_start=True and there is text belonging to no heading - this can only happen at the start of the Markdown file before any headings are specified. Any YAML frontmatter meta is considered as “text belonging to no heading”.\nSetting include_start=False excludes the empty heading altogether.\n\nassert template_mf.get_headings(include_start=False) == [\n    '# Topic[^1]', '# See Also', '# Meta', '## References', '## Citations and Footnotes']\n\nThe parameter levels specifies which level headings to return. The argument passed to levels does not affect whether or not the empty heading '' is included.\n\nassert template_mf.get_headings(levels=1, include_start=True) == [\n    '# Topic[^1]', '# See Also', '# Meta', '']\nassert template_mf.get_headings(levels=1, include_start=False) == [\n    '# Topic[^1]', '# See Also', '# Meta']\n# Since list(range(2,6)) == [2, 3, 4, 5], the below returns all headings of levels 2, 3, 4, 5.\nassert template_mf.get_headings(levels=range(2,6), include_start=True) == [\n    '## References', '## Citations and Footnotes', '']\n\n\nsource\n\n\nMarkdownFile.get_headings_by_line_number\n\n MarkdownFile.get_headings_by_line_number\n                                           (levels:Union[Iterator[int],int\n                                           ,NoneType]=None,\n                                           include_start:bool=True)\n\nReturn a dict of heading titles in the markdown file.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nlevels\nUnion\nNone\nThe levels of the headings to search for. Each int is between 1 and 6 inclusive, as each heading can be of levels 1 to 6. If None then all heading-levels are searched.\n\n\ninclude_start\nbool\nTrue\nIf True and if this object contains text that is not under a heading (i.e. the text does not start with a heading), then include -1 as a key with the empty str as value.\n\n\nReturns\ndict\n\nThe keys are line numbers and each value is str is the heading string, including the leading sharps '#', but without any leading or trailing whitespace characters.\n\n\n\nThe get_headings_by_line_number function returns a dict whose keys are line numbers to headers and whose corresponding values are the full header str.\nSimilarly as with get_headings, setting include_start=True includes the empty header; the corresponding line number is always -1.\n\nline_numbers_and_headings = template_mf.get_headings_by_line_number()\nprint(line_numbers_and_headings)\nassert line_numbers_and_headings == {\n5: '# Topic[^1]',\n 7: '# See Also',\n 9: '# Meta',\n 10: '## References',\n 12: '## Citations and Footnotes',\n -1: ''}\n\nassert template_mf.get_headings_by_line_number(include_start=False) == {\n5: '# Topic[^1]',\n 7: '# See Also',\n 9: '# Meta',\n 10: '## References',\n 12: '## Citations and Footnotes', }\n\n{5: '# Topic[^1]', 7: '# See Also', 9: '# Meta', 10: '## References', 12: '## Citations and Footnotes', -1: ''}\n\n\n\n# TODO: add more examples\n\n\nsource\n\n\nMarkdownFile.get_headings_and_text\n\n MarkdownFile.get_headings_and_text\n                                     (levels:Union[Iterator[int],int,NoneT\n                                     ype]=None, include_start:bool=True)\n\n*Return a list of headings and the text under each heading.\nThe text under each heading does not include the text of subheadings.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nlevels\nUnion\nNone\nThe levels of the headings to search for. Each int is between 1 and 6 inclusive, as each heading can be of levels 1 to 6. If None, then all heading-levels are searched.\n\n\ninclude_start\nbool\nTrue\nIf True and if this object contains text that is not under a heading (i.e. the text does not start with a heading), then include -1 as a key with the empty str as value.\n\n\nReturns\ndict\n\nEach key is the entire str of the heading, including the leading sharps '#', but not including leading or trailing whitespace characters Each value is the str under that heading until the next heading, including at trailing next line characters \\n. If include_start is True, then one of the keys is the empty str and the corresponding value is the start of the text that is not under any heading.\n\n\n\nThe get_headings_and_text function returns a dict whose keys are full headers and whose values are text under the headers.\n\nheadings_and_text = template_mf.get_headings_and_text()\nprint(headings_and_text)\nassert headings_and_text == { '': '---\\ncssclass: clean-embeds\\naliases: []\\ntags: [_meta/literature_note]\\n---',\n '# Topic[^1]': '',\n '# See Also': '',\n '# Meta': '',\n '## References': '',\n '## Citations and Footnotes': '[^1]: Citation' }\n\nprint(template_mf.get_headings_and_text(None, False))\nassert template_mf.get_headings_and_text(None, False) == {\n '# Topic[^1]': '',\n '# See Also': '',\n '# Meta': '',\n '## References': '',\n '## Citations and Footnotes': '[^1]: Citation' }\n\n{'': '---\\ncssclass: clean-embeds\\naliases: []\\ntags: [_meta/literature_note]\\n---', '# Topic[^1]': '', '# See Also': '', '# Meta': '', '## References': '', '## Citations and Footnotes': '[^1]: Citation'}\n{'# Topic[^1]': '', '# See Also': '', '# Meta': '', '## References': '', '## Citations and Footnotes': '[^1]: Citation'}\n\n\n\n# TODO: add more examples\n\n\nsource\n\n\nMarkdownFile.get_headings_tree\n\n MarkdownFile.get_headings_tree ()\n\n*Return a dict representing the tree of headings in the markdown file.\nReturns\n\ndict[Union[str, int], Union[str, dict]]\n\nThe keys are 1. line numbers or 2. the str 'title'. The values are dict or str (the blank str if root node) respectively. The dicts in themselves recursively represent trees and the str are headings, including the leading sharps. In particular, the root level dict also has the blank string '' associated to the key 'title'.*\n\n\n\nheadings_tree = template_mf.get_headings_tree()\nprint(headings_tree)\nassert headings_tree == {\n    'title': '',\n    5: {'title': '# Topic[^1]'},\n    7: {'title': '# See Also'},\n    9: {'title': '# Meta',\n        10: {'title': '## References'},\n        12: {'title': '## Citations and Footnotes'}\n        }\n}\n\n{'title': '', 5: {'title': '# Topic[^1]'}, 7: {'title': '# See Also'}, 9: {'title': '# Meta', 10: {'title': '## References'}, 12: {'title': '## Citations and Footnotes'}}}\n\n\n\nsource\n\n\nMarkdownFile.get_line_number_of_heading\n\n MarkdownFile.get_line_number_of_heading (title:Optional[str]=None,\n                                          from_line:int=0, levels:Union[It\n                                          erator[int],int,NoneType]=None)\n\nReturn the line number of the heading with the specified title after the specified line number.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ntitle\nOptional\nNone\nTitle of the heading. Does not include the leading sharps ('#'). If None, then return the line number of any heading after the specified line number.\n\n\nfrom_line\nint\n0\nThe line number to start searching for the heading with title from.\n\n\nlevels\nUnion\nNone\nThe levels of the heading to search for. Each int is between 1 and 6 inclusive, as each heading can be of levels 1 to 6. If None, then all heading-levels are searched.\n\n\nReturns\nint\n\nAn index in self.parts. If no index/line number of the matching heading exists, then return -1.\n\n\n\nNote that the argument to title does not include the starting hashtags #.\n\nline_number = template_mf.get_line_number_of_heading(title='See Also')\nassert line_number == 7\n\nIf the heading of the specified title does not exist, then -1 is returned.\n\nassert template_mf.get_line_number_of_heading(title='Nonexistent title') == -1\n\nWe can search for headers of specified titles from specified lines onward:\n\nassert template_mf.get_line_number_of_heading(title='Topic[^1]', from_line=3) == 5\nassert template_mf.get_line_number_of_heading(title='Topic[^1]', from_line=6) == -1\n\nWe can also specify the levels that the header must be:\n\nassert template_mf.get_line_number_of_heading(title='Topic[^1]', levels=(1,2,6)) == 5\nassert template_mf.get_line_number_of_heading(title='Topic[^1]', levels=(3, 5)) == -1\n\n\nsource\n\n\nMarkdownFile.get_line_numbers_under_heading\n\n MarkdownFile.get_line_numbers_under_heading (title:Optional[str]=None,\n                                              from_line:int=0, levels:Unio\n                                              n[Iterator[int],int,NoneType\n                                              ]=None, include_subheadings:\n                                              bool=True)\n\nReturn the line numbers belonging to the heading.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ntitle\nOptional\nNone\nTitle of the heading. Does not include the leading sharps ('#'). If None, then return the line number of any heading after the specified line number.\n\n\nfrom_line\nint\n0\nThe line number to start searching for the heading with title from.\n\n\nlevels\nUnion\nNone\nThe levels of the heading to search for. Each int is between 1 and 6 inclusive, as each heading can be of levels 1 to 6. If None, then all heading-levels are searched.\n\n\ninclude_subheadings\nbool\nTrue\nIf True, then include the subheadings.\n\n\nReturns\nUnion\n\n(start, end) where self.parts[start:end] represents the parts under the heading, including the start of the heading. If the heading of the specified title does not exist, then returns -1.\n\n\n\n\nprint(template_text)\ntemplate_mf = MarkdownFile.from_string(template_text)\nassert template_mf.get_line_numbers_under_heading(title='Topic[^1]') == (5,7)\nassert template_mf.get_line_numbers_under_heading(title='See Also') == (7,9)\nassert template_mf.get_line_numbers_under_heading(title='Meta') == (9,14)\nassert template_mf.get_line_numbers_under_heading(title='References') == (10,12)\nassert template_mf.get_line_numbers_under_heading(title='Citations and Footnotes') == (12,14)\n\n---\ncssclass: clean-embeds\naliases: []\ntags: [_meta/literature_note]\n---\n# Topic[^1]\n\n# See Also\n\n# Meta\n## References\n\n## Citations and Footnotes\n[^1]: Citation\n\n\nIf include_subheadings=False, then the line numbers for only the section without any subsections is returned.\n\nassert template_mf.get_line_numbers_under_heading(title='Topic[^1]', include_subheadings=False) == (5,7)\nassert template_mf.get_line_numbers_under_heading(title='See Also', include_subheadings=False) == (7,9)\nassert template_mf.get_line_numbers_under_heading(title='Meta', include_subheadings=False) == (9,10)\nassert template_mf.get_line_numbers_under_heading(title='References', include_subheadings=False) == (10,12)\nassert template_mf.get_line_numbers_under_heading(title='Citations and Footnotes', include_subheadings=False) == (12,14)",
    "crumbs": [
      "markdown.markdown.file"
    ]
  },
  {
    "objectID": "markdown.markdown.file.html#addingremoving-lines-in-a-markdownfile-object",
    "href": "markdown.markdown.file.html#addingremoving-lines-in-a-markdownfile-object",
    "title": "markdown.markdown.file",
    "section": "Adding/removing lines in a MarkdownFile object",
    "text": "Adding/removing lines in a MarkdownFile object\n\n# TODO examples of insert_line, remove_line, pop_line, add_line_to_end, add_blank_line_to_end, add_line_in_section\n\n\nsource\n\nMarkdownFile.insert_line\n\n MarkdownFile.insert_line (index:int,\n                           line_dict:dict[str,typing.Union[__main__.Markdo\n                           wnLineEnum,str]])\n\nAdd a line at the specified index/line number to self.parts.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nindex\nint\nThe index at which to add line_dict into self.parts.\n\n\nline_dict\ndict\nSee self.parts.\n\n\nReturns\nNone\n\n\n\n\n\nsource\n\n\nMarkdownFile.remove_line\n\n MarkdownFile.remove_line (index:int=-1)\n\nRemove a line from self.parts.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nindex\nint\n-1\nThe index of the line to remove from self.parts.\n\n\nReturns\nNone\n\n\n\n\n\n\nsource\n\n\nMarkdownFile.remove_lines\n\n MarkdownFile.remove_lines (start:int, end:int)\n\nRemove lines from self.parts.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nstart\nint\nThe index of the first line to remove from self.parts.\n\n\nend\nint\nThe end index to remove; the line of index end is not removed, but the line of index end - is.\n\n\nReturns\nNone\n\n\n\n\n\nsource\n\n\nMarkdownFile.pop_line\n\n MarkdownFile.pop_line (index:int=-1)\n\nRemove a line from self.parts and get its value.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nindex\nint\n-1\nThe index of the line to pop from self.parts.\n\n\nReturns\ndict\n\nThe popped line\n\n\n\n\nsource\n\n\nMarkdownFile.add_line_to_end\n\n MarkdownFile.add_line_to_end\n                               (line_dict:dict[str,typing.Union[__main__.M\n                               arkdownLineEnum,str]])\n\nAdd a line to the end of self.parts.\n\n\n\n\nType\nDetails\n\n\n\n\nline_dict\ndict\nSee self.parts.\n\n\nReturns\nNone\n\n\n\n\n\nsource\n\n\nMarkdownFile.add_blank_line_to_end\n\n MarkdownFile.add_blank_line_to_end ()\n\nAdd a blank line to the end of self.parts.\n\nsource\n\n\nMarkdownFile.add_line_in_section\n\n MarkdownFile.add_line_in_section (title:str,\n                                   line_dict:dict[str,typing.Union[__main_\n                                   _.MarkdownLineEnum,str]],\n                                   start:bool=True)\n\nAdd a line in section specified by its title.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ntitle\nstr\n\nTitle of the heading (without the leading sharps '#')\n\n\nline_dict\ndict\n\nThe line to add\n\n\nstart\nbool\nTrue\nIf True, add to the start of the section. If False, add to the end of the section.\n\n\nReturns\nNone",
    "crumbs": [
      "markdown.markdown.file"
    ]
  },
  {
    "objectID": "markdown.markdown.file.html#removing-or-clearing-sections-in-a-markdownfile-object",
    "href": "markdown.markdown.file.html#removing-or-clearing-sections-in-a-markdownfile-object",
    "title": "markdown.markdown.file",
    "section": "Removing or clearing sections in a MarkdownFile object",
    "text": "Removing or clearing sections in a MarkdownFile object\n\nsource\n\nMarkdownFile.remove_section\n\n MarkdownFile.remove_section (title:str)\n\nRemove the section with the specified title, including subsections, if the section exists.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ntitle\nstr\nThe title of the section to remove (without the starting '#'’s)\n\n\nReturns\nNone\n\n\n\n\nThe remove_section method removes all lines belonging to a section, including subsections.\n\n# TODO remove_section, clear_section, clear_all_sections\ntemplate_mf = MarkdownFile.from_string(template_text)\ntemplate_mf.remove_section('Topic[^1]')\nassert len(template_mf.parts) == 12\ntemplate_mf.remove_section('Meta')  # This removes subsections too!\nassert str(template_mf) == \"\"\"---\ncssclass: clean-embeds\naliases: []\ntags: [_meta/literature_note]\n---\n# See Also\n\"\"\"\n\nAttempting to remove a Non-existent section does nothing.\n\nmf_2 = MarkdownFile.from_string(template_text)\nmf_2.remove_section('Non existing section')\nassert str(mf_2), template_text\n\n\nsource\n\n\nMarkdownFile.clear_section\n\n MarkdownFile.clear_section (title:str, leave_blank_line:bool=True,\n                             clear_subsections:Optional[str]=None)\n\n*Clear the section with the specified title, if it exists.\nDoes not clear subsections.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ntitle\nstr\n\nTitle of the section (Without the leading sharps '#')\n\n\nleave_blank_line\nbool\nTrue\nIf True, leaves a blank line at the end of the section.\n\n\nclear_subsections\nOptional\nNone\n'clear', 'delete', or None. If 'clear', then just clears the contents of subsections, but does not affect the headers. If 'delete', then clears the contents of the subsections and deletes the headers. If None, then does not affect either.\n\n\nReturns\nNone\n\n\n\n\n\n\nmf = MarkdownFile.from_string(text_1)\nmf.clear_section('Section 1', leave_blank_line=True)\nheadings_and_text = mf.get_headings_and_text()\nassert headings_and_text['# Section 1'] == ''\nassert mf.get_line_number_of_heading('Subsection a') == 3\nassert mf.parts[4]['line'] == 'Didididi'\nprint(mf)\n\n\n# Section 1\n\n## Subsection a\nDidididi\nDododododo\n# Section 2\n\n\nSetting leave_blank_line=False leaves no blank line between the section and the next:\n\nmf = MarkdownFile.from_string(text_1)\nmf.clear_section('Section 1', leave_blank_line=False)\nheadings_and_text = mf.get_headings_and_text()\nassert headings_and_text['# Section 1'] == ''\nassert mf.get_line_number_of_heading('Subsection a') == 2\nassert mf.parts[3]['line'] == 'Didididi'\nprint(mf)\n\n\n# Section 1\n## Subsection a\nDidididi\nDododododo\n# Section 2\n\n\n\nsource\n\n\nMarkdownFile.clear_all_sections\n\n MarkdownFile.clear_all_sections (leave_blank_lines:bool=True)\n\n*Clear all sections.\nDoes not clear frontmatter metadata. Leaves all headers intact.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nleave_blank_lines\nbool\nTrue\n\n\n\nReturns\nNone\n\nIf True, leaves a blank line in each section\n\n\n\n\nmf = MarkdownFile.from_string(text_1)\nmf.clear_all_sections(leave_blank_lines=True)\nassert len(mf.parts) == 3\nprint(mf)\n\n# Section 1\n## Subsection a\n# Section 2",
    "crumbs": [
      "markdown.markdown.file"
    ]
  },
  {
    "objectID": "markdown.markdown.file.html#metadata-in-a-markdownfile-object",
    "href": "markdown.markdown.file.html#metadata-in-a-markdownfile-object",
    "title": "markdown.markdown.file",
    "section": "Metadata in a MarkdownFile object",
    "text": "Metadata in a MarkdownFile object\nHere are some things that we can do with a MarkdownFile object with frontmatter YAML metadata:\n\ntemplate_mf = MarkdownFile.from_string(template_text)\nprint (template_mf.metadata(), '\\n')\nassert template_mf.metadata() == {'cssclass': 'clean-embeds', 'aliases': [], 'tags': ['_meta/literature_note']}\nassert template_mf.has_metadata()\nassert template_mf.metadata_lines() == (0, 4)\n\n\nnew_metadata = {'aliases': ['an_awesome_note', 'no_more_cssclass', 'no_more_tags']}\ntemplate_mf.replace_metadata(new_metadata)\nprint('The following is the MarkdownFile with new frontmatter YAML metadata:\\n')\nprint(template_mf, '\\n')\nassert str(template_mf) == \"\"\"---\naliases: [an_awesome_note, no_more_cssclass, no_more_tags]\n---\n# Topic[^1]\n\n# See Also\n\n# Meta\n## References\n\n## Citations and Footnotes\n[^1]: Citation\"\"\"\n\n\ntemplate_mf.remove_metadata()\nprint('The following is the MarkdownFile with frontmatter YAML metadata removed:\\n')\nprint(template_mf)\nassert str(template_mf) == \"\"\"# Topic[^1]\n\n# See Also\n\n# Meta\n## References\n\n## Citations and Footnotes\n[^1]: Citation\"\"\"\n\n{'cssclass': 'clean-embeds', 'aliases': [], 'tags': ['_meta/literature_note']} \n\nThe following is the MarkdownFile with new frontmatter YAML metadata:\n\n---\naliases: [an_awesome_note, no_more_cssclass, no_more_tags]\n---\n# Topic[^1]\n\n# See Also\n\n# Meta\n## References\n\n## Citations and Footnotes\n[^1]: Citation \n\nThe following is the MarkdownFile with frontmatter YAML metadata removed:\n\n# Topic[^1]\n\n# See Also\n\n# Meta\n## References\n\n## Citations and Footnotes\n[^1]: Citation\n\n\nNote that if the MarkdownFile does not have any YAML frontmatter metadata, then the metadata method returns None:\n\nmf_1 = MarkdownFile.from_string(text_1)\nassert mf_1.metadata() is None\n\nIf the MarkdownFile’s YAML frontmatter metadata has formatting issues then metadata raises a ValueError. In actuality, the error message also yields the appropraite yaml.YAMLError in the PyYAML library, e.g. yaml.parser.ParserError, yaml.scanner.ScannerError, or yaml.reader.ReaderError.\n\ntext_with_bad_yaml = \"---\\nsome_metadata_field: [\\badly_formatted_string]\\n---\\nThe rest of the note contents...\"\nmf = MarkdownFile.from_string(text_with_bad_yaml)\nwith ExceptionExpected(ValueError): # By virtue of giving a ReaderError\n    mf.metadata()\n\n\ntext_with_bad_yaml = \"---\\nfield: field2: \\n---\\nThe rest of the note contents...\"\nmf = MarkdownFile.from_string(text_with_bad_yaml)\nwith ExceptionExpected(ValueError): # By virtue of giving a ScannerError\n    mf.metadata()\n\n\ntext_with_bad_yaml = \"---\\nfield: John\\n- field2: Mary \\n---\\nThe rest of the note contents...\"\nmf = MarkdownFile.from_string(text_with_bad_yaml)\nwith ExceptionExpected(ValueError): # By virtue of giving a ParserError\n    mf.metadata()\n\n\nsource\n\nMarkdownFile.has_metadata\n\n MarkdownFile.has_metadata ()\n\n*Return True if this MarkdownFile object has fronmatter YAML metadata.\nIf the MarkdownFile object has any frontmatter YAML metadata, then it is expected to be at the very start; in particular, it must not be preceded by any whitespace characters.*\n\nsource\n\n\nMarkdownFile.metadata_lines\n\n MarkdownFile.metadata_lines ()\n\n*Return the indices in self.parts which are metadata.\nAssumes that self.parts is nonempty.\nIf the MarkdownFile object has any frontmatter YAML metadata, then it is expected to be at the very start; in particular, it must not be preceded by any whitespace characters.\nReturns\n\ntuple\n\nThe tuple consists of 2 ints, a and b, where self.parts[a:b+1] represent the metadata lines, including the '---' before and after.*\n\n\n\nsource\n\n\nMarkdownFile.replace_metadata\n\n MarkdownFile.replace_metadata (new_metadata:dict[str],\n                                enquote_entries_in_fields:list[str]=[])\n\n*Replace the frontmatter metadata of this MarkdownFile object.\nOptionally also enquotes string entries in fields specified by enquote_entries_in_fields.\nWarning - This method is only tested when the values of new_metadata are either str or list[str].*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nnew_metadata\ndict\n\nThe dictionary representing the new metadata. The keys are the names of fields. The values are the field values, usually expected to be a single string or a list of strings\n\n\nenquote_entries_in_fields\nlist\n[]\nA list of str of fields in the YAML metadata whose entries need to be enquoted. If there is a string that is not a key of new_metadata, then that string is essentially ignored (in particular, no errors are raised).\n\n\nReturns\nNone\n\n\n\n\n\n\n# TODO: basic example\n\nIn the case that the metadata comprises of strings which need to be escaped (because they have backslashes), then the enquote_entries_in_fields parameter of the MarkdownFile.replace_metadata method can be specified to enquote and escape such strings, cf. dict_to_metadata_lines.\nIn particular, the MarkdownFile.replace_metadata method with the MarkdownFile object’s own .metadata() passed in the following example should ideally not modify the string of the MarkdownFile object. This feature needs to be tested with more examples, however.\n\nmf = MarkdownFile.from_string(\n    r'''---\nlatex_in_original: [\"\\\\mathscr{O}_{\\\\text {Proj } S_{*}}(n)\"]\n---\n\n''')\n\noriginal_metadata = mf.metadata()\noriginal_str = str(mf).strip()\n\ndict_to_metadata_lines(mf.metadata(), enquote_entries_in_fields=['latex_in_original'])\nmf.replace_metadata(mf.metadata(), enquote_entries_in_fields=['latex_in_original'])\n\ntest_eq(mf.metadata(), original_metadata)\ntest_eq(str(mf).strip(), original_str)\n\nMultiple methods in the MarkdownFile class, including MarkdownFile.add_tags, MarkdownFile.remove_tags, and MarkdownFile.replace_auto_tags_with_regular_tags depend on the MarkdownFile.replace_metadata method. Arguments for the enquote_entries_in_metadata_fields must be specified appropriately when using these methods.\n\nsource\n\n\nMarkdownFile.remove_metadata\n\n MarkdownFile.remove_metadata ()\n\nRemove the frontmatter metadata of this MarkdownFile object.\n\nsource\n\n\nMarkdownFile.add_metadata_section\n\n MarkdownFile.add_metadata_section (check_exists:bool=True)\n\nAdd a frontmatter YAML metadata at the very beginning.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncheck_exists\nbool\nTrue\nIf True, Check if there is already a metadata section at the beginning and do not add a metadata section if it exists.\n\n\nReturns\nNone\n\n\n\n\n\nIf the MarkdownFile has no frontmatter YAML metadata, then we can use the add_metadata_section method to add blank frontmatter YAML metadata:\n\nmf = MarkdownFile.from_string(text_1)\nassert not mf.has_metadata()\nmf.add_metadata_section()\nprint(mf)\n\n---\n\n---\n\n\n# Section 1\nsome text \n\nasdfasdf\n\n## Subsection a\nDidididi\nDododododo\n# Section 2\n\n\nIf the MarkdownFile object already has frontmatter YAML metadata, then the add_metadata_section method does nothing.\n\ntemplate_mf = MarkdownFile.from_string(template_text)\nmf.add_metadata_section()\nassert str(template_mf) == template_text",
    "crumbs": [
      "markdown.markdown.file"
    ]
  },
  {
    "objectID": "markdown.markdown.file.html#tags-in-markdownfile-objects",
    "href": "markdown.markdown.file.html#tags-in-markdownfile-objects",
    "title": "markdown.markdown.file",
    "section": "Tags in MarkdownFile objects",
    "text": "Tags in MarkdownFile objects\n\nYAML metadata tags\nIn Obsidian, one can add tags to notes both within text and in the frontmatter YAML metadata.\n\nsource\n\n\nMarkdownFile.has_tag\n\n MarkdownFile.has_tag (tag:str)\n\n*Return True if the Markdown file has the specified tag in its YAML frontmatter metadata.\nMore specifically, return True if the MarkdownFile objeect\n\nhas YAML frontmatter metadata,\nthe metadata has a 'tags' section,, and\nthe 'tags' section is a list with the specified tag.\n\nNote that tag should not start with the hashtag # charater.*\n\n\n\n\nType\nDetails\n\n\n\n\ntag\nstr\nThe tag. Does not start with the hashtag '#'.\n\n\nReturns\nbool\n\n\n\n\n\nsource\n\n\nMarkdownFile.add_tags\n\n MarkdownFile.add_tags (tags:Union[str,list[str]], skip_repeats:bool=True,\n                        skip_repeated_auto:bool=True,\n                        enquote_entries_in_metadata_fields:list[str]=[])\n\n*Add tags to the frontmatter metadata.\nThe order of the tags may be changed.\nUltimately the replace_metadata method is used to modify the YAML metadata. Use the enquote_entries_in_metadata_fields parameter to ensure that the replace_metadata invocation preserves enquoted metadata values.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ntags\nUnion\n\nThe str representing the tags. May or may not start with '#', e.g. '#_meta/definition' or '_meta/definition'.\n\n\nskip_repeats\nbool\nTrue\nIf True, then this MarkdownFile will just have unique tags; merges pre-existing repeated tags if necessary. Also, the order of the tags may be changed.\n\n\nskip_repeated_auto\nbool\nTrue\nIf True, then only add tags starting with ’_auto/’ if the corresponding non-auto tag does not exist, e.g. ’_auto/_meta/definition’ is not added if the note already has ’_meta/definition’.\n\n\nenquote_entries_in_metadata_fields\nlist\n[]\nA list of str of fields in the YAML metadata whose entries need to be enquoted. If there is a string that is not a key of new_metadata, then that string is essentially ignored (in particular, no errors are raised).\n\n\nReturns\nNone\n\n\n\n\n\n\nsource\n\n\nMarkdownFile.remove_tags\n\n MarkdownFile.remove_tags (tags:list[str],\n                           enquote_entries_in_metadata_fields:list[str]=[]\n                           )\n\n*Remove specified tags from the frontmatter metadata, if the frontmatter metadata and the specified tags.\nIf the MarkdownFile object does not have a frontmatter or if the frontmatter does not include a tags line, then the MarkdownFile object is not modified.\nAssumes that this MarkdownFile object has a frontmatter and that the frontmatter includes a tags line.\nAny repeated tags are either merged into one (if the tag is not in tags) or are removed (if the tag is in tags).\nUltimately the replace_metadata method is used to modify the YAML metadata. Use the enquote_entries_in_metadata_fields parameter to ensure that the replace_metadata invocation preserves enquoted metadata values.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ntags\nlist\n\nThe str representing the tags. May or may not start with '#', e.g. '#_meta/definition' or '_meta/definition'.\n\n\nenquote_entries_in_metadata_fields\nlist\n[]\nA list of str of fields in the YAML metadata whose entries need to be enquoted. If there is a string that is not a key of new_metadata, then that string is essentially ignored (in particular, no errors are raised).\n\n\nReturns\nNone\n\n\n\n\n\n\nmf = MarkdownFile.from_string(text_2)\nassert mf.has_tag('_meta/definition')\n\nmf.add_tags(['new_tag'])  #This may change the order of the tags.\nassert mf.has_tag('new_tag')\n\nassert mf.has_tag('this_tag_will_be_removed')\nmf.remove_tags(['this_tag_will_be_removed'])\nassert not mf.has_tag('this_tag_will_be_removed')\n\nassert not mf.has_tag('no_tag')\nmf.remove_tags(['no_tag']) # Does nothing\nassert not mf.has_tag('no_tag')\n\nprint(mf)\n\n---\ntags: [_meta/concept, new_tag, _meta/definition, _auto/_meta/notation]\n---\n# Topic\nThis is some note with some stuff.\n\n\nIf the MarkdownFile object does not have frontmatter YAML metadata or if its frontmatter YAML metadata does not have a tags section, then no changes are made to the MarkdownFile object:\n\n# Example of a MarkdownFile object without frontmatter YAML metadata:\nmf = MarkdownFile.from_string(text_1)\n\nmf_str_before = str(mf)\n\nassert mf.metadata() is None\nmf.remove_tags(['_meta/definition'])\nassert mf.metadata() is None\n\ntest_eq(str(mf), mf_str_before)\n\n# Example of a MarkdownFile object with frontmatter YAML metadata but without a tags section.\nmf = MarkdownFile.from_string(text_8)\n\nmf_str_before = str(mf)\n\nassert mf.metadata() is not None\nassert 'tag' not in mf.metadata() \nmf.remove_tags(['_meta/definition'])\n\ntest_eq(str(mf), mf_str_before)\n\nThe add_tags method has a skip_repeats parameter.\n\nmf.add_tags(['new_tag'], skip_repeats=True)  # Only one `new_tag` will be present after this.\nprint(mf)\nmf.add_tags(['new_tag'], skip_repeats=False)  # After this, mf will have 2 `new_tag`'s  # After this, mf will have 2 `new_tag`'s  # After this, mf will have 2 `new_tag`'s\nprint(mf)\nmf.add_tags(['new_tag'], skip_repeats=True)  # Only one `new_tag` will be present after this, even though there were multiple `new_tag`'s before this.\nprint(mf)\n\n---\ncssclass: clean-embeds\ntags: [new_tag]\n---\n# Topic[^1]\nHere is a LaTeX Equation:\n\n$$ 5 \\neq 7$$\nHey\nOkay, now here is another one:\n$$\\begin{align*}\n\\sum_{k=1}^n k = \\frac{n(n+1)}{2}\n\\end{align*}$$\n\n%%This is a comment. \nThe comment is not visible.\nThis is the end of the comment %%\n\nThis is the end of this note. This is visible.\n---\ncssclass: clean-embeds\ntags: [new_tag, new_tag]\n---\n# Topic[^1]\nHere is a LaTeX Equation:\n\n$$ 5 \\neq 7$$\nHey\nOkay, now here is another one:\n$$\\begin{align*}\n\\sum_{k=1}^n k = \\frac{n(n+1)}{2}\n\\end{align*}$$\n\n%%This is a comment. \nThe comment is not visible.\nThis is the end of the comment %%\n\nThis is the end of this note. This is visible.\n---\ncssclass: clean-embeds\ntags: [new_tag]\n---\n# Topic[^1]\nHere is a LaTeX Equation:\n\n$$ 5 \\neq 7$$\nHey\nOkay, now here is another one:\n$$\\begin{align*}\n\\sum_{k=1}^n k = \\frac{n(n+1)}{2}\n\\end{align*}$$\n\n%%This is a comment. \nThe comment is not visible.\nThis is the end of the comment %%\n\nThis is the end of this note. This is visible.\n\n\n\nsource\n\n\nMarkdownFile.replace_auto_tags_with_regular_tags\n\n MarkdownFile.replace_auto_tags_with_regular_tags (exclude:list[str]=None,\n                                                   enquote_entries_in_meta\n                                                   data_fields:list[str]=[\n                                                   ])\n\n*Replace tags in the frontmatter metadata starting with _auto/ with tags without the _auto/.\nUltimately the replace_metadata method is used to modify the YAML metadata. Use the enquote_entries_in_metadata_fields parameter to ensure that the replace_metadata invocation preserves enquoted metadata values.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nexclude\nlist\nNone\nThe tags whose _auto/ tags should not be converted. The str should not start with '#' and should not start with '_auto/'.\n\n\nenquote_entries_in_metadata_fields\nlist\n[]\nA list of str of fields in the YAML metadata whose entries need to be enquoted. If there is a string that is not a key of new_metadata, then that string is essentially ignored (in particular, no errors are raised).\n\n\nReturns\nNone\n\n\n\n\n\nOne can use / characters to create “subtags”. trouver recognizes _auto tags, which are tags that trouver adds to mark notes that it has processed in certain ways.\nFor example, trove.markdown.osidian.personal.machine_learning.tag_categorization can label the “types” of the content of information notes. For example, if this labelling process determines an information note to be a definition note, then it will add a _auto/_meta/definition tag, as opposed to a _meta/definition tag. This way, one can recognize that the tag was added automatically via a machine learning model and may be prone to error.\nThe replace_auto_tags_with_regular_tags replaces _auto tags with regular tags. This can be useful, for example, once tags for a multitude of notes have been verified.\n\nmf = MarkdownFile.from_string(text_2)\nassert mf.has_tag('_auto/_meta/notation')\nmf.replace_auto_tags_with_regular_tags()\nassert mf.has_tag('_meta/notation')\nassert not mf.has_tag(\"_auto/_meta/notation\")\nprint(mf)\n\n---\ntags: [_meta/definition, _meta/concept, _meta/notation, this_tag_will_be_removed]\n---\n# Topic\nThis is some note with some stuff.\n\n\n\ndisplay math mode tags\nThe difference between headers and display math mode tags is that the former has a space between the hashtags and the text and the latter does not. For example, # Header is a header and #tag is a tag.\n\nsource\n\n\n\nMarkdownFile.remove_in_line_tags\n\n MarkdownFile.remove_in_line_tags ()\n\nRemove lines starting with in line tags.\n\nmf = MarkdownFile.from_string(text_3)\nmf.remove_in_line_tags()\nprint(str(mf))\nprint(mf.parts)\nassert len(mf.parts) == 7\nassert str(mf) == \"\"\"\n# Section 1\nSome stuff\n\n\n# Hello\n\"\"\"\n\n\n# Section 1\nSome stuff\n\n\n# Hello\n\n[{'line': '', 'type': &lt;MarkdownLineEnum.BLANK_LINE: 9&gt;}, {'line': '# Section 1', 'type': &lt;MarkdownLineEnum.HEADING: 1&gt;}, {'line': 'Some stuff', 'type': &lt;MarkdownLineEnum.DEFAULT: 0&gt;}, {'line': '', 'type': &lt;MarkdownLineEnum.BLANK_LINE: 9&gt;}, {'line': '', 'type': &lt;MarkdownLineEnum.BLANK_LINE: 9&gt;}, {'line': '# Hello', 'type': &lt;MarkdownLineEnum.HEADING: 1&gt;}, {'line': '', 'type': &lt;MarkdownLineEnum.BLANK_LINE: 9&gt;}]\n\n\n\ntemplate_mf = MarkdownFile.from_string(template_text)\ntemplate_mf.remove_in_line_tags()\nassert str(template_mf) == template_text",
    "crumbs": [
      "markdown.markdown.file"
    ]
  },
  {
    "objectID": "markdown.markdown.file.html#extract-raw-content-from-a-markownfile-object",
    "href": "markdown.markdown.file.html#extract-raw-content-from-a-markownfile-object",
    "title": "markdown.markdown.file",
    "section": "Extract raw content from a MarkownFile object",
    "text": "Extract raw content from a MarkownFile object\nOne can add a multitude of meta-data to Obsidian Markdown notes - frontmatter metadata, headers/footers, links, embedded links, tags, etc.\nWe can extract raw content from notes by removing a combination of these meta-data.\nSee also remove_in_line_tags.\n\nsource\n\nMarkdownFile.replace_links_with_display_text\n\n MarkdownFile.replace_links_with_display_text\n                                               (remove_embedded_note_links\n                                               :bool=False)\n\nRemove nonembedded links and replaces them with their display text.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nremove_embedded_note_links\nbool\nFalse\nIf True, remove links to embedded notes as well. If False, does not modify embedded notes.`\n\n\nReturns\nNone\n\n\n\n\n\n\nmf = MarkdownFile.from_string(text_4)\nmf.replace_links_with_display_text()\nprint(str(mf))\nassert str(mf) == \"\"\"\n# Some thing\n\nI have a link\n\n## Another topic\nThis is a link without a specified display text: some_kind_of_note.\n\nThis is a link to an anchor without a specified display text: another_note &gt; another anchor.\"\"\"\n\n\n# Some thing\n\nI have a link\n\n## Another topic\nThis is a link without a specified display text: some_kind_of_note.\n\nThis is a link to an anchor without a specified display text: another_note &gt; another anchor.\n\n\nIf remove_embedded_note_links=True, then embedded links will be replaced with their “display text” as a link; they will not be replaced with the underlying embedded text.\n\nmf = MarkdownFile.from_string(text_5)\nmf.replace_links_with_display_text()\nassert str(mf) == text_5\n\nmf.replace_links_with_display_text(remove_embedded_note_links=True)\nprint(str(mf))\nassert str(mf) == \"\"\"# A header\nThis note is embedded.\n\nThe link above should will not be replaced by `replace_links_with_display_text`,\nunless `remove_embedded_note_links` is set to `True`.\"\"\"\n\n# A header\nThis note is embedded.\n\nThe link above should will not be replaced by `replace_links_with_display_text`,\nunless `remove_embedded_note_links` is set to `True`.\n\n\n\nsource\n\n\nMarkdownFile.remove_footnotes_to_embedded_links\n\n MarkdownFile.remove_footnotes_to_embedded_links\n                                                  (remove_footnote_mention\n                                                  s:bool=True)\n\n*Remove footnotes to embedded links.\nThese are footnotes whose only content are embedded links, e.g. [^1]: ![[embedded_note]]*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nremove_footnote_mentions\nbool\nTrue\nIf True, removes the mentions to the footnote to the embedded links in the text.\n\n\nReturns\nNone\n\n\n\n\n\nI very often use footnotes with only embedded links. We can remove such footnotes.\n\nmf = MarkdownFile.from_string(text_6)\nmf.remove_footnotes_to_embedded_links()\nassert str(mf) == \"\"\"\n# Header\n\nI want to link to some embedded note\n\n\nYou can also let the footnote mention be alphanumeric\n\"\"\"\n\nSetting remove_footnote_mentions=False removes the content of the footnotes themselves, but leaves the mentions intact:\n\nmf = MarkdownFile.from_string(text_6)\nmf.remove_footnotes_to_embedded_links(remove_footnote_mentions=False)\nassert str(mf) == \"\"\"\n# Header\n\nI want to link to some embedded note[^1]\n\n\nYou can also let the footnote mention be alphanumeric[^1][^note]\n\"\"\"\n\n\n# hide\nmf = MarkdownFile.from_string(text_7)\nmf.remove_footnotes_to_embedded_links(remove_footnote_mentions=True)\nassert '[^2]' not in str(mf)\n\n\nsource\n\n\nMarkdownFile.remove_headers\n\n MarkdownFile.remove_headers ()\n\nRemove all headers.\nWe can remove all of the headers and leave the rest of the text intact\n\nmf = MarkdownFile.from_string(template_text)\nmf.remove_headers()\nassert str(mf) == \"\"\"---\ncssclass: clean-embeds\naliases: []\ntags: [_meta/literature_note]\n---\n\n\n\n[^1]: Citation\"\"\"\n\nmf = MarkdownFile.from_string(text_1)\nmf.remove_headers()\nassert str(mf) == \"\"\"\nsome text \n\nasdfasdf\n\nDidididi\nDododododo\"\"\"\n\n\nsource\n\n\nMarkdownFile.remove_double_blank_lines\n\n MarkdownFile.remove_double_blank_lines ()\n\nRemove blank lines so that there are no consecutive blank lines\nWhen removing some of the “metadata”, the content of the note can be left with a lot of consecutive blank lines. To ensure that machine-learning models will not develop some kind of blank line bias, we can remove such consecutive blank lines.\n\nmf = MarkdownFile.from_string(template_text)\nmf.remove_headers()\nmf.remove_double_blank_lines()\nassert str(mf) == \"\"\"---\ncssclass: clean-embeds\naliases: []\ntags: [_meta/literature_note]\n---\n\n[^1]: Citation\"\"\"\n\n\nsource\n\n\nMarkdownFile.replace_embedded_links_with_text\n\n MarkdownFile.replace_embedded_links_with_text (vault:os.PathLike,\n                                                recursive:bool=True, remov\n                                                e_paragraph_id:bool=True)\n\n*Remove embedded links and replaces them with their underlying text, as found in notes in the vault.\nAssumes that the embedded links do not loop infinitely.\nFor embedded links to notes that do not exist in the vault, the embedded links are replaced with blank str.\nNo new entries are added to self.parts even if the embedded links have multiple lines.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nvault\nPathLike\n\n\n\n\nrecursive\nbool\nTrue\nIf True, then recursively replaces embedded links in the text of the embedded links.\n\n\nremove_paragraph_id\nbool\nTrue\nIf True, then removes the paragraph id’s in the text of the embedded links. Leaves the paragraph id’s of the origianl text in tact.\n\n\nReturns\nNone\n\n\n\n\n\n\n# TODO: test recursive\nwith tempfile.TemporaryDirectory(prefix='temp_dir_', dir=os.getcwd()) as temp_dir:\n    make_example_vault_2(temp_dir)\n    vault = Path(temp_dir)\n    vn = VaultNote(vault, name='note_with_embedded_links_1')\n    mf = MarkdownFile.from_vault_note(vn)\n    mf.replace_embedded_links_with_text(vault)\n    assert str(mf) == r\"\"\"This is a note.\n\nThere are some embedded text here:\n\nHello, this is a note which becomes entirely embedded.\n\nThe comment is not visible.\nThis is the end of the comment %%\n\n\ncheese \nbandit\n$$asdf$$\nasdf \n\n$$5 \\neq 7\n$$ \n\n# Section\nSome kind of section?\n\nLalalala\n## Subsection\nargonaut\"\"\"\n\nsetting remove_paragraph_id=False keeps the paragraph id’s in the embedded text.\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir_', dir=os.getcwd()) as temp_dir:\n    make_example_vault_2(temp_dir)\n    vault = Path(temp_dir)\n    vn = VaultNote(vault, name='note_with_embedded_links_1')\n    mf = MarkdownFile.from_vault_note(vn)\n    mf = MarkdownFile.from_vault_note(vn)\n    mf.replace_embedded_links_with_text(vault, remove_paragraph_id=False)\n    print(str(mf))\n    assert str(mf) == r\"\"\"This is a note.\n\nThere are some embedded text here:\n\nHello, this is a note which becomes entirely embedded.\n\nThe comment is not visible.\nThis is the end of the comment %%\n\n\ncheese \nbandit\n$$asdf$$\nasdf \n^65809f\n\n$$5 \\neq 7\n$$ \n^221b51\n\n# Section\nSome kind of section?\n\nLalalala\n## Subsection\nargonaut\"\"\"\n\nThis is a note.\n\nThere are some embedded text here:\n\nHello, this is a note which becomes entirely embedded.\n%%This is a comment. \nThe comment is not visible.\nThis is the end of the comment %%\n\n\ncheese \nbandit\n$$asdf$$\nasdf \n^65809f\n\n$$5 \\neq 7\n$$ \n^221b51\n\n# Section\nSome kind of section?\n\nLalalala\n## Subsection\nargonaut\n\n\n\nsource\n\n\nMarkdownFile.remove_html_tags\n\n MarkdownFile.remove_html_tags ()\n\n*Remove HTML tags that are typeset in single lines.\nHTML tags that span multiple lines are ignored.*\n\n# TODO: test\n\n\nsource\n\n\nMarkdownFile.merge_display_math_mode\n\n MarkdownFile.merge_display_math_mode ()\n\nMerge chunks of display_math_mode latex lines into single lines\n\nmf = MarkdownFile.from_string(text_10)\nmf.merge_display_math_mode()\nprint(mf)\nassert len(mf.parts) == 13\n\nThis is a single line display math mode LaTeX equation:\n\n$$\\mathcal{O}_X$$\n\nThis is a single multi-line display math mode LaTeX equation:\n\n$$ 5 + 2 = 7 $$\n\nThese are multiple consecutive display math mode LaTeX equations:\n\n$$1+1 = 2 $$\n$$5 + 7 = 14$$\n$$  8 + 4 = 12  $$\n\n\n\nsource\n\n\nMarkdownFile.merge_display_math_mode_into_preceding_text\n\n MarkdownFile.merge_display_math_mode_into_preceding_text\n                                                           (separator:str=\n                                                           '\\n')\n\nMerge chunks of display math mode latex lines into single lines and merge those single lines into preceding text lines.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nseparator\nstr\n\nThe str with which to join the latex lines into the text lines. Note that the display math mode latex lines are not joined with this str.\n\n\nReturns\nNone\n\n\n\n\n\n\nmf = MarkdownFile.from_string(text_10)\nmf.merge_display_math_mode_into_preceding_text(separator=' ')\nprint(mf)\nassert len(mf.parts) == 5\n\nThis is a single line display math mode LaTeX equation:  $$\\mathcal{O}_X$$\n\nThis is a single multi-line display math mode LaTeX equation:  $$ 5 + 2 = 7 $$\n\nThese are multiple consecutive display math mode LaTeX equations:  $$1+1 = 2 $$ $$5 + 7 = 14$$ $$  8 + 4 = 12  $$\n\n\nWe can set separator to its default value \\n.\n\nmf = MarkdownFile.from_string(text_10)\nmf.merge_display_math_mode_into_preceding_text(separator='\\n')\nprint(mf)\nassert len(mf.parts) == 5  # Some of the parts have 'line' as multi-line str i.e. as str with `\\n` characters.\nassert '\\n' in mf.parts[0]['line']\nassert '\\n' not in mf.parts[1]['line']\n\nThis is a single line display math mode LaTeX equation:\n\n$$\\mathcal{O}_X$$\n\nThis is a single multi-line display math mode LaTeX equation:\n\n$$ 5 + 2 = 7 $$\n\nThese are multiple consecutive display math mode LaTeX equations:\n\n$$1+1 = 2 $$\n$$5 + 7 = 14$$\n$$  8 + 4 = 12  $$\n\n\nIf the text starts with display math mode LaTeX, then that text is combined into one.\n\nmf = MarkdownFile.from_string(text_11)\nmf.merge_display_math_mode_into_preceding_text(separator=' ')\nprint(mf)\nassert len(mf.parts) == 2\n\n$$asdf$$ $$asdf$$ $$asdf$$\nAfter text.",
    "crumbs": [
      "markdown.markdown.file"
    ]
  },
  {
    "objectID": "markdown.markdown.file.html#writing-a-markdownfile-object-to-a-file",
    "href": "markdown.markdown.file.html#writing-a-markdownfile-object-to-a-file",
    "title": "markdown.markdown.file",
    "section": "Writing a MarkdownFile object to a file",
    "text": "Writing a MarkdownFile object to a file\nWe can write the contents of a MarkdownFile object to the file represented by VaultNote object.\n\nsource\n\nMarkdownFile.parts_of_id\n\n MarkdownFile.parts_of_id (par_id:str)\n\n*Return the indices of the lines within the Markdown file belonging to the specified text id.\nThis id can be used as an anchor for a link in Obsidian. For example, [[note#^65809f]] is a link to a note named note to the text with id 65809f. Such a text is marked with a trailing ^65809f.*\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\npar_id\nstr\nMust begin with '\\^'.\n\n\nReturns\nOptional\n(start,end) where self.parts[start:end] consists of the lines of the specified id. If the specified id does not exist for the note, then None is returned.\n\n\n\nLinks in Obsidian can be anchored at “paragraphs” of text. As Wikilinks, such links have the format [[&lt;note_name&gt;#^&lt;id_of_paragraph&gt;]]. Note that the id begins with a carat ^.\nWe can get the parts of the Markdown file to which the id refers to:\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir_', dir=os.getcwd()) as temp_dir:\n    make_example_vault_2(temp_dir)\n    vault = Path(temp_dir)\n    vn = VaultNote(vault, name = 'note_with_paragraphs_that_are_embedded_1')\n    mf = MarkdownFile.from_vault_note(vn)\n\n    start, end = mf.parts_of_id('^65809f')\n    assert start == 3 and end == 8\n    print(mf.text_of_lines(start, end), '\\n')\n    # lines = [mf.parts[i]['line'] for i in range(start, end)]\n    # print('\\n'.join(lines))\n\n    start, end = mf.parts_of_id('^221b51')\n    assert start == 13 and end == 16\n    print(mf.text_of_lines(start, end), '\\n')\n\n    start, end = mf.parts_of_id('^123456')\n    assert start == 17 and end == 18\n    print(mf.text_of_lines(start, end), '\\n')\n\n    start, end = mf.parts_of_id('^fff123')\n    assert start == 20 and end == 21\n    print(mf.text_of_lines(start, end), '\\n')\n\n    start, end = mf.parts_of_id('^latexthing')\n    assert start == 22 and end == 23\n    print(mf.text_of_lines(start, end), '\\n')\n\ncheese \nbandit\n$$asdf$$\nasdf \n^65809f \n\n$$5 \\neq 7\n$$ \n^221b51 \n\n# This section has an id ^123456 \n\n^fff123 \n\n$$\\mathcal{O}_X$$  ^latexthing \n\n\n\n\nHidden tests\n\n# hide \n# TODO _look_at_start_of_file, _line_dict",
    "crumbs": [
      "markdown.markdown.file"
    ]
  },
  {
    "objectID": "markdown.markdown.file.html#misc-todo",
    "href": "markdown.markdown.file.html#misc-todo",
    "title": "markdown.markdown.file",
    "section": "Misc TODO",
    "text": "Misc TODO\n\nsource\n\nMarkdownFile.text_of_lines\n\n MarkdownFile.text_of_lines (start:int, end:int)\n\nReturn the text of self.parts[start:end], adding new line characters ' ' in between.\n\nsource\n\n\nMarkdownFile.write\n\n MarkdownFile.write (vn:trouver.markdown.obsidian.vault.VaultNote,\n                     mode:str='w', check_validity:bool=True)\n\n*Write to the file specified by a VaultNote object.\nIf the file that the VaultNote object represents does not exist, then this method creates it.\nRaises - ValueError - If check_validity is True and if str(self) cannot be parsed as a MarkdownFile object. If this error is raised, then most likely the issue is that the frontmatter metadata cannot be parsed by pyyaml and the metadata field elements need to be escaped and/or enquoted.\nIt is recommended to use .replace_metadata and passing arguments to the enquote_entries_in_fields parameter or to use the dict_to_metadata_lines function to ensure that metadata fields are enquoted and escaped.*\nThe MarkdownFile.write method raises a ValueError if check_validity is True and if the output of .__str__() on the MarkdownFile object cannot be parsed as a MarkdownFile object itself.\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir_', dir=os.getcwd()) as temp_dir:\n    make_example_vault(temp_dir)\n\n    # The following text is parseable by pyyaml.\n    metadata_markdownfile_text = r'''---\nlatex_in_original: [\"\\\\text{hi}\"]\n---\nblahblah\n'''\n    mf = MarkdownFile.from_string(metadata_markdownfile_text)\n    print(\"Note that `mf` is completely fine right after it is constructed:\")\n    print(str(mf))\n    MarkdownFile.from_string(str(mf))  # This does not raise errors\n\n    mf.add_tags('_new_tag')\n    print('\\nAfter adding a tag, however, the metadata changes. Note that the `latex_in_original` field is no longer enquoted and escaped:')\n    print(mf.__str__())\n    print('\\n\\nTo prevent further problems, the `.write` method raises a `ValueError`')\n\n    vault_note = VaultNote(temp_dir, name='pauli_wickelgren_aa1_example 3.7')\n\n    with ExceptionExpected(ex=ValueError):\n        mf.write(vault_note)\n\nNote that `mf` is completely fine right after it is constructed:\n---\nlatex_in_original: [\"\\\\text{hi}\"]\n---\nblahblah\n\nAfter adding a tag, however, the metadata changes. Note that the `latex_in_original` field is no longer enquoted and escaped:\n---\nlatex_in_original: [\\text{hi}]\ntags: [_new_tag]\n---\nblahblah\n\n\nTo prevent further problems, the `.write` method raises a `ValueError`\n\n\nIf check_validity is False, then the .write method will attempt to write to the file of the VaultNote object. However, note that the resulting file writing may result not be fully parseable as a MarkdownFile object.\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir_', dir=os.getcwd()) as temp_dir:\n    make_example_vault(temp_dir)\n\n    # The following text is parseable by pyyaml.\n    metadata_markdownfile_text = r'''---\nlatex_in_original: [\"\\\\text{hi}\"]\n---\nblahblah\n'''\n    mf = MarkdownFile.from_string(metadata_markdownfile_text)\n    print(\"Note that `mf` is completely fine right after it is constructed:\")\n    print(str(mf))\n    MarkdownFile.from_string(str(mf))  # This does not raise errors\n\n    mf.add_tags('_new_tag')\n    print('\\nAfter adding a tag, however, the metadata changes. Note that the `latex_in_original` field is no longer enquoted and escaped:')\n    print(mf.__str__())\n    print('\\n\\nTo prevent further problems, the `.write` method raises a `ValueError`')\n\n    vault_note = VaultNote(temp_dir, name='pauli_wickelgren_aa1_example 3.7')\n\n    mf.write(vault_note, check_validity=False)\n    new_mf = MarkdownFile.from_vault_note(vault_note)\n    with ExceptionExpected(ValueError): # The ValueError is from the .metadata method.\n        new_mf.metadata()\n\nNote that `mf` is completely fine right after it is constructed:\n---\nlatex_in_original: [\"\\\\text{hi}\"]\n---\nblahblah\n\nAfter adding a tag, however, the metadata changes. Note that the `latex_in_original` field is no longer enquoted and escaped:\n---\nlatex_in_original: [\\text{hi}]\ntags: [_new_tag]\n---\nblahblah\n\n\nTo prevent further problems, the `.write` method raises a `ValueError`\n\n\n\nsource\n\n\nMarkdownFile.copy\n\n MarkdownFile.copy (deep:bool)",
    "crumbs": [
      "markdown.markdown.file"
    ]
  },
  {
    "objectID": "helper.date_and_time.html",
    "href": "helper.date_and_time.html",
    "title": "helper.date_and_time",
    "section": "",
    "text": "source\n\n\n\n current_time_formatted_to_minutes ()\n\n*Return the current time to minutes.\nReturns\n\nstr\n\nIn UTC time, to minutes.*\n\n\nThe current_time_formatted_to_minutes function is a convenience function that returns a string formatting current UTC time:\n\ntime_str = current_time_formatted_to_minutes()\nprint(time_str)\n\n2024-08-30T19:29\n\n\nUse the dattime.dattime.fromisoformat function to convert back the formatted string to a datetime.datetime object:\n\ndt = datetime.datetime.fromisoformat(time_str)",
    "crumbs": [
      "helper.date_and_time"
    ]
  },
  {
    "objectID": "helper.date_and_time.html#date-and-time",
    "href": "helper.date_and_time.html#date-and-time",
    "title": "helper.date_and_time",
    "section": "",
    "text": "source\n\n\n\n current_time_formatted_to_minutes ()\n\n*Return the current time to minutes.\nReturns\n\nstr\n\nIn UTC time, to minutes.*\n\n\nThe current_time_formatted_to_minutes function is a convenience function that returns a string formatting current UTC time:\n\ntime_str = current_time_formatted_to_minutes()\nprint(time_str)\n\n2024-08-30T19:29\n\n\nUse the dattime.dattime.fromisoformat function to convert back the formatted string to a datetime.datetime object:\n\ndt = datetime.datetime.fromisoformat(time_str)",
    "crumbs": [
      "helper.date_and_time"
    ]
  },
  {
    "objectID": "tutorial.walkthrough.html",
    "href": "tutorial.walkthrough.html",
    "title": "tutorial.walkthrough",
    "section": "",
    "text": "In this tutorial, we describe a recommended setup for using trouver. Note that the exact details and consequences of this walkthrough may change as trouver or any related software changes; the current version of this walkthrough was written on 12/24/2024 and was written based on trouver version 1.0.0.\nSee also tutorial.concise_code for a concise version of the code used in this tutorial.",
    "crumbs": [
      "tutorial.walkthrough"
    ]
  },
  {
    "objectID": "tutorial.walkthrough.html#installations",
    "href": "tutorial.walkthrough.html#installations",
    "title": "tutorial.walkthrough",
    "section": "Installations",
    "text": "Installations\nSee also how_to.install_trouver.\nGo to a command-line (e.g. cmd on Windows, Terminal on Linux) and install trouver with pip:\npip install trouver\nInstall JupyterLab.\npip install jupyterlab\nOnce installed, launch JupyterLab with\njupyter-lab\n\n\n\nThis is supposed to be an image of JupyterLab being launched\n\n\nAlternatively, install the classic Jupyter Notebook via\npip install notebook\nand launch with\njupyter notebook\n\n\n\nThis is supposed to be an image of classic Jupyter notebook being launched\n\n\nor use Visual Studio Code to view and edit notebooks.\n\n\n\nThis is an image of Visual Studio Code\n\n\nInstall Obsidian.md. Obsidian.md is a note taking software that, among other functionalities, makes it easy to link between notes.\nNote that the most important basic functionalities in Obsidian.md are free.\n\n\n\nThe following window pops up upon launching Obsidian.md\n\n\n\n\nWarning At the time of this writing, trouver has not been tested on MacOS extensively. We have also found that running the latest Python versions in Jupyter notebooks on modern MacOS machines (e.g. those using the M1 processor and in particular the arm64 architecture) lead to some issues. cf. stackexchange discussions such as\n- https://apple.stackexchange.com/questions/436801/m1-mac-mach-o-file-but-is-an-incompatible-architecture-have-x86-64-need-a\n- https://stackoverflow.com/questions/71502583/jupiter-wont-launch-from-terminal-on-m1-macbook.\nFor MacOS users, it may be useful to go through this tutorial/walkthrough using a Python console or using the Google Colab Notebook for this tutorial/walkthrough.",
    "crumbs": [
      "tutorial.walkthrough"
    ]
  },
  {
    "objectID": "tutorial.walkthrough.html#creating-an-obsidian.md-vault",
    "href": "tutorial.walkthrough.html#creating-an-obsidian.md-vault",
    "title": "tutorial.walkthrough",
    "section": "Creating an Obsidian.md vault",
    "text": "Creating an Obsidian.md vault\nAn Obsidian vault is a folder where Obsidian stores your notes as well as setting files, CSS, trash folder, and any sub-folders, notes, and attachments you add yourself, cf. “What exactly is a vault?”.\nLet us make a new Obsidian.md vault. For this example, we call the vault example_math_vault and create it in a local folder called trouver_walkthrough_folder. Doing so creates a folder example_math_vault in trouver_walkthrough_folder, i.e. creates the folder trouver_walkthrough_folder/example_math_vault:\n\n\n\nUpon creating the vault, Obsidian.md will open the vault:",
    "crumbs": [
      "tutorial.walkthrough"
    ]
  },
  {
    "objectID": "tutorial.walkthrough.html#obsidian.md-functionalities",
    "href": "tutorial.walkthrough.html#obsidian.md-functionalities",
    "title": "tutorial.walkthrough",
    "section": "Obsidian.md functionalities",
    "text": "Obsidian.md functionalities\n\nCreating files and folders in an Obsidian vault\nBy and large, one can make files and folders fairly liberally in one’s own Obsidian vault (note, however, that Obsidian can experience significant lags on vaults with many notes, say on the order of 10,000, depending on the machine running it).\nFor example, let us create a new note by clicking on the “New note” icon in the left pane:\n\n\n\nLet us name the new note _index:\n\n\n\nLet us check that a new file named _index.md has been created in the computer. To open the directory that the file is in, it is convenient to use the Show in system explorer command. To use this command, open the Command Palette by either clicking on the Open command palette icon in the left pane\n\n\n\nor by using the Hotkey/keyboard shortcut for the Open command palette command. By default, this shortcut is either Ctrl + p or Cmd + p (or the appropriate variant for your computer).\nEither way, the command palette should open up.\n\n\n\nType the word system so that the command palette shows that Show in system explorer command.\n\n\n\nSelect this command to open the directory containing the _index.md file, which should be the root directory of the vault:\n\n\n\n\n\nLinks and editing files\nLet us now create some more files and folders. Note that one can create files and folders for an Obsidian vault without using Obsidian. In particular, one can create such files and folders in the computer’s default file system.\nLet us create a folder named algebra and a folder named number_theory. Let us also create files named _index_algebra.md and _index_number_theory.md in these two folders respectively (make sure that the file extensions are .md).\n\n\n\nGoing back to Obsidian, note that Osidian recognizes that these files and folders have been created:\n\n\n\nNow let us edit the _index.md file within Obsidian. In the file, start typing [[_index_algebra]]. Note that Obsidian makes some autocomplete suggestions when we do so:\n\n\n\nWhat we have done is that we have created a link within the Obsidian vault! This is one of Obsidian’s highlighted features - one can make and access links fairly easily within an Obsidian vault. Click on the link to go to the _index_algebra note:\n\n\n\nLet us start typing the following text:\nAlgebra is really fun. Here are some things that I want to learn about \n- The Galois group $\\operatorname{Gal}(L/K)$ of a Galois field extension\n- $\\mathbb{A}^1$-homotopy theory.\n- etc.\nNote that there are some LaTeX strings in this text and that Obsidian renders such text as so:\n\n\n\nSome users may prefer to use the Source mode as the Default editing mode, as opposed to Live Preview. To change this setting, go to Settings &gt; Editor &gt; Default editing mode:\n\n\n\n\n\n\nOn can quickly toggle between the editing view and reading view with the Toggle reading/editing view command (which has the Hotkey Ctrl + e or Cmd + e by default):\n\n\n\n\n\nQuick Switcher\nIn Obsidian, one can search and open notes by name. Open the Quick switcher either with the Open quick switcher icon in the left pane or with the Hotkey Ctrl + o or Cmd + o:\n\n\n\n\n\n\nStart typing _index_number_theory. Note that the quick switcher autocompletes note names. Open the _index_number_theory note by selecting it in the quick switcher:\n\n\n\n\n\n\nOne can add “aliases” to Obsidian notes to make them better searchable.\n\n\nMore Obsidian features\nObsidian has quite a lot of features that make Obsidian vaults highly useful and customizable. In fact, there are quite a lot of features of Obsidian that the author of trouver regularly uses:\n\nVim keybindings\nCSS Styles\nPlugins\netc.\n\nSee the Obsidian Help vault online for more information on Obsidian’s features.",
    "crumbs": [
      "tutorial.walkthrough"
    ]
  },
  {
    "objectID": "tutorial.walkthrough.html#optional-adding-some-files-and-folders-for-formatting-for-trouver",
    "href": "tutorial.walkthrough.html#optional-adding-some-files-and-folders-for-formatting-for-trouver",
    "title": "tutorial.walkthrough",
    "section": "Optional: Adding some files and folders for formatting for trouver",
    "text": "Optional: Adding some files and folders for formatting for trouver\nFor the purposes of using trouver, we recommend adding a few more folders. We will need a _references folder and a _templates folder and multiple subfolders. For convenience, copy the _references and _templates folders from the nbs/_tests/empty_model_vault directory of the trouver GitHub repository:\n\n\n\nEach of these folders have subfolders A-E, F-J, K-O, P-T, and U-Z and subsubfolders corresponding to each letter in the English alphabet. These are for organization. There are also multiple files named README.md in this subsubfolders. Feel free to delete them.\n\nRationale for the _references and _templates folders\nThe basic file organization philosophy for trouver is that each mathematical reference should have a dedicated folder in a vault and mathematical (standard information) notes derived from the mathematical reference should belong to this folder (or one of its subfolders/subsubfolders/etc).\nThe _references folder contains notes that contain information about each mathematical references, e.g. bibliographical information, where to find the reference (say on the arxiv), any other personal notes about the reference. The reference notes will be embedded in the standard information notes so that these information do not have to be manually replicated from standard information note to standard information note.\nThe _templates folder contains notes which serve as templates for the standard information notes for each reference.",
    "crumbs": [
      "tutorial.walkthrough"
    ]
  },
  {
    "objectID": "tutorial.walkthrough.html#dividing-a-latex-file",
    "href": "tutorial.walkthrough.html#dividing-a-latex-file",
    "title": "tutorial.walkthrough",
    "section": "Dividing a LaTeX file",
    "text": "Dividing a LaTeX file\nThe helper.arxiv module of trouver can use the arXiv API to download the source code of an arXiv article. Moreover, trouver can (attempt to) divide a LaTeX document into not-too-long parts in an Obsidian vault.\n\nSee index for an acknowledgement of arXiv.\n\n\nObtaining an arXiv source file using trouver\nOne fortunate state of mathematics is that many manuscripts are made publicly available on arxiv.org before they are formally published. In fact, the source code to many of these manuscripts are also generally available on the arxiv.\nAs an example, we download the source code for a paper written by the creator of trouver with a collaborator (See Special Thanks for an acknowledgement to Sun Woo Park, the collaborator in question, for permitting this paper to be presented for examples in trouver’s documentation).\n\nfrom pathlib import Path\n\nfrom trouver.helper.files_and_folders import get_download_path\nfrom trouver.latex import find_main_latex_file\nfrom trouver.helper.arxiv import arxiv_id, arxiv_search, download_from_results, extract_last_names\n\n\nurl = \"https://arxiv.org/abs/2106.10586\" # Replace this with the url \nresults = list(arxiv_search(arxiv_id(url)))\nlatex_dir = Path(get_download_path()) # Replace this with the path that you can to download the source file in; e.g. r'C:\\Users\\&lt;your user name&gt;' or r'/home/usr'\n\ndownloaded_path = download_from_results(results, latex_dir, source=True)[0]\nprint(downloaded_path)\nreference = downloaded_path.name\nauthor_full_names = [author.name for author in results[0].authors]\nauthor_names = extract_last_names(author_full_names)\n\nlatex_file = find_main_latex_file(downloaded_path)\nprint(latex_file)\n\nC:\\Users\\hyunj\\Downloads\\kim_park_gm1dcmbmc\nC:\\Users\\hyunj\\Downloads\\kim_park_gm1dcmbmc\\2106.10586v4.Global___mathbb_A__1__degrees_of_covering_maps_between_modular_curves.tex\n\n\n\n(Manual) Download an arXiv file\nAlternatively, if the code above does not work for some reason, one can manually download the source code.\nAs an example, let us go to the arxiv page for a paper written by the creator of trouver with a collaborator.\n\n\n\nOn the right, beneath Download:, note that there is a link titled Other formats. Access the link to got to the Format selector page:\n\n\n\nAround the bottom of this page is the option to download the source file(s) for the article. Click the Download source link to download the source file(s). Move the files to a different location if desired. For this example, we made a folder named latex_files in the trouver_walkthrough_folder, a subfolder named kim_park_ga1dcmmc in latex_files, and moved the source file into kim_park_ga1dcmmc.\n\n\n\nEither the file is compressed and contains multiple files, or the file is not compressed and is actually a .tex file. Attempt to decompress the file. If this fails, rename the file to have the .tex extension. Either way, you should have a .tex file at this stage. For this example, it turns out that the file is compressed and multiple files appear upon decompression.\n\n\n\n\n\n\nThe author usually finds it convenient to name the (main) .tex file main.tex for the purposes of using trouver, but the name of the .tex file ultimately does not matter.\n\n\nUsing trouver to divide the file and make notes in the Obsidian vault\nNow that we have the .tex file set up, we are now ready to the code from trouver to divide it. While the code can really be run from any python interpreter, we highly recommend using a notebook (say via Jupyter or VSCode) to run trouver code.\nTo open JupyterLab, open a command-line interface and run\njupyter-lab\n\n\n\nCreate a new notebook and run the following Python import statements:\n\nfrom pathlib import Path\nfrom trouver.helper.files_and_folders import text_from_file\nfrom trouver.latex.convert import (\n    divide_preamble, divide_latex_text, custom_commands,\n    setup_reference_from_latex_parts\n)\nfrom trouver.latex.preamble import replace_inclusion_of_style_file_with_code\n\nFurther run (a variant of) the following code. Replace latex_file and vault to be Python Path’s appropriate for your example. For more general instances, you may want to change the reference variable, the location variable, and the author_names varaibles as well.\n\n# One way to get folders accessible in Google Colab is to upload\n# zip files of them and to unzip them.\n# !unzip /content/example_math_vault.zip\n# !unzip /content/latex_files.zip\n\n\n# Change this as desired.\n# The name of the reference as well as the name of the folder that contains\n# the latex file\nreference = reference\n# Change this as desired.\nlatex_file = latex_file \n# latex_file = Path(r'C:\\Users\\&lt;user&gt;') / reference / 'main.tex'\nlatex_text = text_from_file(latex_file)\npreamble, _ = divide_preamble(latex_text)\npreamble = replace_inclusion_of_style_file_with_code(preamble, latex_dir)\nparts = divide_latex_text(latex_text, downloaded_path)\ncust_comms = custom_commands(preamble)\n# Replace the below as needed;\n# The path to the Obsidian vault in which to setup the \"subvault\"\n# For convenience, we currently set this as the folder where the\n# arXiv source file got downloaded into,\n# But you may change this to wherever your Obsiidan.md vault\n# actually is located at.\nvault = Path(downloaded_path)\n# Replace the below as needed;\n# The path relative to the vault of the directory in which to make\n# the new folder containing the new notes.\nlocation = Path('.')  \n# Replace the below as needed\n# The (family) names of the authors;\nauthor_names = author_names \n\nsetup_reference_from_latex_parts(\n    parts, cust_comms, vault, location,\n    reference,\n    author_names,\n    # You may set this to `True` if you set up a `_references` folder\n    # in your Obsidian.md vault.\n    create_reference_file_in_references_folder=False,\n    # You may set this to `True` if you set up a `_templates` folder\n    # in your Obsidian.md vault.\n    create_template_file_in_templates_folder=False,\n    adjust_common_latex_syntax_to_markdown=True,\n    repeat_replacing_custom_commands=-1,\n    copy_obsidian_configs=None\n    )\n\n\n\n\n\nNow return to the Obsidian vault. Note that a new folder named kim_park_ga1dcmmc has been created in the specified folder of the vault (If you used the code above as-is, then this new folder is within the same folder that the arXiv source .tex file is downloaded in). In Obsidian, open the _index_kim_park_ga1dcmmc note:\n\n\n\nClick on any of the links in the _index_kim_park_ga1dcmmc note to open another “index note”:\n\n\n\nClick on any of the links in the index note to open a “standard information note”. This note contains some text from the paper on arxiv.\n\n\n\nYou may need to reload the Obsidian vault before you can view some of these notes; Obsidian may not have registered/“indexed” some of these notes upon their creation. Reload Obsidian using the Reload app without saving commmand in the command palette:\n\n\n\nAt this point, we recommend that you explore the newly created notes and folders. As an overview, the above code does the following:\n\nCreates a folder for the reference in the specified folder (In this case, a folder named kim_park_ga1dcmmc was created in the number_theory folder in the vault).\nCreates folders corresponding to sections of the LaTeX file.\nCreates various notes/files in the reference folder, including, but not limited to\n\nstandard information notes\nan index note (in this case named _index_kim_park_ga1dcmmc)\n\nA template note for the standard information notes for the reference folder.\n\nThis template note may either be in same folder as the index note (if you used the above code as-is), or in the _templates folder of the vault. (In this case, the template note is created in _templates/K-O/K folder as the file _template_kim_park_ga1dcmmc.md)\n\nA copy of the above template note located in the root of the reference folder (In this case, the template note is created as the file _template_kim_park_ga1dcmmc_2.md).\n\nThis copy template note is created for use in case the user wishes to edit the reference folder by opening it as an Obsidian vault; in general, subdirectories of an obsidian vault can be opened as obsidian vaults in themselves. This can be advantageous when the “main” vault has many notes and thus Obsidian runs slowly in the “main” vault.\n\nA reference note for the reference.\n\nThis reference note may either be in same folder as the index note (if you used the above code as-is), in the _references folder of the vault (In this case, the reference note is located in the _references/K-O/K folder as the file _reference_kim_park_ga1dcmmc.md)\nThe user is encouraged to fill in this note with bibliographic information of the reference. Note that this reference note is embedded in the standard information notes for the reference, so the information provided in the reference note is easily readable from the standard information notes (in viewing mode).\n\n\nIf you made a mistake in running the above code and would like to re-setup your reference folder, you can use the following code to delete the reference folder, the template note, and the reference note. Enter the letter Y (case sensitive) to confirm that you wish to delete the folder and these notes. Note that this operation cannot be reversed.\n\nfrom trouver.markdown.obsidian.personal.reference import (\n    delete_reference_folder\n)\n# TODO: delete template and reference files even without reference folder.\ndelete_reference_folder(vault, reference)\n\n\nIdentified reference 'kim_park_gm1dcmbmc' in the vault 'C:\\Users\\hyunj\\Downloads\\kim_park_gm1dcmbmc' as the folder 'C:\\Users\\hyunj\\Downloads\\kim_park_gm1dcmbmc\\kim_park_gm1dcmbmc'...\nAborting deleting reference.\n\n\n\n\n\n\n\n\nUsing these notes\nOne can fairly liberally modify the contents in a standard information note for the purposes of trouver. Some things that we recommend include, but are not limited to:\n\nFor the user to read more about Obsidian’s features in Obsidian’s official help vault, including Obsidians’ flavor of Markdown syntax\n\nHowever, there are many forms of Obsidian’s Markdown syntax that trouver does not yet parse. One example is that trouver does not currently parse inline footnotes.\n\nFor the user to see what (community) plugins are available for Obsidian.\n\nUse these plugins at your own risk as there is no way to ultimately ensure that malicious or insecure code is not included in such plugins. However, most to all of these plugins are made open source, so the user can themselves understand how these plugins are implemented.\n\nFor the user to read trouver’s documentation and to explore the example vaults in the nbs/_tests directory of trouver(’s GitHub repository)\nFor the user to liberally mark their standard information notes with footnotes with personal memos about their experience reading the specific excerpt(s) from the specific mathematical references.\n\n\n\n\n\nFor the user to make modifications in the standard information notes to clean up the LaTeX syntax for the purposes of reading in Obsidian.md\n\nFor example, $ \\operatorname{Gal}(L/K)$ (notice the space between the $ and the \\ characters) will not render properly due to the space. One can correct this by typing $\\operatorname{Gal}(L/K)$ instead.\n\nFor the user to make links between notes to develop a stronger understanding of the relationship among notes and to build reliable methods for quickly recalling mathematical facts, definitions, or notations.\nFor the user to NOT create and maintain notes of the same file name in a single vault. trouver generally operates under the assumption that an Obsidian vault will not have two or more files of the same name. In particular, errors or unexpected consequences may arise if the code of trouver is run on an Obsidian vault with two files of the same name.\n\nHowever, here are some modifications that one should not make to a standard information note for the purposes of trouver:\n\nChanging the title of/deleting the See Also, Meta, References, Citations and Footnotes headers/sections; doing so will result in errors in some functionalities of trouver as trouver’s criteria for recognizing a standard information note is as a note with such headers.\n\nOne can nevertheless modify the contents within these sections. Note that the title of the section titled Topic may be modified liberally and that sections can be added liberally.\n\nChanging the formatting of the frontmatter YAML metadata (The text in the beginning of a note starting with ---).\n\nOne can and should nevertheless modify the contents of the frontmatter YAML metadata as appropriate.",
    "crumbs": [
      "tutorial.walkthrough"
    ]
  },
  {
    "objectID": "tutorial.walkthrough.html#using-machine-learning-models",
    "href": "tutorial.walkthrough.html#using-machine-learning-models",
    "title": "tutorial.walkthrough",
    "section": "Using Machine learning models",
    "text": "Using Machine learning models\nNow that we have set up a reference folder from a LaTeX file, we should make great use of the notes/files in the folder to learn concepts presented in the LaTeX file.\nOne of the basic challenges in deciphering a mathematical paper is grasping the definitions and notations presented in the paper. The machine learning models can help make this process more reliable and faster.\nCurrently, the functionalities of trouver are more focused towards finding notations as opposed to definitions. In time, we hope to improve these functionalities to better encompass finding definitions as well. Nevertheless, the functionalities of trouver effectively allow the user to identify where notations are introduced in the various notes in the reference folder and to create, for each notation, a note dedicated to the notation.\nCurrently, trouver uses the following ML models:\n\nhyunjongkimmath/information_note_type\nhyunjongkimmath/def_and_notat_token_classification_model\nhyunjongkimmath/definition_naming_model and hyunjongkimmath/notation_naming_model\nhyunjongkimmath/notation_summarizations_model\n\nThe first is trained using fast.ai and the rest are trained using the Hugging Face Transformers library.\nML models can be computationally intensive to run. As such, trouver roughly operates on a “run-once, record results for later use” principle when it comes to its ML models. Moreover, since ML models inherently cannot be perfect, trouver also operates on general principle to allow for users to manually correct these recorded results without raising errors.\n\nRemark Graphical Processing Units (GPU’s) are not necessary to use these models. In particular, these models can be loaded onto a computer’s CPU.\n\n\nDownloading and loading the ML models\nSince ML models typically are large in file size, the models are not part of the trouver library itself. Instead, the models are made publicly available on Hugging Face, where they can be downloaded.\nRun the following code to download the models from the Hugging Face Hub’ and then to load the models. Depending on your internet connection, it may take a few minutes to download this models the first time because each model is at least several hundred megabytes large. Downloading the models may also sometimes temporarily fail and may run correctly once you run the code again after waiting for some time. Moreover, these models are saved to a local cache folder. See Hugging Face cache management for more details. The get_Huggingface_cache_dir function should indicate where these models are stored in your machine.\nSee also index for a description of what these models accomplish.\n\nimport pathlib\nfrom pathlib import Path, WindowsPath\nimport platform\n\nfrom huggingface_hub import from_pretrained_fastai\nfrom transformers import AutoModelForSeq2SeqLM, AutoModelForTokenClassification, AutoTokenizer, pipeline\n\nfrom trouver.helper.files_and_folders import get_huggingface_cache_dir\nfrom trouver.markdown.obsidian.personal.machine_learning.information_note_types import automatically_add_note_type_tags\n\nfrom trouver.markdown.obsidian.personal.machine_learning.tokenize.def_and_notat_token_classification import auto_mark_def_and_notats\nfrom trouver.markdown.obsidian.personal.machine_learning.definition_and_notation_naming import add_names_to_html_tags_in_info_note\nfrom trouver.markdown.obsidian.personal.machine_learning.notation_summarization import append_summary_to_notation_note\n\n\n# Load the model that categorizes the type(s) of standard information notes\nrepo_id = 'hyunjongkimmath/information_note_type'\nif platform.system() == 'Windows':\n    temp = pathlib.PosixPath # See https://stackoverflow.com/questions/57286486/i-cant-load-my-model-because-i-cant-put-a-posixpath\n    pathlib.PosixPath = pathlib.WindowsPath\n    information_note_type_model = from_pretrained_fastai(repo_id)\n    pathlib.PosixPath = temp\nelse:\n    information_note_type_model = from_pretrained_fastai(repo_id)\n\n\n# Load the model the finds definitions and notations introduced in standard information notes\nmodel = AutoModelForTokenClassification.from_pretrained('hyunjongkimmath/def_and_notat_token_classification_model')\ntokenizer = AutoTokenizer.from_pretrained('hyunjongkimmath/def_and_notat_token_classification_model')\ndef_notat_classifier = pipeline('ner', model=model, tokenizer=tokenizer)\n\n# Load the models that names definitions and notations.\nmodel = AutoModelForSeq2SeqLM.from_pretrained('hyunjongkimmath/definition_naming_model')\ntokenizer = AutoTokenizer.from_pretrained('hyunjongkimmath/definition_naming_model')\ndefinition_naming_pipeline = pipeline('summarization', model=model, tokenizer=tokenizer)\n\nmodel = AutoModelForSeq2SeqLM.from_pretrained('hyunjongkimmath/notation_naming_model')\ntokenizer = AutoTokenizer.from_pretrained('hyunjongkimmath/notation_naming_model')\nnotation_naming_pipeline = pipeline('summarization', model=model, tokenizer=tokenizer)\n\n# Load the model the summarizes what notations denote\nmodel = AutoModelForSeq2SeqLM.from_pretrained('hyunjongkimmath/notation_summarizations_model')\ntokenizer = AutoTokenizer.from_pretrained('hyunjongkimmath/notation_summarizations_model')\nsummarizer = pipeline('summarization', model=model, tokenizer=tokenizer)\n\n\n\n\n\n\n\nNote that there are some if-else statements used to load the fast.ai models; this is a workaround implemented for Windows users as loading fast.ai models seems to have some issues with Python’s pathlib, cf. https://stackoverflow.com/questions/57286486/i-cant-load-my-model-because-i-cant-put-a-posixpath.\nAfter running this code, we have the Python variables information_note_type_model, def_notat_classifier, definition_naming_pipeline, notation_naming_pipeline, and summarizer. Note that information_note_type_model is a fast.ai model while the others are all technically not models, but rather pipelines of the transformers library that contain models.\nTo use the models, first run the following import statements:\n\nimport warnings\n\nfrom trouver.markdown.markdown.file import MarkdownFile\nfrom trouver.markdown.obsidian.vault import VaultNote\nfrom trouver.markdown.obsidian.personal.notes import notes_linked_in_notes_linked_in_note, notes_linked_in_note\nfrom trouver.markdown.obsidian.personal.notation import make_notation_notes_from_double_asts, make_notation_notes_from_HTML_tags\nfrom trouver.markdown.obsidian.personal.notation.in_standard_information_note import notation_notes_linked_in_see_also_section\n\n\n\nCategorizing the type(s) of standard information notes\nRun the following code to 1. use the information_note_type_model to predict the types of each standard information note in the newly created reference folder, and 2. record these predictions to the standard information notes’ respective frontmatter YAML metadata. Running the following code should take several minutes.\n\n# Change `vault` and `reference` if necessary. These variables were defined in previous code.\n# vault = Path(r'C:\\Users\\&lt;user&gt;\\...')  # The path to the Obsidian vault\n# `reference` = 'kim_park_ga1dcmmc`\nindex_note = VaultNote(vault, name=f'_index_{reference}')\nnotes = notes_linked_in_notes_linked_in_note(index_note, as_dict=False)\n\nfor note in notes:\n    if not note.exists():\n        raise Exception(note.name)\n\nprint(\"Tagging notes\")\nautomatically_add_note_type_tags(information_note_type_model, vault, notes)\n\nTagging notes\n\n\nc:\\Users\\hyunj\\Documents\\Development\\Python\\trouver_py310_venv\\lib\\site-packages\\bs4\\__init__.py:435: MarkupResemblesLocatorWarning: The input looks more like a filename than markup. You may want to open this file and pass the filehandle into Beautiful Soup.\n  warnings.warn(\n\n\nLet us first describe in more detail what the above code does. The first line\nindex_note = VaultNote(vault, name=f'_index_{reference}')\ncreates a VaultNote object from the trouver.markdown.obsidian.vault module, which represents a note in an Obsidian vault. The note/file that a VaultNote object represents does not have to exist, although runtime errors may be raised on certain operations, such as reading or writing a file, that require an existing file. In the above line of code, we pass vault as an argument, signifying that the VaultNote object should represent a note from the specified Obsidian vault (as opposed to a file in any directory outside of vault). We also pass the Python string f'_index_{reference}' as the argument to the name parameter — in this case the string equals the string '_index_kim_park_ga1dcmmc' — signifying that the VaultNote object should represent the note named _index_kim_park_ga1dcmmc (recall that trouver operates under the assumption that no two notes in an Obsidian vault have the same name).\nFurthermore, the VaultNote class has a cache which is supposed to keep track of all the .md files in an Obsidian vault. Creating or deleting files by not using methods from the VaultNote class may make the information stored in this cache obsolete. The VaultNote class will try to re-scan files in the vault to update its cache, but sometimes (for reasons that are not yet well documented) the user may need to manually clear the cache via the VaultNote.clear_cache class method:\nVaultNote.clear_cache()\nDepending on the size of the vault and the specs of the computer running trouver, scanning the files in a vault may take several seconds or more.\nThe second line of code creates a list of VaultNote objects and stores the list in the variable notes:\nnotes = notes_linked_in_notes_linked_in_note(index_note, as_dict=False)\nThe notes_linked_in_notes_linked_in_note function is implemented specifically for index notes which keep track of index notes, which in turn keep track of standard information notes, via links; recall that the note _index_kim_park_ga1dcmmc is such an index note:\n\n\n\nThe code\nfor note in notes:\n    if not note.exists():\n        raise Exception(note.name)\nchecks that the standard information notes listed in notes actually exist (more accurately, the code checks that the links in the notes linked in the note _index_kim_park_ga1dcmmc point to notes that actually exist). Finally,\nautomatically_add_note_type_tags(information_note_type_model, vault, notes)\nuses the model to make predictions and record those predictions to the frontmatter YAML metadata of the notes.\nThe following is a comparison of a note before and after these predictions are made and recorded (note that the note is viewed in Edit mode as opposed to Viewing mode):\n\n\n\n\n\n\nBefore the predictions, the note only has the _reference/kim_park_ga1dcmmc and _meta/literature_note tags in the tags section of its YAML frontmatter metadata. After the predictions, the _auto/_meta/narrative tag is added.\nThe _auto prefix is used to signify that the tag is added automatically with the model. The _meta/narrative tag signifies that the content of the note contains a “narrative”; in this example, the note gives an overview of \\(\\mathbb{A}^1\\)-enumerative geometry, so it is fitting to consider it is “narrative”. Some tags that the model will predict for include\n\n_meta/definition\n_meta/notation\n_meta/concept\n_meta/proof\n_meta/narrative\n_meta/exercise\n_meta/remark\n_meta/example\n\nSee the documentation for markdown.obsidian.personal.machine_learning.information_note_types for more details.\nWe recommend manually editing these tags in your standard information notes as follows (if you have the time and inclination):\n\nremove the _auto prefix to confirm the model’s prediction if the model makes a correct prediction.\ndelete the tag altogether if the model’s prediction is incorrect.\nadd tags that the model incorrectly did not predict.\n\nAt the very least, we recommend making these edits for the _meta/definition and _meta/notation tags, which signify that a standard information note introduces at least one definition and at least one notation respectively.\nFor example, upon recognizing that the model correctly predicted the standard information note to contain a narrative, we delete the _auto prefix from the _auto/_meta/narrative tag:\n\n\n\n\n\nLocating definitions and notations introduced in standard information notes\nNext, we use the def_notat_classifier to locate notations introduced in the standard information notes and record these locations in the notes. Run the following code, which may take several to a few dozen minutes:\n\nwarnings.filterwarnings(\"ignore\")\n\nindex_note = VaultNote(vault, name=f'_index_{reference}')\nnotes = notes_linked_in_notes_linked_in_note(index_note, as_dict=False)\n\nfor note in notes:\n    assert note.exists()\n\nprint(\"Finding notations\")\nnote_mfs = [MarkdownFile.from_vault_note(note) for note in notes]\nnotation_notes = [\n    note for note, mf in zip(notes, note_mfs)\n    if mf.has_tag('_auto/_meta/definition') or mf.has_tag('_auto/_meta/notation')\n       or mf.has_tag('_meta/definition') or mf.has_tag('_meta/notation')]\nfor note in notation_notes:\n    auto_mark_def_and_notats(note, def_notat_classifier, excessive_space_threshold=2)\n    # automatically_mark_notations(note, notation_identification_model, reference_name=reference)\n\nFinding notations\n\n\nToken indices sequence length is longer than the specified maximum sequence length for this model (514 &gt; 512). Running this sequence through the model will result in indexing errors\n\n\nAgain, notes is a list of all standard information notes in the reference folder. The line\nnote_mfs = [MarkdownFile.from_vault_note(note) for note in notes]\nCreates a list of MarkdownFile objects of the trouver.markdown.markdown.file module. A MarkdownFile object represents the contents of an Obsidian Markdown file (as opposed to a file itself). In particular, a MarkdownFile object can be created from a VaultNote object (via the MarkdownFile.from_vault_note factory method) or from a Python string (via the MarkdownFile.from_string factory method). In particular, note_mfs is a list of MarkdownFile objects created from the contents of notes.\nThe line\nnotation_notes = [note for note, mf in zip(notes, note_mfs) if mf.has_tag('_auto/_meta/definition') or mf.has_tag('_auto/_meta/notation') or mf.has_tag('_meta/definition') or mf.has_tag('_meta/notation')]\nthen creates notation_notes as a sublist of notes consisting only of the notes with at least one of the following tags in their frontmatter YAML metadata:\n\n_auto/_meta/definition\n_auto/_meta/notation\n_meta/definition\n_meta/notation\n\nThe code\nfor note in notation_notes:\n    auto_mark_def_and_notats(note, def_notat_classifier, excessive_space_threshold=2)\nThen iterates through notation_notes, using def_notat_classifier to locate notations introduced only in the notes in notation_notes. We recommend using the above code to use the model to locate notations in the notes in notation_notes because the model works better in notes that are deemed likely to contain definitions or notations.\nThe following is an example of a comparison of a note before and after notations are located (for the current version of trouver, the note named kim_park_ga1dcmmc_29 should suffice as an example):\nTODO: update images to reflect current implementation of the def/notat marking\n\n\n\n\n\n\nNote that the difference is that html tags surround parts of the text that the model predicts to introduce definitions or notations.\n\nFor definitions, the HTML tags are &lt;b&gt; tags and have a definition=\"\" attribute.\nFor notations, the HTML tags are &lt;span&gt; tags and have a notation=\"\" attribute. Such HTML tags for notations only surround LaTeX math mode str’s.\nFor either, the HTML tags have some formatting specifications that draw boxes around the definitions/notations to make them easier to see in Obsidian.ms’s view mode.\n\nAn _auto/def_and_notat_identified tag is added to the notes if the model finds definitions and/or notations.\nWe highly recommend the user to manually make the following edits to correct def_notat_classifier’s mistakes:\n\nEdit/remove the HTML tags as needed\nAdd HTML tags to mark definitions/notations introduced in the text as needed.\n\n\n\n\nNaming marked definitions and notations\nAfter the definitions and notations are marked, we can then attempt to “name” them. See also index for a description of what this means.\nDepending on the length and number of notes, this may take at least several or dozens of minutes.\n\nindex_note = VaultNote(vault, name=f'_index_{reference}')\nnotes = notes_linked_in_notes_linked_in_note(index_note, as_dict=False)\n\nfor note in notes:\n    try:\n        mf = MarkdownFile.from_vault_note(note)\n        add_names_to_html_tags_in_info_note(\n            note, def_pipeline=definition_naming_pipeline,\n            notat_pipeline=notation_naming_pipeline, overwrite=False) \n    except Exception as e:\n        print(f'{note.name} raised an exception')\n        print(e)\n\nYour max_length is set to 200, but your input_length is only 116. Since this is a summarization task, where outputs shorter than the input are typically wanted, you might consider decreasing max_length manually, e.g. summarizer('...', max_length=58)\nYour max_length is set to 200, but your input_length is only 126. Since this is a summarization task, where outputs shorter than the input are typically wanted, you might consider decreasing max_length manually, e.g. summarizer('...', max_length=63)\nYour max_length is set to 200, but your input_length is only 164. Since this is a summarization task, where outputs shorter than the input are typically wanted, you might consider decreasing max_length manually, e.g. summarizer('...', max_length=82)\nYour max_length is set to 200, but your input_length is only 85. Since this is a summarization task, where outputs shorter than the input are typically wanted, you might consider decreasing max_length manually, e.g. summarizer('...', max_length=42)\nYour max_length is set to 200, but your input_length is only 188. Since this is a summarization task, where outputs shorter than the input are typically wanted, you might consider decreasing max_length manually, e.g. summarizer('...', max_length=94)\nYour max_length is set to 200, but your input_length is only 188. Since this is a summarization task, where outputs shorter than the input are typically wanted, you might consider decreasing max_length manually, e.g. summarizer('...', max_length=94)\nYour max_length is set to 200, but your input_length is only 58. Since this is a summarization task, where outputs shorter than the input are typically wanted, you might consider decreasing max_length manually, e.g. summarizer('...', max_length=29)\n\n\n\n---------------------------------------------------------------------------\nKeyboardInterrupt                         Traceback (most recent call last)\nCell In [17], line 8\n      6 try:\n      7     mf = MarkdownFile.from_vault_note(note)\n----&gt; 8     add_names_to_html_tags_in_info_note(\n      9         note, def_pipeline=definition_naming_pipeline,\n     10         notat_pipeline=notation_naming_pipeline, overwrite=False) \n     11 except Exception as e:\n     12     print(f'{note.name} raised an exception')\n\nFile c:\\users\\hyunj\\documents\\development\\python\\trouver\\trouver\\markdown\\obsidian\\personal\\machine_learning\\definition_and_notation_naming.py:159, in add_names_to_html_tags_in_info_note(info_note, def_and_notat_pipeline, def_pipeline, notat_pipeline, overwrite, fix_formatting, correct_syntax)\n    156 raw_info_note_text = info_note.text()\n    157 raw_info_note_text_minus_html_tags, tags_and_locats = remove_html_tags_in_text(\n    158     raw_info_note_text)\n--&gt; 159 predicted_names = predict_names(\n    160     info_note, def_and_notat_pipeline, def_pipeline,\n    161     notat_pipeline)\n    163 # If somehow a different number of HTML tags were found\n    164 if len(predicted_names) != len(tags_and_locats):\n    165     # TODO: do warning\n\nFile c:\\users\\hyunj\\documents\\development\\python\\trouver\\trouver\\markdown\\obsidian\\personal\\machine_learning\\definition_and_notation_naming.py:111, in predict_names(info_note, def_and_notat_pipeline, def_pipeline, notat_pipeline)\n    107     raise ValueError(\n    108         \"Expected `def_and_notat_pipeline` to be specified or \"\n    109         \"both `def_pipeline` and `notat_pipeline` to be specified.\")\n    110 data_points = data_from_information_note(info_note)\n--&gt; 111 return [_name_prediction_for_data_point(\n    112     data_point, def_and_notat_pipeline, def_pipeline, notat_pipeline)\n    113     for data_point in data_points]\n\nFile c:\\users\\hyunj\\documents\\development\\python\\trouver\\trouver\\markdown\\obsidian\\personal\\machine_learning\\definition_and_notation_naming.py:111, in &lt;listcomp&gt;(.0)\n    107     raise ValueError(\n    108         \"Expected `def_and_notat_pipeline` to be specified or \"\n    109         \"both `def_pipeline` and `notat_pipeline` to be specified.\")\n    110 data_points = data_from_information_note(info_note)\n--&gt; 111 return [_name_prediction_for_data_point(\n    112     data_point, def_and_notat_pipeline, def_pipeline, notat_pipeline)\n    113     for data_point in data_points]\n\nFile c:\\users\\hyunj\\documents\\development\\python\\trouver\\trouver\\markdown\\obsidian\\personal\\machine_learning\\definition_and_notation_naming.py:129, in _name_prediction_for_data_point(data_point, def_and_notat_pipeline, def_pipeline, notat_pipeline)\n    127 else:\n    128     summarizer = notat_pipeline\n--&gt; 129     summarizer_output = summarizer(data_point['text'], max_length=20, min_length=0)\n    130 return summarizer_output[0]['summary_text']\n\nFile c:\\Users\\hyunj\\Documents\\Development\\Python\\trouver_py310_venv\\lib\\site-packages\\transformers\\pipelines\\text2text_generation.py:269, in SummarizationPipeline.__call__(self, *args, **kwargs)\n    245 def __call__(self, *args, **kwargs):\n    246     r\"\"\"\n    247     Summarize the text(s) given as inputs.\n    248 \n   (...)\n    267           ids of the summary.\n    268     \"\"\"\n--&gt; 269     return super().__call__(*args, **kwargs)\n\nFile c:\\Users\\hyunj\\Documents\\Development\\Python\\trouver_py310_venv\\lib\\site-packages\\transformers\\pipelines\\text2text_generation.py:167, in Text2TextGenerationPipeline.__call__(self, *args, **kwargs)\n    138 def __call__(self, *args, **kwargs):\n    139     r\"\"\"\n    140     Generate the output text(s) using text(s) given as inputs.\n    141 \n   (...)\n    164           ids of the generated text.\n    165     \"\"\"\n--&gt; 167     result = super().__call__(*args, **kwargs)\n    168     if (\n    169         isinstance(args[0], list)\n    170         and all(isinstance(el, str) for el in args[0])\n    171         and all(len(res) == 1 for res in result)\n    172     ):\n    173         return [res[0] for res in result]\n\nFile c:\\Users\\hyunj\\Documents\\Development\\Python\\trouver_py310_venv\\lib\\site-packages\\transformers\\pipelines\\base.py:1257, in Pipeline.__call__(self, inputs, num_workers, batch_size, *args, **kwargs)\n   1249     return next(\n   1250         iter(\n   1251             self.get_iterator(\n   (...)\n   1254         )\n   1255     )\n   1256 else:\n-&gt; 1257     return self.run_single(inputs, preprocess_params, forward_params, postprocess_params)\n\nFile c:\\Users\\hyunj\\Documents\\Development\\Python\\trouver_py310_venv\\lib\\site-packages\\transformers\\pipelines\\base.py:1264, in Pipeline.run_single(self, inputs, preprocess_params, forward_params, postprocess_params)\n   1262 def run_single(self, inputs, preprocess_params, forward_params, postprocess_params):\n   1263     model_inputs = self.preprocess(inputs, **preprocess_params)\n-&gt; 1264     model_outputs = self.forward(model_inputs, **forward_params)\n   1265     outputs = self.postprocess(model_outputs, **postprocess_params)\n   1266     return outputs\n\nFile c:\\Users\\hyunj\\Documents\\Development\\Python\\trouver_py310_venv\\lib\\site-packages\\transformers\\pipelines\\base.py:1164, in Pipeline.forward(self, model_inputs, **forward_params)\n   1162     with inference_context():\n   1163         model_inputs = self._ensure_tensor_on_device(model_inputs, device=self.device)\n-&gt; 1164         model_outputs = self._forward(model_inputs, **forward_params)\n   1165         model_outputs = self._ensure_tensor_on_device(model_outputs, device=torch.device(\"cpu\"))\n   1166 else:\n\nFile c:\\Users\\hyunj\\Documents\\Development\\Python\\trouver_py310_venv\\lib\\site-packages\\transformers\\pipelines\\text2text_generation.py:191, in Text2TextGenerationPipeline._forward(self, model_inputs, **generate_kwargs)\n    184     in_b, input_length = tf.shape(model_inputs[\"input_ids\"]).numpy()\n    186 self.check_inputs(\n    187     input_length,\n    188     generate_kwargs.get(\"min_length\", self.model.config.min_length),\n    189     generate_kwargs.get(\"max_length\", self.model.config.max_length),\n    190 )\n--&gt; 191 output_ids = self.model.generate(**model_inputs, **generate_kwargs)\n    192 out_b = output_ids.shape[0]\n    193 if self.framework == \"pt\":\n\nFile c:\\Users\\hyunj\\Documents\\Development\\Python\\trouver_py310_venv\\lib\\site-packages\\torch\\autograd\\grad_mode.py:27, in _DecoratorContextManager.__call__.&lt;locals&gt;.decorate_context(*args, **kwargs)\n     24 @functools.wraps(func)\n     25 def decorate_context(*args, **kwargs):\n     26     with self.clone():\n---&gt; 27         return func(*args, **kwargs)\n\nFile c:\\Users\\hyunj\\Documents\\Development\\Python\\trouver_py310_venv\\lib\\site-packages\\transformers\\generation\\utils.py:1745, in GenerationMixin.generate(self, inputs, generation_config, logits_processor, stopping_criteria, prefix_allowed_tokens_fn, synced_gpus, assistant_model, streamer, negative_prompt_ids, negative_prompt_attention_mask, **kwargs)\n   1739     model_kwargs[\"attention_mask\"] = self._prepare_attention_mask_for_generation(\n   1740         inputs_tensor, generation_config._pad_token_tensor, generation_config._eos_token_tensor\n   1741     )\n   1743 if self.config.is_encoder_decoder and \"encoder_outputs\" not in model_kwargs:\n   1744     # if model is encoder decoder encoder_outputs are created and added to `model_kwargs`\n-&gt; 1745     model_kwargs = self._prepare_encoder_decoder_kwargs_for_generation(\n   1746         inputs_tensor, model_kwargs, model_input_name, generation_config\n   1747     )\n   1749 # 5. Prepare `input_ids` which will be used for auto-regressive generation\n   1750 if self.config.is_encoder_decoder:\n\nFile c:\\Users\\hyunj\\Documents\\Development\\Python\\trouver_py310_venv\\lib\\site-packages\\transformers\\generation\\utils.py:549, in GenerationMixin._prepare_encoder_decoder_kwargs_for_generation(self, inputs_tensor, model_kwargs, model_input_name, generation_config)\n    547 encoder_kwargs[\"return_dict\"] = True\n    548 encoder_kwargs[model_input_name] = inputs_tensor\n--&gt; 549 model_kwargs[\"encoder_outputs\"]: ModelOutput = encoder(**encoder_kwargs)\n    551 return model_kwargs\n\nFile c:\\Users\\hyunj\\Documents\\Development\\Python\\trouver_py310_venv\\lib\\site-packages\\torch\\nn\\modules\\module.py:1194, in Module._call_impl(self, *input, **kwargs)\n   1190 # If we don't have any hooks, we want to skip the rest of the logic in\n   1191 # this function, and just call forward.\n   1192 if not (self._backward_hooks or self._forward_hooks or self._forward_pre_hooks or _global_backward_hooks\n   1193         or _global_forward_hooks or _global_forward_pre_hooks):\n-&gt; 1194     return forward_call(*input, **kwargs)\n   1195 # Do not call functions when jit is used\n   1196 full_backward_hooks, non_full_backward_hooks = [], []\n\nFile c:\\Users\\hyunj\\Documents\\Development\\Python\\trouver_py310_venv\\lib\\site-packages\\transformers\\models\\t5\\modeling_t5.py:1106, in T5Stack.forward(self, input_ids, attention_mask, encoder_hidden_states, encoder_attention_mask, inputs_embeds, head_mask, cross_attn_head_mask, past_key_values, use_cache, output_attentions, output_hidden_states, return_dict)\n   1091     layer_outputs = self._gradient_checkpointing_func(\n   1092         layer_module.forward,\n   1093         hidden_states,\n   (...)\n   1103         output_attentions,\n   1104     )\n   1105 else:\n-&gt; 1106     layer_outputs = layer_module(\n   1107         hidden_states,\n   1108         attention_mask=extended_attention_mask,\n   1109         position_bias=position_bias,\n   1110         encoder_hidden_states=encoder_hidden_states,\n   1111         encoder_attention_mask=encoder_extended_attention_mask,\n   1112         encoder_decoder_position_bias=encoder_decoder_position_bias,\n   1113         layer_head_mask=layer_head_mask,\n   1114         cross_attn_layer_head_mask=cross_attn_layer_head_mask,\n   1115         past_key_value=past_key_value,\n   1116         use_cache=use_cache,\n   1117         output_attentions=output_attentions,\n   1118     )\n   1120 # layer_outputs is a tuple with:\n   1121 # hidden-states, key-value-states, (self-attention position bias), (self-attention weights), (cross-attention position bias), (cross-attention weights)\n   1122 if use_cache is False:\n\nFile c:\\Users\\hyunj\\Documents\\Development\\Python\\trouver_py310_venv\\lib\\site-packages\\torch\\nn\\modules\\module.py:1194, in Module._call_impl(self, *input, **kwargs)\n   1190 # If we don't have any hooks, we want to skip the rest of the logic in\n   1191 # this function, and just call forward.\n   1192 if not (self._backward_hooks or self._forward_hooks or self._forward_pre_hooks or _global_backward_hooks\n   1193         or _global_forward_hooks or _global_forward_pre_hooks):\n-&gt; 1194     return forward_call(*input, **kwargs)\n   1195 # Do not call functions when jit is used\n   1196 full_backward_hooks, non_full_backward_hooks = [], []\n\nFile c:\\Users\\hyunj\\Documents\\Development\\Python\\trouver_py310_venv\\lib\\site-packages\\transformers\\models\\t5\\modeling_t5.py:746, in T5Block.forward(self, hidden_states, attention_mask, position_bias, encoder_hidden_states, encoder_attention_mask, encoder_decoder_position_bias, layer_head_mask, cross_attn_layer_head_mask, past_key_value, use_cache, output_attentions, return_dict)\n    743     attention_outputs = attention_outputs + cross_attention_outputs[2:]\n    745 # Apply Feed Forward layer\n--&gt; 746 hidden_states = self.layer[-1](hidden_states)\n    748 # clamp inf values to enable fp16 training\n    749 if hidden_states.dtype == torch.float16:\n\nFile c:\\Users\\hyunj\\Documents\\Development\\Python\\trouver_py310_venv\\lib\\site-packages\\torch\\nn\\modules\\module.py:1194, in Module._call_impl(self, *input, **kwargs)\n   1190 # If we don't have any hooks, we want to skip the rest of the logic in\n   1191 # this function, and just call forward.\n   1192 if not (self._backward_hooks or self._forward_hooks or self._forward_pre_hooks or _global_backward_hooks\n   1193         or _global_forward_hooks or _global_forward_pre_hooks):\n-&gt; 1194     return forward_call(*input, **kwargs)\n   1195 # Do not call functions when jit is used\n   1196 full_backward_hooks, non_full_backward_hooks = [], []\n\nFile c:\\Users\\hyunj\\Documents\\Development\\Python\\trouver_py310_venv\\lib\\site-packages\\transformers\\models\\t5\\modeling_t5.py:335, in T5LayerFF.forward(self, hidden_states)\n    333 def forward(self, hidden_states):\n    334     forwarded_states = self.layer_norm(hidden_states)\n--&gt; 335     forwarded_states = self.DenseReluDense(forwarded_states)\n    336     hidden_states = hidden_states + self.dropout(forwarded_states)\n    337     return hidden_states\n\nFile c:\\Users\\hyunj\\Documents\\Development\\Python\\trouver_py310_venv\\lib\\site-packages\\torch\\nn\\modules\\module.py:1194, in Module._call_impl(self, *input, **kwargs)\n   1190 # If we don't have any hooks, we want to skip the rest of the logic in\n   1191 # this function, and just call forward.\n   1192 if not (self._backward_hooks or self._forward_hooks or self._forward_pre_hooks or _global_backward_hooks\n   1193         or _global_forward_hooks or _global_forward_pre_hooks):\n-&gt; 1194     return forward_call(*input, **kwargs)\n   1195 # Do not call functions when jit is used\n   1196 full_backward_hooks, non_full_backward_hooks = [], []\n\nFile c:\\Users\\hyunj\\Documents\\Development\\Python\\trouver_py310_venv\\lib\\site-packages\\transformers\\models\\t5\\modeling_t5.py:289, in T5DenseActDense.forward(self, hidden_states)\n    283 if (\n    284     isinstance(self.wo.weight, torch.Tensor)\n    285     and hidden_states.dtype != self.wo.weight.dtype\n    286     and self.wo.weight.dtype != torch.int8\n    287 ):\n    288     hidden_states = hidden_states.to(self.wo.weight.dtype)\n--&gt; 289 hidden_states = self.wo(hidden_states)\n    290 return hidden_states\n\nFile c:\\Users\\hyunj\\Documents\\Development\\Python\\trouver_py310_venv\\lib\\site-packages\\torch\\nn\\modules\\module.py:1194, in Module._call_impl(self, *input, **kwargs)\n   1190 # If we don't have any hooks, we want to skip the rest of the logic in\n   1191 # this function, and just call forward.\n   1192 if not (self._backward_hooks or self._forward_hooks or self._forward_pre_hooks or _global_backward_hooks\n   1193         or _global_forward_hooks or _global_forward_pre_hooks):\n-&gt; 1194     return forward_call(*input, **kwargs)\n   1195 # Do not call functions when jit is used\n   1196 full_backward_hooks, non_full_backward_hooks = [], []\n\nFile c:\\Users\\hyunj\\Documents\\Development\\Python\\trouver_py310_venv\\lib\\site-packages\\torch\\nn\\modules\\linear.py:114, in Linear.forward(self, input)\n    113 def forward(self, input: Tensor) -&gt; Tensor:\n--&gt; 114     return F.linear(input, self.weight, self.bias)\n\nKeyboardInterrupt: \n\n\n\nAfter running the above code, the predicted names for the definitions and notations should be contained in the definiiton and notation attributes of the HTML tags. If a notation attribute’s value remains blank \"\", then this effectively means that predicted name for the notation is the entire LaTeX math mode string that the HTML tags encompasses (recall that notation HTML tags only surround LaTeX math mode strings)\n\n\nCreating notation notes for the notations introduced in standard information notes\nOnce the notations have been marked with HTML tags and the notations have been named, we use the make_notation_notes_from_HTML_tags function to create new notes dedicated to each notation and to link these newly created notes\nThis part does not depend on any ML models. Run the following code:\n\nindex_note = VaultNote(vault, name=f'_index_{reference}')\nnotes = notes_linked_in_notes_linked_in_note(index_note, as_dict=False)\n\nfor note in notes:\n    try:\n        new_notes = make_notation_notes_from_HTML_tags(note, vault, reference_name=reference)\n    except Exception as e:\n        print(note.name)\n        raise(e)\n    # assert len(new_notes) == 0\n\nThe following is a comparison of the note before and after the above code is executed:\n\n\n\n\n\n\nIf some extraneously notation notes are created due to incorrectly marked HTML tags, you may remove/edit the HTML tags, delete tha notation note, and delete the link to the notation note.\nMoreover, even if some HTML tags had not been marked to indicate a notation introduced in a standard information note, running the above code again will safely create the notation note after the double asterisks are correctly added. make_notation_notes_from_HTML_tags attempts to create new notation notes without creating duplication notation notes.\nTODO: change the below to reflect recent version.\nFor example, the def_notat_classifier seems to have deemed the LaTeX strings $e(\\pi, q)$ and $e(\\pi,q)$ to introduce notations, and marked these latex strings with double asterisks **. The make_notation_notes_from_double_asts function above then created notation notes corresponding to these LaTeX strings. However, the author of trouver does not consider these strings to have actually introduced the notations (because the standard information note containing these strings does NOT define what these notations mean). Let us remove the double asterisks, delete the corresponding notation notes, and delete the links to these notation notes:\n\n\n\n\n\nSummarizing what the notations denote and recording the summaries in the notation notes\nFinally, we pass the summarizer pipeline to the append_summary_to_notation_note function to summarize what the notations denote and record these summaries in the notation notes:\nDepending on the length and number of notes, this may take at least several or dozens of minutes.\n\nindex_note = VaultNote(vault, name=f'_index_{reference}')\nnotes = notes_linked_in_notes_linked_in_note(index_note, as_dict=False)\n\nfor note in notes:\n    if not note.exists():\n        print(f\"note does not exist: {note.name}\")\n        raise Exception()\n\nprint(\"Summarizing notations\")\nfor note in notes:\n    notation_notes_linked_in_note = notation_notes_linked_in_see_also_section(note, vault)\n    for notation_note in notation_notes_linked_in_note:\n        append_summary_to_notation_note(notation_note, vault, summarizer)\n\nToken indices sequence length is longer than the specified maximum sequence length for this model (2259 &gt; 512). Running this sequence through the model will result in indexing errors\n\n\nSummarizing notations\n\n\nYour max_length is set to 200, but your input_length is only 184. Since this is a summarization task, where outputs shorter than the input are typically wanted, you might consider decreasing max_length manually, e.g. summarizer('...', max_length=92)\nYour max_length is set to 200, but your input_length is only 178. Since this is a summarization task, where outputs shorter than the input are typically wanted, you might consider decreasing max_length manually, e.g. summarizer('...', max_length=89)\nYour max_length is set to 200, but your input_length is only 163. Since this is a summarization task, where outputs shorter than the input are typically wanted, you might consider decreasing max_length manually, e.g. summarizer('...', max_length=81)\nYour max_length is set to 200, but your input_length is only 164. Since this is a summarization task, where outputs shorter than the input are typically wanted, you might consider decreasing max_length manually, e.g. summarizer('...', max_length=82)\nYour max_length is set to 200, but your input_length is only 164. Since this is a summarization task, where outputs shorter than the input are typically wanted, you might consider decreasing max_length manually, e.g. summarizer('...', max_length=82)\n\n\nThe following is a comparison of the notation note before and after the append_summary_to_notation_note function is applied to the notation note:\n\n\n\n\n\n\nNote that the _auto/notation_summary tag is added to the notation note’s YAML frontmatter meta data to indicate that the summarizer pipeline generated the summary.\nWe highly recommend manually editing the notation note as follows:\n\nCorrect the notation LaTeX string if necessary (in this example, the notation is the string $F_q(X,Y)$ before the link [[kimpark_ga1dcmmc_29|denotes]] and it looks like there is nothing to correct. However, corrections might be necessary more generally, e.g. )\nRename the notation notes to be more searchable. Recall that Obsidian’s Quick switcher provides suggestions for notes to open based on note/file names.\nCorrect the autogenerated summary and remove the _auto/notation_summary tag.\n\n\nWarning The model is currently not robust enough to generate reliable summaries in general. The model especially struggles with generating LaTeX strings.\n\nFor example, this is what the notation note for the string `$F_q(X,Y)$` looks just after the autogenerated summary has been added:\n\n\n\n\n\n\nLet us fix the summary, remove the _auto/notation_summary tag (to indicate that the summary in the notation note is no longer autogenerated), and rename the note as follows:\n\n\n\n\n\n\n\nIf the “notation note” does not correspond to a LaTeX string in a standard information note, then delete the “notation note”.",
    "crumbs": [
      "tutorial.walkthrough"
    ]
  },
  {
    "objectID": "tutorial.walkthrough.html#applications-of-the-notation-notes",
    "href": "tutorial.walkthrough.html#applications-of-the-notation-notes",
    "title": "tutorial.walkthrough",
    "section": "Applications of the notation notes",
    "text": "Applications of the notation notes\nWe also recommend using notation notes in the following ways:\n\nEmbed notation notes in footnotes\nIt can be useful to (manually) embed notation notes in standard notation notes in footnotes. For example, the following is a (standard information) note presenting a lemma about \\(F_q(X,Y)\\):\n\n\n\nLet us add a footnote with the notation note for the notation \\(F_q(X,Y)\\) embedded:\n\n\n\n\n\n\nLet us now view the standard information note in Viewing mode:\n\n\n\nThe following is what the bottom of the note looks like. Note that the notation note has been embedded:\n\n\n\nIn particular, the footnote indicates to the reader/user that the LaTeX string $F_q(s_0,s_1)$ depends upon the notation \\(F_q(X,Y)\\), which denotes the monic minimal polynomial of the closed point \\(q \\in \\mathbb{P}^1_k\\). Such footnotes can be useful for users who need to remind themselves of mathematical facts, but have difficulties recalling the precise denotations of various notations.\n\n\nLink notation notes in other notation notes.\nWhile we do not recommend embedding notation notes into other notation notes (because such efforts might result in multi-level embeddings of notation notes or even circular embeddings of notation notes), we still recommend linking notation notes in other notation notes.\nFor example, we can write the following notation note:\n---\ndetect_regex: []\nlatex_in_original: [\"e(\\\\pi,q)\"]\ntags: []\n---\n$e(\\pi,q)$ [[kim_park_ga1dcmmc_Definition 3.2|denotes]] the Euler number $e(\\pi^* \\mathscr{O}_{\\mathbb{P}^1_k}(\\deg F_q), F_q(s_0,s_1))$ where $q \\in \\mathbb{P}^1_k$ is a closed point and $\\pi: C \\to \\mathbb{P}^1_k$ is a finite morphism over a field $k$ whose characteristic is not $2$ where $C$ is a smooth projective curve, assuming that $\\pi^*(\\mathscr{O}_{\\mathbb{P}^1_k}(\\deg F_q))$ is a relatively orientable line bundle of $C$.\n\n- [$e(V,f)$](kim_park_ga1dcmmc_notation_e_V_f_euler_number_of_global_section_of_relatively_orientable_vector_bundle)\n- [$F_q(X,Y)$](kim_park_ga1dcmmc_notation_F_q_X_Y_monic_minimal_polynomial_of_closed_point_in_P_1)\nNote that External links/Markdownstyle links are used to link to the other notation notes as opposed to Internal links/Wikilink-styled links. We use external links/Markdownstyle links here because Obsidian internal links/Wikilink-styled links do not render LaTeX strings.\nThis note displays as\n\n\n\nNote that one can hover the cursor above links in Obsidian to show a preview of the linked note:",
    "crumbs": [
      "tutorial.walkthrough"
    ]
  },
  {
    "objectID": "markdown.obsidian.links.html",
    "href": "markdown.obsidian.links.html",
    "title": "markdown.obsidian.links",
    "section": "",
    "text": "Obsidian uses both Markdown style links and Wikilinks as internal links. Markdown style links are of the form [text_shown](link) whereas Wikilinks are of the form [[link_to_markdown#possible_anchor_to_header|text_shown]]. They have an exclamation mark ! if they are embedded.\nWithin Obsidian, it is often more convenient to use Wikilinks for Vault-internal links for several reasons:\nNevertheless, Markdown style links have the following functions which Wikilinks lack:\nfrom os import PathLike\n\nfrom fastcore.test import *\nfrom nbdev.showdoc import show_doc",
    "crumbs": [
      "markdown.obsidian.links"
    ]
  },
  {
    "objectID": "markdown.obsidian.links.html#finding-links-in-text-via-indices",
    "href": "markdown.obsidian.links.html#finding-links-in-text-via-indices",
    "title": "markdown.obsidian.links",
    "section": "Finding links in text via indices",
    "text": "Finding links in text via indices\n\nsource\n\nlink_ranges_in_text\n\n link_ranges_in_text (text:str)\n\n*Return ranges in the markdown text string where internal links occur.\nSee Also\n\nlinks_from_text*\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ntext\nstr\n\n\n\nReturns\nlist\nEach tuple is of the form (a,b) where text[a:b] is an obsidian internal link.\n\n\n\nlink_ranges_in_text returns a list of indices in a string in which the links are located.\n\ntutorial_text = r'''\nThis is an Obsidian note. It has some [[this_is_the_note_to_which_the_link_points|links]]!\nLinks are pretty neat. They can [[this_text_is_not_actually_shown|connect notes]] for you.\nThe following will create a link to the note `some_note`; the displayed text is `some_note`: [[some_note]]\nYou can also embed the contents of one note into another note. ![[note_being_embedded]].\nThe contents of `note_being_embedded` will be displayed when you view the note in Obsidian's view mode.\nYou can make anchors in links. For example [[note#This is a header title]] is a link to the note named\n`note` and more specifically to the theader with title `This is a header title`.\n\nThe above links are all Wikilinks. Obsidian also supports Markdownlinks, e.g. [This is the text shown](This is the link.)\n\nHow about a link to an anchor? [[note_name#heading]]\n\nIf the note of a link does not exist in an Obsidian vault, then Obsidian will create the note.\nEven if the note does not have a header with title specified by the anchor of a link, Obsidian\nwill still open the note; it will not go to any particular header, however.\n\nThis is a Markdownstyle link: [hello](note_name.md).\n\nThis is an embedded markdownstyle link: ![hallo!](other_note_name.md)\n\n'''\n\nranges = link_ranges_in_text(tutorial_text)\nmatch_strs = [tutorial_text[start:end] for start, end in ranges]\ntest_eq(match_strs, [\n    '[[this_is_the_note_to_which_the_link_points|links]]', \n    '[[this_text_is_not_actually_shown|connect notes]]',\n    '[[some_note]]',\n    '![[note_being_embedded]]',\n    '[[note#This is a header title]]',\n    '[This is the text shown](This is the link.)',\n    '[[note_name#heading]]',\n    '[hello](note_name.md)',\n    '![hallo!](other_note_name.md)'\n    ])",
    "crumbs": [
      "markdown.obsidian.links"
    ]
  },
  {
    "objectID": "markdown.obsidian.links.html#obsidianlink-class",
    "href": "markdown.obsidian.links.html#obsidianlink-class",
    "title": "markdown.obsidian.links",
    "section": "ObsidianLink class",
    "text": "ObsidianLink class\n\nsource\n\nLinkFormatError\n\n LinkFormatError (text)\n\n*Error that is raised when a string cannot be parsed as an ObsidianLink object.\nAttribute\n\ntext - str*\n\n\nsource\n\n\nLinkType\n\n LinkType (value, names=None, module=None, qualname=None, type=None,\n           start=1)\n\n*An Enumeration indicating whether an ObsidianLink object is a Wikilink or a Markdown-style link.\nEnumerates LinkType.WIKILINK and LinkType.MARKDOWN.*\n\nsource\n\n\nObsidianLink\n\n ObsidianLink (is_embedded:bool, file_name:Union[str,int],\n               anchor:Union[str,int], custom_text:Union[str,int],\n               link_type:__main__.LinkType=&lt;LinkType.WIKILINK: 0&gt;)\n\n*Object representing an obsidian link\nAttributes\n\nis_embedded - bool\n\nWhether or not the link is embedded.\n\nfile_name - str, or -1\n\nThe destination of the link. It is either\n\nThe Obsidian-vault-recognized name of the file that the link points to. It can be a path relative to the Obsidian vault path without the file extension (.md),\nan external link, such as a URL, or\n-1, in which case the object represents a generic link pointing to any file (this is for generating regex).\n\nNote that if file_name is the empty string, then the link is a link to the same file\n\nanchor - str, 0, or -1\n\nThe title of the header of the anchor in the destination that the link points to or the ID to the markdown block link (preceded by a carat ^). If 0, then the ObsidianLink object represents a link without an anchor. If -1, then the object represents a generic link with or without an anchor (this is for generating regex).\n\ncustom_text - str, 0, or -1\n\nThe custom text of the link. Is None if no such text is specified. If 0, then the ObsidianLink object represents an internal link without custom text. If -1, then the object represents a generic internal link of any custom text (this is for generating regex).\n\nlink_type - LinkType\n\nIf LinkType.WIKILINK, then the str should be of the format '[[&lt;Obsidian-vault-recognized-name&gt;(#anchor)?(|custom_text)]]' (The question marks here indicate optional components). Otherwise, the str should be a more standard Markdown link. Defaults to LinkType.WIKILINK.\n\n\nParameters\n\nis_embedded - bool\nfile_name - str or None\n\nIf None, set self.file_name to -1.\n\nanchor - str or None\ncustom_text - str or None\nlink_type - LinkType*\n\n\nsource\n\n\nObsidianLink.from_text\n\n ObsidianLink.from_text (text:str)\n\n*Return an ObsidianLink object from text.\nRaises\n\nInteralLinkFormatError\n\nIf text is not properly formatted as an Obsidian internal link.*\n\n\n\nsource\n\n\nObsidianLink.to_regex\n\n ObsidianLink.to_regex ()\n\n*Return the regex for that this ObsidianLink object represents.\nAssumes that self.file_name, self.anchor, and self.custom_text are regex-formatted strings, e.g. if self.custom_text is denotes?, then the outputted regex-pattern matches links whose custom text is either denote or denotes.\nIf neither self.file_name, self.anchor nor self.custom_text is -1, then the regex will in fact be a concrete string.*\n\nsource\n\n\nObsidianLink.__str__\n\n ObsidianLink.__str__ ()\n\nReturn str(self).\n\nsource\n\n\nObsidianLink.to_string\n\n ObsidianLink.to_string ()\n\n*Return the string for the link if it is concrete.\nRaises\n\nValueError\n\nIf self.file_name, self.anchor or self.custom_text is -1, i.e. ambiguously represents an anchor or custom text.*\n\n\n\nsource\n\n\nObsidianLink.convert_link_type\n\n ObsidianLink.convert_link_type (link_type:__main__.LinkType)\n\nReturn an equivalent Link object which has the specified LinkType.\n\nsource\n\n\nObsidianLink.displayed_text\n\n ObsidianLink.displayed_text ()\n\n*Returns the displayed text of this link.\nself.file_name, self.custom_text and self.anchor are assumed to be not -1.*\n\nsource\n\n\nObsidianLink.is_abstract\n\n ObsidianLink.is_abstract ()\n\nReturn True if self is abstract, i.e. file_name, anchor, or custom_text is -1.\n\nParsing an ObsidianLink class from a string\nThe following example parses a Wikilink with an anchor and a custom display text:\n\ninternal_link = ObsidianLink.from_text(\"[[smooth_covering_map#Smooth covering map 1|smooth covering map]]\")\nassert internal_link.file_name == \"smooth_covering_map\"\nassert internal_link.anchor == \"Smooth covering map 1\"\nassert internal_link.custom_text == \"smooth covering map\"\n\nThe following example parses a Wikilink with an anchor, but not with a custom display text:\n\ninternal_link = ObsidianLink.from_text(\"[[sample_thing#anchor]]\")\nassert internal_link.file_name == \"sample_thing\"\nassert internal_link.anchor == \"anchor\"\nassert internal_link.custom_text == 0\n\nThe following example parses a Wikilink without an anchor, but with custom display text:\n\ninternal_link = ObsidianLink.from_text(\"[[another_file|this_is_the_text_shown]]\")\nassert internal_link.file_name == \"another_file\"\nassert internal_link.anchor == 0\nassert internal_link.custom_text == \"this_is_the_text_shown\"\n\nThe following example parses a Wikilink without neither an anchor nor custom display text:\n\ninternal_link = ObsidianLink.from_text(\"[[notation_I_S_ideal_of_vanishing_on_a_subset_of_the_spectrum_of_a_ring]]\")\nassert internal_link.file_name == \"notation_I_S_ideal_of_vanishing_on_a_subset_of_the_spectrum_of_a_ring\"\nassert internal_link.anchor == 0\nassert internal_link.custom_text == 0\n\nThe following example parses an embedded (Wiki)link\n\ninternal_link = ObsidianLink.from_text(\"![[_reference_some_reference]]\")\nassert internal_link.file_name == \"_reference_some_reference\"\nassert internal_link.anchor == 0\nassert internal_link.custom_text == 0\n\nThe following example parses a Markdownlink with an anchor:\n\ninternal_link = ObsidianLink.from_text(\"[asdf](localization_of_a_module#Localization of a module 1)\")\nassert internal_link.file_name == \"localization_of_a_module\"\nassert internal_link.anchor == \"Localization of a module 1\"\nassert internal_link.custom_text == \"asdf\"\n\nThe following example parses a Markdownlink with some spaces formatted as %20:\n\ninternal_link = ObsidianLink.from_text(r\"[do do](Some%20note#Topic%201)\")\nassert internal_link.file_name == \"Some note\"\nassert internal_link.anchor == \"Topic 1\"\nassert internal_link.custom_text == \"do do\"\n\nThe following example parses a Markdownlink in which the displaytext has LaTeX in it:\n\ninternal_link = ObsidianLink.from_text(\"[$\\\\mathscr{O}(n)$](some_reference_notation_O_n_on_projective_scheme)\")\nassert internal_link.file_name == \"some_reference_notation_O_n_on_projective_scheme\"\nassert internal_link.anchor == 0\nassert internal_link.custom_text == \"$\\\\mathscr{O}(n)$\"\n# TODO test links with file_name = -1\n\n\nsource\n\n\n\nObsidianLink.__copy__\n\n ObsidianLink.__copy__ ()\n\n\nlink = ObsidianLink(\n        is_embedded=False,\n        file_name=\"test_file\",\n        anchor=\"test_anchor\",\n        custom_text=\"test_custom\",\n        link_type=LinkType.WIKILINK\n    )\nlink_copy = link.__copy__()\n\ntest_eq(link_copy, link)\ntest_eq(link_copy.is_embedded, link.is_embedded)\ntest_eq(link_copy.file_name, link.file_name)\ntest_eq(link_copy.anchor, link.anchor)\ntest_eq(link_copy.custom_text, link.custom_text)\ntest_eq(link_copy.link_type, link.link_type)\n\n\nsource\n\n\nObsidianLink.__eq__\n\n ObsidianLink.__eq__ (other)\n\nReturn self==value.\n\nlink1 = ObsidianLink(\n    is_embedded=False,\n    file_name=\"test_file\",\n    anchor=\"test_anchor\",\n    custom_text=\"test_custom\",\n    link_type=LinkType.WIKILINK\n)\nlink2 = ObsidianLink(\n    is_embedded=True,\n    file_name=\"another_file\",\n    anchor=0,\n    custom_text=0,\n    link_type=LinkType.MARKDOWN\n)\nlink1_copy = link1.__copy__()\n\ntest_eq(link1, link1_copy)\ntest_ne(link1, link2)\ntest_ne(link1, \"Not an ObsidianLink\")\n\n\nlink1 = ObsidianLink(\n    is_embedded=False,\n    file_name=\"test_file\",\n    anchor=\"test_anchor\",\n    custom_text=\"test_custom\",\n    link_type=LinkType.WIKILINK\n)\n\nlink1_different_embedded = ObsidianLink(\n    is_embedded=not link1.is_embedded,\n    file_name=link1.file_name,\n    anchor=link1.anchor,\n    custom_text=link1.custom_text,\n    link_type=link1.link_type\n)\ntest_ne(link1, link1_different_embedded)\n\nlink1_different_file_name = ObsidianLink(\n    is_embedded=link1.is_embedded,\n    file_name=\"different_file\",\n    anchor=link1.anchor,\n    custom_text=link1.custom_text,\n    link_type=link1.link_type\n)\ntest_ne(link1, link1_different_file_name)\n\n\nConstructing abstract ObsidianLink objets\nWe might want to detect links in Obsidian Markdown notes of certain formats. Constructing ObsidianLink objects via the constructor can help with this.\nSetting file_name, anchor, or custom_text to -1 can yields an ObisidianLink object representing an abstract link. Use the to_regex function of the ObsidianLink object to get a regex str which detects links of the specified format.\nIn the following example, the anchor and custom text of the ObsidianLink object are both abstract - the regex pattern returned by ._to_regex will detect any link of the specified type (by default, LinkType.WIKILINK) with the specified file name:\n\ninternal_link_object = ObsidianLink(is_embedded=False, file_name = 'hi', anchor=-1, custom_text=-1)\nregex_pattern = internal_link_object.to_regex()\nprint(f'regex_pattern: {regex_pattern}')\nassert re.match(regex_pattern, '[[hi#this is some anchor|this is some display text]]')\nassert re.match(regex_pattern, '[[hi|some display text, but no anchor!]]')\nassert re.match(regex_pattern, '[[hi#some anchor, but no custom text]]')\nassert re.match(regex_pattern, '[[hi]]')  #No anchor and no custom text\nassert not re.match(regex_pattern, '[[note_with_wrong_name]]')\n\nregex_pattern: \\[\\[hi(#(.*?))?(\\|(.*?))?\\]\\]\n\n\nThe following is an example where the custom_text is specified, but the file_name and anchor are both abstract:\n\ninternal_link_object = ObsidianLink(is_embedded=False, file_name = -1, anchor=-1, custom_text='must match this text!')\nregex_pattern = internal_link_object.to_regex()\nprint(f'regex_pattern: {regex_pattern}')\nassert re.match(regex_pattern, '[[some note#some anchor|must match this text!]]')\n# TODO: matching the below is not currently implemented.\n# assert re.match(regex_pattern, '[[must match this text!]]')\nassert re.match(regex_pattern, '[[some note|must match this text!]]')\nassert re.match(regex_pattern, '[[#anchor in note|must match this text!]]')  #No anchor and no custom text\nassert not re.match(regex_pattern, '[[some note#some anchor|Wrong text]]')\n\nregex_pattern: \\[\\[([^#\\|]*)?(#(.*?))?\\|must match this text!\\]\\]\n\n\nIn the following example, the linktype is specified to be LinkeType.MARKDOWN:\n\ninternal_link_object = ObsidianLink(is_embedded=False, file_name = 'hi', anchor=-1, custom_text=-1, link_type=LinkType.MARKDOWN)\nregex_pattern = internal_link_object.to_regex()\nprint(f'regex_pattern: {regex_pattern}')\nassert re.match(regex_pattern, '[Some custom text](hi#Some anchor)')\nassert re.match(regex_pattern, '[Some custom text, no anchor](hi)')\nassert not re.match(regex_pattern, '[Some custom text, link an anchor in the same note](#anchor)')\n\nregex_pattern: \\[(.*?)?\\]\\(hi(#(.*?))?\\)\n\n\n\n\n\nString of an ObsidianLink object\nA concrete ObsidianLink object has a to_string function:\n\ninternal_link_object = ObsidianLink(is_embedded=True, file_name = 'compactly_generated_product_hom_adjunction', anchor='Title', custom_text='compactly generated', link_type=LinkType.WIKILINK)\nprint(internal_link_object.to_string())\ninternal_link_object = ObsidianLink(is_embedded=True, file_name = 'compactly_generated_product_hom_adjunction', anchor='Title 1', custom_text='compactly generated', link_type=LinkType.MARKDOWN)\nprint(internal_link_object.to_string())\n\n![[compactly_generated_product_hom_adjunction#Title|compactly generated]]\n![compactly generated](compactly_generated_product_hom_adjunction#Title%201)",
    "crumbs": [
      "markdown.obsidian.links"
    ]
  },
  {
    "objectID": "markdown.obsidian.links.html#find-the-links-in-text-as-obsidianlink-objects",
    "href": "markdown.obsidian.links.html#find-the-links-in-text-as-obsidianlink-objects",
    "title": "markdown.obsidian.links",
    "section": "Find the links in text as ObsidianLink objects",
    "text": "Find the links in text as ObsidianLink objects\n\nsource\n\nlinks_from_text\n\n links_from_text (text:str)\n\nReturn a list of ObsidianLink objects corresponding to links found in the text.\n\n\n\n\nType\nDetails\n\n\n\n\ntext\nstr\n\n\n\nReturns\nlist\nThe ObsidianLink objects are ordered by appearance.\n\n\n\nUnlike link_ranges_in_text, the links_from_text function returns a list of ObsidianLink objects instead.\n\nlinks = links_from_text(tutorial_text)\nassert links[0].displayed_text() == 'links'  # The displayed text of [[this_is_the_note_to_which_the_link_points|links]] is `links`.\nassert links[3].is_embedded  # ![[note_being_embedded]] is an embedded link\nassert links[4].anchor == 'This is a header title'  # [[note#This is a header title]] has anchor `This is a header title`.",
    "crumbs": [
      "markdown.obsidian.links"
    ]
  },
  {
    "objectID": "markdown.obsidian.links.html#removing-links-from-text",
    "href": "markdown.obsidian.links.html#removing-links-from-text",
    "title": "markdown.obsidian.links",
    "section": "Removing links from text",
    "text": "Removing links from text\n\nsource\n\nremove_links_from_text\n\n remove_links_from_text (text:str,\n                         exclude:list[__main__.ObsidianLink]=None,\n                         remove_embedded_note_links:bool=False)\n\nReturn a text with all Obsidian links removed and replaced with the display texts of the links.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ntext\nstr\n\n\n\n\nexclude\nlist\nNone\nA list of ObsidianLink objects of links to not be removed.\n\n\nremove_embedded_note_links\nbool\nFalse\nIf True, remove links to embedded notes as well. Note that embedded links are replaced by their “display” text in the same manner as non-embedded links and are not replaced the content of the embedding. If False, does not modify embedded note links.\n\n\nReturns\nstr\n\n\n\n\n\nWe can remove all links of from text and preserve the underlying display text of each link:\n\ntext = 'I have a [[this is a note#this is an anchor in the note|link]]'\nlinks_removed = remove_links_from_text(text)\nprint(links_removed)\nassert links_removed == 'I have a link'\n\ntext = 'Something about a [[some_reference_conormal_sheaf_of_a_locally_closed_embedding#For a locally closed embedding 2 4|conormal sheaf]]'\nlinks_removed = remove_links_from_text(text)\nprint(links_removed)\nassert links_removed == 'Something about a conormal sheaf'\n\ntext = 'This is a link without a specified display text: [[some_kind_of_note]].'\nlinks_removed = remove_links_from_text(text)\nprint(links_removed)\nassert links_removed == 'This is a link without a specified display text: some_kind_of_note.'\n\ntext = 'This is a link to an anchor without a specified display text: [[another_note#another anchor]].'\nlinks_removed = remove_links_from_text(text)\nprint(links_removed)\nassert links_removed == 'This is a link to an anchor without a specified display text: another_note &gt; another anchor.'\n\nI have a link\nSomething about a conormal sheaf\nThis is a link without a specified display text: some_kind_of_note.\nThis is a link to an anchor without a specified display text: another_note &gt; another anchor.\n\n\nWe can specify links to not remove in this process:\n\ntext = 'This thing [[some note|denotes]] something'\ndo_not_remove_link = ObsidianLink(False, None, -1, 'denote(s)?')\nlinks_removed = remove_links_from_text(text, exclude=[do_not_remove_link])\nassert text == links_removed\n\nThis function does not remove embedded links by default.\n\ntext = '![[embedded note]]'\nlinks_removed = remove_links_from_text(text)\nprint(links_removed)\nassert links_removed == text\n\n![[embedded note]]\n\n\n\ntext = '![[embedded note]]'\nlinks_removed = remove_links_from_text(text, remove_embedded_note_links=True)\nprint(links_removed)\nassert links_removed == 'embedded note'\n\nembedded note",
    "crumbs": [
      "markdown.obsidian.links"
    ]
  },
  {
    "objectID": "markdown.obsidian.links.html#replacing-links-in-text",
    "href": "markdown.obsidian.links.html#replacing-links-in-text",
    "title": "markdown.obsidian.links",
    "section": "Replacing links in text",
    "text": "Replacing links in text\n\nsource\n\nreplace_links_in_text\n\n replace_links_in_text (text:str, links_to_replace:__main__.ObsidianLink,\n                        new_link_name:str)\n\nModify all links matching links_to_replace so that the the new destination is new_link_name.\n\n\n\n\nType\nDetails\n\n\n\n\ntext\nstr\n\n\n\nlinks_to_replace\nObsidianLink\n\n\n\nnew_link_name\nstr\n\n\n\nReturns\nstr\nlink_to_replace_with \n\n\n\n\n# Test case 1: Replace a single wikilink\ntext1 = \"This is a [[test link]] in the text.\"\nlink_to_replace1 = ObsidianLink(False, \"test link\", 0, 0, LinkType.WIKILINK)\nnew_link_name1 = \"new link\"\nexpected1 = \"This is a [[new link]] in the text.\"\ntest_eq(replace_links_in_text(text1, link_to_replace1, new_link_name1), expected1)\n\n# Test case 2: Replace multiple wikilinks\ntext2 = \"[[link1]] and [[link1]] are the same.\"\nlink_to_replace2 = ObsidianLink(False, \"link1\", 0, 0, LinkType.WIKILINK)\nnew_link_name2 = \"updated_link\"\nexpected2 = \"[[updated_link]] and [[updated_link]] are the same.\"\ntest_eq(replace_links_in_text(text2, link_to_replace2, new_link_name2), expected2)\n\n# Test case 3: Replace markdown links\ntext3 = \"This is a [markdown link](test_file.md) in the text.\"\nlink_to_replace3 = ObsidianLink(False, \"test_file.md\", 0, \"markdown link\", LinkType.MARKDOWN)\nnew_link_name3 = \"new_file.md\"\nexpected3 = \"This is a [markdown link](new_file.md) in the text.\"\ntest_eq(replace_links_in_text(text3, link_to_replace3, new_link_name3), expected3)\n\n# Test case 4: Replace links with anchors\ntext4 = \"See [[file#section]] for more info.\"\nlink_to_replace4 = ObsidianLink(False, \"file\", \"section\", 0, LinkType.WIKILINK)\nnew_link_name4 = \"new_file\"\nexpected4 = \"See [[new_file#section]] for more info.\"\ntest_eq(replace_links_in_text(text4, link_to_replace4, new_link_name4), expected4)\n\n# Test case 5: Replace embedded links\ntext5 = \"An embedded image: ![[image.png]]\"\nlink_to_replace5 = ObsidianLink(True, \"image.png\", 0, 0, LinkType.WIKILINK)\nnew_link_name5 = \"new_image.png\"\nexpected5 = \"An embedded image: ![[new_image.png]]\"\ntest_eq(replace_links_in_text(text5, link_to_replace5, new_link_name5), expected5)\n\n# Test case 6: No matches in text\ntext6 = \"This text has no links to replace.\"\nlink_to_replace6 = ObsidianLink(False, \"nonexistent\", 0, 0, LinkType.WIKILINK)\nnew_link_name6 = \"anything\"\nexpected6 = \"This text has no links to replace.\"\ntest_eq(replace_links_in_text(text6, link_to_replace6, new_link_name6), expected6)\n\n# Test case 7: Replace links with custom text\ntext7 = \"See [[file|Custom Text]] for details.\"\nlink_to_replace7 = ObsidianLink(False, \"file\", 0, \"Custom Text\", LinkType.WIKILINK)\nnew_link_name7 = \"new_file\"\nexpected7 = \"See [[new_file|Custom Text]] for details.\"\ntest_eq(replace_links_in_text(text7, link_to_replace7, new_link_name7), expected7)",
    "crumbs": [
      "markdown.obsidian.links"
    ]
  },
  {
    "objectID": "latex.convert.html",
    "href": "latex.convert.html",
    "title": "latex.convert",
    "section": "",
    "text": "This module contains functions and methods to automatically make Obsidian notes from LaTeX files of mathematical papers, most notably those on arXiv.\nSee the Potential Problems section below for some common errors that arise from this module and how to circumvent them.\nimport glob\nimport shutil\nimport tempfile\n\n\nfrom fastcore.test import ExceptionExpected, test_eq\nfrom pathvalidate import validate_filename\n\nfrom trouver.helper.tests import _test_directory# , non_utf8_chars_in_file\nfrom trouver.markdown.obsidian.personal.reference import (\n    delete_reference_folder\n)",
    "crumbs": [
      "latex.convert"
    ]
  },
  {
    "objectID": "latex.convert.html#potential-problems",
    "href": "latex.convert.html#potential-problems",
    "title": "latex.convert",
    "section": "Potential problems",
    "text": "Potential problems\nThe following are some frequently problems that arise when using this module:\n\nUnicodeDecodeErrors arise when reading LaTeX files\nBy default, the text_from_file method in trouver.helper reads files and attempts to decode them in utf-8. If a LaTeX file has characters that cannot be decoded into utf-8, then a UnicodeDecodeError may be raised. In this case, one can find identify these characters using the trouver.helper.non_utf8_chars_in_file method and modify the LaTeX file manually. It may be useful to use a text editor to jump to the positions that the characters are at and to change the encoding of the LaTeX file into utf-8; for example, the author of trouver has opened some ANSI-encoded LaTeX documents in Notepad++ and converted their encoding into UTF-8.\n\n\nNoDocumentNodeErrors arise even though the LaTeX file has a document environemt (i.e. \\begin{document}...\\end{document})\nThe find_document_node method in this module sometimes is not able to detect the docment environment of a LaTeX file. This error is known to arise when - there are macros (which include commands) defined that represents/expands to characters including \\begin{...}... \\end{...}. For example\n\n# TODO in the above explanation, include an example.",
    "crumbs": [
      "latex.convert"
    ]
  },
  {
    "objectID": "latex.convert.html#setup-an-obsidian-vault-reference",
    "href": "latex.convert.html#setup-an-obsidian-vault-reference",
    "title": "latex.convert",
    "section": "Setup an Obsidian vault reference",
    "text": "Setup an Obsidian vault reference\n\nsource\n\nsetup_reference_from_latex_parts\n\n setup_reference_from_latex_parts (parts:list[tuple[str,str]],\n                                   custom_commands:list[tuple[str,int,typi\n                                   ng.Optional[str],str]],\n                                   vault:os.PathLike,\n                                   location:os.PathLike,\n                                   reference_name:os.PathLike,\n                                   authors:Union[str,list[str]], author_fo\n                                   lder:os.PathLike='_mathematicians', cre\n                                   ate_reference_file_in_references_folder\n                                   :bool=True, references_folder:os.PathLi\n                                   ke='_references', create_template_file_\n                                   in_templates_folder:bool=True, template\n                                   s_folder:os.PathLike='_templates', temp\n                                   late_file_name:str='_template_common', \n                                   notation_index_template_file_name:str='\n                                   _template_notation_index', glossary_tem\n                                   plate_file_name:str='_template_glossary\n                                   ', setup_temp_folder:bool=True, make_se\n                                   cond_template_file_in_reference_directo\n                                   ry:bool=True, copy_obsidian_configs:Opt\n                                   ional[os.PathLike]='.obsidian',\n                                   overwrite:Optional[str]=None,\n                                   confirm_overwrite:bool=True,\n                                   verbose:bool=False,\n                                   replace_custom_commands:bool=True, adju\n                                   st_common_latex_syntax_to_markdown:bool\n                                   =True,\n                                   repeat_replacing_custom_commands:int=1)\n\n*Set up a reference folder in vault using an output of divide_latex_text, create notes from parts, and link notes in index files in the reference folder.\nAssumes that\n\nparts is derived from a LaTeX document in which\n\nall of the text belongs to sections.\nall of the sections/subsections are uniquely named\n\nThe template file is has a section # Topic\nThe last line of the template file is a footnote indicating where the note comes from.\nThere is at most one reference folder in the vault whose name is given by reference_name.\n\nparts itself is not modified, even if replace_custom_commands and/or adjust_common_latex_syntax_to_markdown are set to True.\ncf. setup_folder_for_new_reference for how the reference folder is set up..\nThe names for the subfolders of the reference folder are the section titles, except for sections with common titles such as Introduction, Notations, Conventions, Preliminaries, and Notations and Conventions. This ensures that the index file names for sections in different reference folders do not have the same name.\nText/parts that precede explicitly given sections are included in the first section’s folder and are linked in the first section’s index file.*\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nparts\nlist\n\nOutput of divide_latex_text\n\n\ncustom_commands\nlist\n\nOutput of custom_commands applied to the preamble of the LaTeX ddocument.| | vault | PathLike |  | An Obsidian.md vault, | | location | PathLike |  | The path to make the new reference folder. Relative tovault. | | reference_name | PathLike |  | The name of the new reference. | | authors | Union |  | Each str is the family name of each author. | | author_folder | PathLike | _mathematicians | The directory where the author files are stored in. Relative tovault. | | create_reference_file_in_references_folder | bool | True | IfTrue, then the reference file creation is attempted withinreferences_folder. Otherwise, the reference file creation is attempted at the base of the newly setup folder for the reference.. | | references_folder | PathLike | _references | The directory where the references files are stored in. Relative tovault. | | create_template_file_in_templates_folder | bool | True | IfTrue, then the template file creation is attempted withintemplates_folder. Otherwise, the template file creation is attempted at the base of the newly setup folder for the reference. | | templates_folder | PathLike | _templates | The directory where the template files are stored in. Relative tovault. | | template_file_name | str | _template_common | The template file from which to base the template file of the new reference. | | notation_index_template_file_name | str | _template_notation_index | The template file from which to base the notation index file of the new reference. | | glossary_template_file_name | str | _template_glossary | The template file from which to base the glossary file of the new reference. | | setup_temp_folder | bool | True | IfTrue, creates a_tempfolder with an index file. This folder serves to house notes auto-created from LaTeX text files before moving them to their correct directories. Defaults toTrue. | | make_second_template_file_in_reference_directory | bool | True | IfTrue, creates a copy of the template note within the directory for the reference. | | copy_obsidian_configs | Optional | .obsidian | The folder relative tovaultfrom which to copy obsidian configs.  IfNone, then no obsidian configs are copied to the reference folder. Defaults to.obsidian. | | overwrite | Optional | None | Specifies if and how to overwrite the reference folder if it already exists.  - If‘w’, then deletes the contents of the existing reference folder, as well as the template and reference file before setting up the reference folder before creating the new reference folder.  - If‘a’, then overwrites the contents of the reference folder, but does not remove existing files/folders.  - IfNone, then does not modify the existing reference folder and raises aFileExistsError. | | confirm_overwrite | bool | True | Specifies whether or not to confirm the deletion of the reference folder if it already exists and ifoverwriteis‘w’. Defaults toTrue. | | verbose | bool | False |  | | replace_custom_commands | bool | True | IfTrue, replace the custom commands in the text ofpartswhen making the notes. | | adjust_common_latex_syntax_to_markdown | bool | True | IfTrue, apply [adjust_common_syntax_to_markdown](https://hyunjongkimmath.github.io/trouver/latex.formatting.html#adjust_common_syntax_to_markdown) to the text inpartswhen making the notes.\n\n\nrepeat_replacing_custom_commands\nint\n1\nThe number of times to repeat replacing the custom commands throughout the text; note that some custom commands could be “nested”, i.e. the custom commands are defined in terms of other custom commands. Defaults to 1, in which custom commands are replaced throughout the entire document once. If set to any negative number (e.g. `-1``), then this function attempts to replace custom commands until no commands to replace are found.\n\n\nReturns\nNone\n\n\n\n\n\n\nwith (tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir):\n    temp_vault = Path(temp_dir) / 'test_vault_5'\n    shutil.copytree(_test_directory() / 'test_vault_5', temp_vault)\n\n    dir = _test_directory() / 'latex_examples' / 'latex_example_with_untitled_subsections_setup_to_a_vault'\n    sample_latex_file = dir / 'main.tex' \n    sample_latex_text = text_from_file(sample_latex_file)\n    preamble, _ = divide_preamble(sample_latex_text)\n    parts = divide_latex_text(sample_latex_text, dir)\n    cust_comms = custom_commands(preamble)\n    \n    setup_reference_from_latex_parts(\n        parts, cust_comms, temp_vault, Path(''),\n        'test_ref',\n        ['Kim', 'Kim', 'Kim'])\n    # os.startfile(temp_vault)\n    # input()\n\n\n# TODO: give an example for a LaTeX document with a multiline section\n# TODO: give an example for a LaTeX document with a section that must be sanitized first, e.g.\n# in banwait_et_al_cnpgrg2c, there is a section of the string\n# `\\section{Exceptional maximal subgroups of \n# \\texorpdfstring{\\(\\GSp_4(\\ff_\\ell)\\)}{GSp4Fell}}`\n\nThe following example demonstrates setting up a reference folder from a latex document with significant content before any explicitly specified sections. In particular, the reference folder contains a subfolder dedicated to the content that comes before the explicitly specified sections.\n\nwith (tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir):\n    temp_vault = Path(temp_dir) / 'test_vault_5'\n    shutil.copytree(_test_directory() / 'test_vault_5', temp_vault)\n\n    dir = _test_directory() / 'latex_examples' / 'latex_example_with_content_before_sections'\n    sample_latex_file = dir / 'main.tex' \n    sample_latex_text = text_from_file(sample_latex_file)\n    preamble, _ = divide_preamble(sample_latex_text)\n    parts = divide_latex_text(sample_latex_text, dir)\n    cust_comms = custom_commands(preamble)\n    \n    setup_reference_from_latex_parts(\n        parts, cust_comms, temp_vault, Path(''),\n        'test_ref',\n        ['Kim', 'Kim', 'Kim'])\n    reference_folder = temp_vault / 'test_ref'\n\n    subdirectories = list(reference_folder.glob('**'))\n    relative_subdirectories = [\n        os.path.relpath(subdirectory, reference_folder)\n        for subdirectory in subdirectories]\n    print(\"The following are the subdirectories of `reference_folder` (relative to `temp_vault`):\")\n    print(relative_subdirectories)\n    assert convert_title_to_folder_name(f'test_ref {UNTITLED_SECTION_TITLE}') in relative_subdirectories\n\n    # os.startfile(temp_vault)\n    # input()\n\nThe following are the subdirectories of `reference_folder` (relative to `temp_vault`):\n['.', '.obsidian', '1_proof_of_theorem~refthmain', 'test_ref_untitled_section', '_temp', '.obsidian\\\\plugins', '.obsidian\\\\plugins\\\\fast-link-edit', '.obsidian\\\\plugins\\\\obsidian-vimrc-support', '1_proof_of_theorem~refthmain\\\\11_this_is_a_subsection', '1_proof_of_theorem~refthmain\\\\12_this_is_another_subsection']",
    "crumbs": [
      "latex.convert"
    ]
  },
  {
    "objectID": "latex.convert.html#compile-obsidian.md-vault-notes-into-latex-code",
    "href": "latex.convert.html#compile-obsidian.md-vault-notes-into-latex-code",
    "title": "latex.convert",
    "section": "Compile Obsidian.md vault notes into LaTeX code",
    "text": "Compile Obsidian.md vault notes into LaTeX code\nAs a side note, the remove_dollar_signs_around_equationlike_envs function is one function used to revert some markdown-formatted code into code better suited for LaTeX.\n\noutput = remove_dollar_signs_around_equationlike_envs(\nr'''$$\\begin{align*}asdf\\end{align*}$$''')\nprint(output)\nassert '$' not in output\n\n\\begin{align*}asdf\\end{align*}\n\n\n\nsource\n\nconvert_notes_to_latex_code\n\n convert_notes_to_latex_code\n                              (notes:list[trouver.markdown.obsidian.vault.\n                              VaultNote], vault:os.PathLike, preamble:str)\n\nCompile the contents of the VaultNote’s into code for a LaTeX file.\n\nbody = r\"\"\"\nLet us explain why this point of view is useful for proving homological stability for Hurwitz spaces.  In most situations where homological stability is understood, one has a sequence of (usually connected) spaces $X_n$ and stabilization maps $f_n: X_n \\to X_{n+1}$; the goal is to show that each $f_n$ induces homology isomorphisms in a range of dimensions.  Let $X= \\sqcup_n X_n$, and consider the homology\n\n&lt;span notation=\"\" style=\"border-width:1px;border-style:solid;padding:3px\"&gt;$$M_p = H_p(X) =\\oplus_n H_p(X_n)$$&lt;/span&gt;\n\nGive $M_p$ the structure of a $k[x]$-module by making the indeterminate $x$ act via the stabilization map.  $M_p$ admits a grading by the number $n$, and $x$ acts as a degree 1 operator.  Homological stability is rephrased as the statement that $x$ is an isomorphism in sufficiently high degree.  Equivalently, we need the quotient and $x$-torsion\n\n$$\\begin{array}{ccc} Tor_0^{k[x]}(k, M_p) = M_p/xM_p & {\\rm and} & Tor_1^{k[x]}(k, M_p) = M_p[x] \\end{array}$$\n\nto be concentrated in low degrees.\n\"\"\"\nprint(_replace_html_with_latex_command_markings(body))\n\n\nLet us explain why this point of view is useful for proving homological stability for Hurwitz spaces.  In most situations where homological stability is understood, one has a sequence of (usually connected) spaces $X_n$ and stabilization maps $f_n: X_n \\to X_{n+1}$; the goal is to show that each $f_n$ induces homology isomorphisms in a range of dimensions.  Let $X= \\sqcup_n X_n$, and consider the homology\n\n$$\\mathcolorbox{lightgray}{M_p = H_p(X) =\\oplus_n H_p(X_n)}$$\n\nGive $M_p$ the structure of a $k[x]$-module by making the indeterminate $x$ act via the stabilization map.  $M_p$ admits a grading by the number $n$, and $x$ acts as a degree 1 operator.  Homological stability is rephrased as the statement that $x$ is an isomorphism in sufficiently high degree.  Equivalently, we need the quotient and $x$-torsion\n\n$$\\begin{array}{ccc} Tor_0^{k[x]}(k, M_p) = M_p/xM_p & {\\rm and} & Tor_1^{k[x]}(k, M_p) = M_p[x] \\end{array}$$\n\nto be concentrated in low degrees.",
    "crumbs": [
      "latex.convert"
    ]
  },
  {
    "objectID": "star.html",
    "href": "star.html",
    "title": "helper.packages",
    "section": "",
    "text": "source\n\n\n\n check_package_installed (package_name:str)\n\n\n# Check for fastai and fastcore\ncheck_package_installed('fastai')\ncheck_package_installed('fastcore')\n\nTrue\n\n\n\nsource\n\n\n\n\n check_package_version_with_version_attribute (package_name)\n\n*Checks and returns the version of the specified package if available.\nArgs: package_name (str): The name of the package to check.\nReturns: str or None: The version of the package or None if the package is not available.*\n\n# Example usage\npackage_name = 'fastai'  # Replace with any package name you want to check\nversion = check_package_version_with_version_attribute(package_name)\nif version:\n    print(f\"{package_name} version: {version}\")\nelse:\n    print(f\"{package_name} is not installed or does not have a version attribute.\")",
    "crumbs": [
      "helper.packages"
    ]
  },
  {
    "objectID": "star.html#detect-packages",
    "href": "star.html#detect-packages",
    "title": "helper.packages",
    "section": "",
    "text": "source\n\n\n\n check_package_installed (package_name:str)\n\n\n# Check for fastai and fastcore\ncheck_package_installed('fastai')\ncheck_package_installed('fastcore')\n\nTrue\n\n\n\nsource\n\n\n\n\n check_package_version_with_version_attribute (package_name)\n\n*Checks and returns the version of the specified package if available.\nArgs: package_name (str): The name of the package to check.\nReturns: str or None: The version of the package or None if the package is not available.*\n\n# Example usage\npackage_name = 'fastai'  # Replace with any package name you want to check\nversion = check_package_version_with_version_attribute(package_name)\nif version:\n    print(f\"{package_name} version: {version}\")\nelse:\n    print(f\"{package_name} is not installed or does not have a version attribute.\")",
    "crumbs": [
      "helper.packages"
    ]
  },
  {
    "objectID": "star.html#install-package-during-runtime",
    "href": "star.html#install-package-during-runtime",
    "title": "helper.packages",
    "section": "Install package during runtime",
    "text": "Install package during runtime\n\nsource\n\nensure_package_installed\n\n ensure_package_installed (package_name:str)\n\nCheck if a package is installed and install it if not.\n\nsource\n\n\ninstall_package\n\n install_package (package_name:str)\n\nInstall a package using pip.",
    "crumbs": [
      "helper.packages"
    ]
  },
  {
    "objectID": "helper.tests.html",
    "href": "helper.tests.html",
    "title": "helper.tests",
    "section": "",
    "text": "from nbdev import show_doc\n\n\nsource\n\n_test_directory\n\n _test_directory ()\n\n*Returns the nbs/_tests directory of the trouver repository.\nAssumes that the current working directory is either the root of the repository or the nbs folder and the nbs/_tests folder exists in the repository but the root of the repository does not have a folder named _tests.*\nTest files for trouver are contained in nbs/_tests directory within the repository. The hidden _test_directory() method returns this directory.\n\nassert os.path.exists(_test_directory())\n\n\nos.listdir(_test_directory())\n\n['empty_model_vault',\n 'latex_examples',\n 'ml_examples',\n 'test_vault_1',\n 'test_vault_10',\n 'test_vault_2',\n 'test_vault_3',\n 'test_vault_4',\n 'test_vault_5',\n 'test_vault_6',\n 'test_vault_7',\n 'test_vault_8',\n 'test_vault_9']",
    "crumbs": [
      "helper.tests"
    ]
  },
  {
    "objectID": "46_helper.files_and_folders.html",
    "href": "46_helper.files_and_folders.html",
    "title": "trouver",
    "section": "",
    "text": "from fastcore.test import *\nfrom unittest import mock",
    "crumbs": [
      "Files and folders"
    ]
  },
  {
    "objectID": "46_helper.files_and_folders.html#files-and-folders",
    "href": "46_helper.files_and_folders.html#files-and-folders",
    "title": "trouver",
    "section": "Files and folders",
    "text": "Files and folders\n\nFile existence\n\nsource\n\n\nfile_existence_test\n\n file_existence_test (path:os.PathLike,\n                      relative_to:Optional[os.PathLike]=None)\n\n*Deprecated. Use existing_path instead.\nReturns a path relative to a specified path as an absolute path that exists.\nRaises - FileNotFoundError - If relative_to is not None but does not exist, or if file does not exist.\nNotes - This function may add the string '\\\\?\\' in front, which identifies very long paths.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npath\nPathLike\n\nA file or directory path. Either absolute or relative to relative_to.\n\n\nrelative_to\nOptional\nNone\nPath to the directory that file is relative to. If None, then path is an absolute path.\n\n\nReturns\nPath\n\nThe path formed by relative_to adjoined with path. Defaults to None\n\n\n\n\nsource\n\n\nexisting_path\n\n existing_path (path:os.PathLike, relative_to:Optional[os.PathLike]=None)\n\n*Returns a path relative to a specified path as an absolute path that exists.\nRaises\n\nFileNotFoundError\n\nIf relative_to is not None but does not exist, or if file does not exist.\n\nValueError\n\nIf relative_to is not None and yet not an absolute path, or if relative_to is None at yet path is not an absolute path.\n\n\nNotes - This function may add the string '\\\\?\\' in front, which identifies very long paths.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npath\nPathLike\n\nA file or directory path. Either absolute or relative to relative_to.\n\n\nrelative_to\nOptional\nNone\nPath to the directory that file is relative to. If None, then path is an absolute path.\n\n\nReturns\nPath\n\nThe path formed by relative_to adjoined with path. Defaults to None\n\n\n\nIn the following example, the existing_path method returns an existing absolute path \\(p_2 \\backslash p_1\\) which is equivalent to a specified path \\(p_1\\) relative to an existing absolute path \\(p_2\\). Note that all paths and os methods are mocked:\n\nwith (mock.patch('os.path.exists') as mock_path_exists,\n      mock.patch('os.path.isabs') as mock_is_abs):\n    mock_path_exists.return_value = True\n    mock_is_abs.return_value = True\n    path_1 = existing_path('mock_existing_relative_path', 'mock_existing_absolute_path')\n    test_eq(Path('mock_existing_absolute_path') / 'mock_existing_relative_path', path_1)\n\nIf the desired path is very long in Windows, then the \\\\?\\ may be appended in front of the absolute path so that Python can actually find the path, cf. https://stackoverflow.com/questions/36219317/pathname-too-long-to-open:\n\n# TODO provide an example\nwith (mock.patch('os.path.exists') as mock_path_exists,\n      mock.patch('os.path.isabs') as mock_is_abs):\n  print('hi')\n\nhi\n\n\nIf the parameter relative_to, which is supposed to be an absolute path, is not None and not absolute, then a ValueError is raised:\n\nwith (ExceptionExpected(ex=ValueError, regex='absolute path'),\n      mock.patch('os.path.exists') as mock_path_exists,\n      mock.patch('os.path.isabs') as mock_is_abs):\n    mock_is_abs.return_value = False\n    path = 'mock_relative_path_that_is_not_None'\n    relative_to = 'mock_non_absolute_path'\n    existing_path('mock_relative_to_that_is_not_None', relative_to)\n\n\nwith (ExceptionExpected(ex=ValueError, regex='absolute path'),\n      mock.patch('os.path.exists') as mock_path_exists,\n      mock.patch('os.path.isabs') as mock_is_abs):\n    mock_is_abs.return_value = False\n    # It does not matter what `path`` is - as long as `relative_to`` is not `None` and not absolute, the ValueError is raised.\n    path = None  \n    relative_to = 'mock_non_absolute_path'\n    existing_path('mock_relative_to_that_is_not_None', relative_to)\n\nIf the parameter relative_to is None and the paramether path is not absolute, then a ValueError is raised:\n\nwith (ExceptionExpected(ex=ValueError, regex='absolute path'),\n      mock.patch('os.path.isabs') as mock_is_abs):\n    mock_is_abs.return_value = False\n    relative_to = None\n    path = 'mock_non_absolute_path'\n    existing_path(path, relative_to)\n\nIf relative_to does not exist or if path does not exist, then a FileNotFoundError is raised:\n\n# In this example, both `relative_to` and `path` are specified, and `relative_to`\n# is a non-existent path.`\nwith (ExceptionExpected(ex=FileNotFoundError),\n      mock.patch('os.path.exists') as mock_path_exists,\n      mock.patch('os.path.isabs') as mock_is_abs):\n    relative_to = 'mock_non_existent_absolute_path'\n    path = 'mock_some_relative_path'\n    def relative_to_does_not_exist(path_to_check):\n      return False if path_to_check is relative_to else True\n    def relative_to_is_absolute_path(path_to_check):\n      return True if path_to_check is relative_to else False\n\n    mock_path_exists.side_effect = relative_to_does_not_exist\n    mock_is_abs.side_effect = relative_to_is_absolute_path\n    existing_path(path, relative_to)\n\n\n# In this example, both `relative_to` and `path` are specified, and `path`\n# is a non-existent path.`, whereas `relative_to` exists.\nwith (ExceptionExpected(ex=FileNotFoundError),\n      mock.patch('os.path.exists') as mock_path_exists,\n      mock.patch('os.path.isabs') as mock_is_abs):\n    relative_to = 'mock_existent_absolute_path'\n    path = 'mock_non_existent_relative_path'\n    def only_relative_to_exists(path_to_check):\n      # only `relative_to` exists; all other paths of interest do not exist.\n      return path_to_check is relative_to\n    def relative_to_is_absolute_path(path_to_check):\n      return True if path_to_check is relative_to else False\n\n    mock_path_exists.side_effect = only_relative_to_exists\n    mock_is_abs.side_effect = relative_to_is_absolute_path\n    existing_path(path, relative_to)\n\n\nPaths without extensions\n\nsource\n\n\n\npath_name_no_ext\n\n path_name_no_ext (path:os.PathLike)\n\n*Return the name of a file or directory from its path without the extension.\nThe file or directory does not have to exist.*\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\npath\nPathLike\nThe path of the file or directory. This may be absolute or relative to any directory.\n\n\nReturns\nstr\nThe name of the file or directory without the extension.\n\n\n\nBasic usage:\n\npath = Path('hypothetical_directory')\ntest_eq(path_name_no_ext(path / 'hypothetical_subdirectory'),  'hypothetical_subdirectory')\ntest_eq(path_name_no_ext(path / 'hypotehtical_subdirectory' / 'hypothetical_file.md'),  'hypothetical_file')\n\nThe path does not have to exist.\n\ntest_eq(path_name_no_ext(path / 'this_folder_does_not_exist'), 'this_folder_does_not_exist')\n\nOn paths to files with “multiple extensions”, the function returns the file name without the last extension only.\n\ntest_eq(path_name_no_ext('archived_file_somewhere.7z.zip.tar'),  'archived_file_somewhere.7z.zip')\n\n\nsource\n\n\npath_no_ext\n\n path_no_ext (path:os.PathLike)\n\n*Returns the path of a file or directory without the extension.\nThe file or directory does not have to exist.*\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\npath\nPathLike\nThe path of the file or directory. This may be absolute or relative to any directory.\n\n\nReturns\nstr\nThe path of the file or directory without the extension. If path is a path to a directory, then the output should be essentially the same as path.\n\n\n\nBasic usage - the path does not have to exist:\n\nassert path_no_ext('C:\\\\hi') == 'C:\\\\hi'\nassert path_no_ext('greetings\\\\file.txt') == 'greetings\\\\file'\n\n\nRead text from file\n\nsource\n\n\n\ntext_from_file\n\n text_from_file (path:os.PathLike, encoding:str='utf8')\n\n*Return the entire text from a file.\nAssuems that the file can be encoded in the specified encoding*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npath\nPathLike\n\nThe absolute path of the file.\n\n\nencoding\nstr\nutf8\nThe encoding of the file to be read. Defaults to 'utf8'.\n\n\nReturns\nstr\n\nThe entire text from a file\n\n\n\nThe text_from_file method is a quick method to extract the text from a file.\n\n# TODO: examples/tests\n\n\nFile extension\n\nsource\n\n\n\nfiles_of_format_sorted\n\n files_of_format_sorted (directory:os.PathLike, extension:str='txt')\n\nReturn a list of path str of files in the directory (but not subdirectories) sorted via natsort.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndirectory\nPathLike\n\nThe directory in which to find the files\n\n\nextension\nstr\ntxt\nExtension of the files to find. Defaults to ‘txt’.\n\n\nReturns\nlist\n\n\n\n\n\nIn the following example, we mock a folder with numbered files. files_of_format_sorted returns them in the “natural” order.\n\nwith (mock.patch('glob.glob') as mock_glob):\n    mock_directory = Path('some_directory')\n    # `glob_results`` is not sorted in \"natural\" order. \n    glob_results = [mock_directory / f'{i}.txt' for i in range (10,0, -1)]\n    mock_glob.return_value = glob_results\n\n    # mock to make sure that natsorted was called.\n    with mock.patch(__name__ + '.natsorted') as mock_natsorted:\n      mock_files = files_of_format_sorted(mock_directory)\n      mock_natsorted.assert_called_with(mock_glob.return_value)\n\n    # Now print out that the files are sorted in \"natural\" order.\n    mock_files = files_of_format_sorted(mock_directory)\n    print(mock_files)\n    test_shuffled(glob_results, mock_files)\n\n[WindowsPath('some_directory/1.txt'), WindowsPath('some_directory/2.txt'), WindowsPath('some_directory/3.txt'), WindowsPath('some_directory/4.txt'), WindowsPath('some_directory/5.txt'), WindowsPath('some_directory/6.txt'), WindowsPath('some_directory/7.txt'), WindowsPath('some_directory/8.txt'), WindowsPath('some_directory/9.txt'), WindowsPath('some_directory/10.txt')]",
    "crumbs": [
      "Files and folders"
    ]
  },
  {
    "objectID": "46_helper.files_and_folders.html#compressed-files",
    "href": "46_helper.files_and_folders.html#compressed-files",
    "title": "trouver",
    "section": "Compressed files",
    "text": "Compressed files\n\nsource\n\nfile_is_compressed\n\n file_is_compressed (filename:str)\n\n\nassert file_is_compressed('asdf.tar')\nassert file_is_compressed('asdf.tar.gz')\nassert file_is_compressed('./hi/asdf.tar.gz')\nassert not file_is_compressed('./hi/bye')\nassert not file_is_compressed('./hi/bye.pdf')\n\n\nsource\n\n\nuncompress_file\n\n uncompress_file (file_path:os.PathLike, verbose:bool=False)\n\n\n# TODO : test\n\n# Example usage\n# file_to_uncompress = './1605.08386v1.Heat_bath_random_walks_with_Markov_bases.tar'  # Replace with your file name\n# hi = uncompress_file(file_to_uncompress)\n\n\n# hi",
    "crumbs": [
      "Files and folders"
    ]
  },
  {
    "objectID": "46_helper.files_and_folders.html#downloads-folder",
    "href": "46_helper.files_and_folders.html#downloads-folder",
    "title": "trouver",
    "section": "Downloads folder",
    "text": "Downloads folder\n\nsource\n\nget_download_path\n\n get_download_path ()\n\nReturn the user’s download folder",
    "crumbs": [
      "Files and folders"
    ]
  },
  {
    "objectID": "46_helper.files_and_folders.html#huggingface-cache",
    "href": "46_helper.files_and_folders.html#huggingface-cache",
    "title": "trouver",
    "section": "HuggingFace cache",
    "text": "HuggingFace cache\n\nsource\n\nget_huggingface_cache_dir\n\n get_huggingface_cache_dir ()\n\n\n# get_huggingface_cache_dir()",
    "crumbs": [
      "Files and folders"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.machine_learning.__init__.html",
    "href": "markdown.obsidian.personal.machine_learning.__init__.html",
    "title": "markdown.obisidian.personal.machine_learning",
    "section": "",
    "text": "# get_model_size('hyunjongkimmath/def_and_notat_token_classification_model')\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nInput In [6], in &lt;cell line: 1&gt;()\n----&gt; 1 get_model_size('hyunjongkimmath/def_and_notat_token_classification_model')\n\nInput In [5], in get_model_size(model_name)\n      8 model_info = api.model_info(model_name)\n     10 # Calculate total size\n---&gt; 11 total_size = sum(file.size for file in model_info.siblings)\n     12 return total_size\n\nTypeError: unsupported operand type(s) for +: 'int' and 'NoneType'",
    "crumbs": [
      "markdown.obisidian.personal.machine_learning"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.notation.html",
    "href": "markdown.obsidian.personal.notation.html",
    "title": "markdown.obisidian.personal.notation",
    "section": "",
    "text": "import os\nimport shutil\nimport tempfile\n\nfrom fastcore.test import *\n\nfrom trouver.helper.tests import _test_directory",
    "crumbs": [
      "markdown.obisidian.personal.notation"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.notation.html#detect-notations-being-used-in-reference",
    "href": "markdown.obsidian.personal.notation.html#detect-notations-being-used-in-reference",
    "title": "markdown.obisidian.personal.notation",
    "section": "Detect notations being used in reference",
    "text": "Detect notations being used in reference\n\nRegex from latex\n\n\n\nregex_from_latex\n\n regex_from_latex (latex:str, replaceables:dict[str,set[str]]={'mathrm':\n                   {'rm', 'operatorname', 'text', 'mathrm'},\n                   'operatorname': {'rm', 'operatorname', 'text',\n                   'mathrm'}, 'rm': {'rm', 'operatorname', 'text',\n                   'mathrm'}, 'text': {'rm', 'operatorname', 'text',\n                   'mathrm'}, 'mathbf': {'bf', 'mathbf'}, 'bf': {'bf',\n                   'mathbf'}, 'mathit': {'mathit', 'it'}, 'it': {'mathit',\n                   'it'}}, special_characters:list[str]=['.', '+', '*',\n                   '?', '^', '$', '(', ')', '[', ']', '{', '}', '|',\n                   '\\\\'])\n\n*Returns regex to match latex math mode string which is essentially equivalent to a specified latex math mode string.\nThe outputs of this function may not work correctly. The regex pattern does not have to fully match equivalent string.\nParameters\n\nlatex - str\n\nThe latex math mode string. Does not include math mode delimiters such as $, $$, \\[ \\] (although the characters '\\[' and '\\]' can still be part of the string, e.g. for optional arguments of a macro/operator). Can include “placeholders” r'\\1', r'\\2', r'\\3', etc. to indicate substitutable/generics; the placeholders can be substituted with any string.\n\nreplaceables - dict[str, set[str]]\n\nlatex strings/commands which are considered “interreplacable”\n\nspecial_characters - list[str]\n\ncharacters to add a backslash '\\' in front of for regex. Defaults to a list consisting of special characters in regex.*\n\n\n\ntext = r\"\"\"e\"\"\"\nprint(regex_from_latex(text, REPLACEABLES))\n\n(?:[ \\{\\}]*?)e(?:[ \\{\\}]*?)(?:[ \\{\\}]*)\n\n\n\n\nGet regex from notation note\nSo far, I have just made notation notes in the form '$math_mode_string$ denotes ...'. I want to add frontmatter metadata in notation notes to indicate regex to detect the notation with placeholders.\n\n\n\nregex_from_notation_note\n\n regex_from_notation_note (vault:os.PathLike,\n                           note:trouver.markdown.obsidian.vault.VaultNote)\n\n*Returns a regex str to detect the notation of the notation note.\nThe regex detection strings should be in a list labeled detect_regex in the yaml frontmatter. If multiple strings are in the list, then the regex will detect latex math mode strings roughly corresponding to any of them. If multiple strings are in the list, then they must be ordered “by priority”, with the higher priority regexes coming first. It is good to have these string in quotes \"\" to make sure that yaml can load them safely. When doing so, make sure to escape characters, e.g. backslash should be typed as \\, etc.\nThe strings in detect_regex can include placeholders, cf. regex_from_latex.\nParameters - vault - PathLike - note - VaultNote\nReturns - str - Of the regex used to detect the notation. The regex does not need to fully match instances of the notation.*\n\n# TODO: test",
    "crumbs": [
      "markdown.obisidian.personal.notation"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.note_type.html",
    "href": "markdown.obsidian.personal.note_type.html",
    "title": "markdown.obsidian.personal.note_type",
    "section": "",
    "text": "from fastcore.test import *\n\nfrom trouver.helper.tests import _test_directory\nIt should be convenient to be able to distinguish between different types of notes; thus far, I have made the following types of notes:",
    "crumbs": [
      "markdown.obsidian.personal.note_type"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.note_type.html#personalnotetypeenum-class",
    "href": "markdown.obsidian.personal.note_type.html#personalnotetypeenum-class",
    "title": "markdown.obsidian.personal.note_type",
    "section": "PersonalNoteTypeEnum class",
    "text": "PersonalNoteTypeEnum class\n\nsource\n\nPersonalNoteTypeEnum\n\n PersonalNoteTypeEnum (value, names=None, module=None, qualname=None,\n                       type=None, start=1)\n\nAn Enum class for note types in my Obsidian math vault\n\nPersonalNoteTypeEnum.type_function(PersonalNoteTypeEnum.INDEX_NOTE)\n\n&lt;function __main__._is_index_note(vault_note: trouver.markdown.obsidian.vault.VaultNote) -&gt; bool&gt;\n\n\n\nfor note_type in PersonalNoteTypeEnum:\n    print(note_type)\n\nPersonalNoteTypeEnum.INDEX_NOTE\nPersonalNoteTypeEnum.STANDARD_INFORMATION_NOTE\nPersonalNoteTypeEnum.INDEX_OF_NOTATION_NOTE\nPersonalNoteTypeEnum.NOTATION_NOTE\nPersonalNoteTypeEnum.PREMISE_NOTE\nPersonalNoteTypeEnum.COMMON_TERMS_NOTE\nPersonalNoteTypeEnum.TEMPLATE_NOTE\nPersonalNoteTypeEnum.NOTES_NOTE\nPersonalNoteTypeEnum.MATHEMATICIAN_NOTE\nPersonalNoteTypeEnum.EQUATION_NOTE\nPersonalNoteTypeEnum.REFERENCE_NOTE\nPersonalNoteTypeEnum.GLOSSARY_NOTE\n\n\n\nsource\n\n\ntype_of_note\n\n type_of_note (vault_note:trouver.markdown.obsidian.vault.VaultNote)\n\n*Returns the type of the specified note.\nAssumes that vault_note represents an existing note.\nNotes - This function may return incorrect or unintended results, depending on the formatting or existence of the file.\nRaises - NoteDoesNoteExistError - If vault_note does not exist.*\n\nsource\n\n\nnote_is_of_type\n\n note_is_of_type (vault_note:trouver.markdown.obsidian.vault.VaultNote,\n                  note_type:Optional[__main__.PersonalNoteTypeEnum])\n\n*Returns True if the Markdown vault note exists and is determined to be of the specified type.\nAssumes that vault_note represents an existing note.\nNotes - This function may return incorrect results, depending on the formatting of the file.\nRaises - NoteDoesNoteExistError - If vault_note does not exist.*\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nvault_note\nVaultNote\n\n\n\nnote_type\nOptional\nThe type of note. If None, then any type of note; in this case, returns whether or not the note exists.\n\n\nReturns\nbool\n\n\n\n\nWe can get the type of a note with type_of_note or tell whether a note is of a given type with note_is_of_type:\n\nvault = _test_directory() / 'test_vault_4'\n\nsample_vn_1 = VaultNote(vault, name='number_theory_reference_1_Definition 1.7')\nassert type_of_note(sample_vn_1) == PersonalNoteTypeEnum.STANDARD_INFORMATION_NOTE\nassert note_is_of_type(sample_vn_1, PersonalNoteTypeEnum.STANDARD_INFORMATION_NOTE)\n\nsample_vn_2 = VaultNote(vault, name='_index_1_chapter_number_theory_reference_1')\nassert type_of_note(sample_vn_2) == PersonalNoteTypeEnum.INDEX_NOTE\n\nsample_vn_3 = VaultNote(vault, name='_notation_number_theory_reference_1')\nassert type_of_note(sample_vn_3) == PersonalNoteTypeEnum.INDEX_OF_NOTATION_NOTE\n\nsample_vn_4 = VaultNote(vault, name='number_theory_reference_1_notation_Z_nZ_ring_of_integers_modulo_n')\nassert type_of_note(sample_vn_4) == PersonalNoteTypeEnum.NOTATION_NOTE\n\nsample_vn_5 = VaultNote(vault, name='_glossary_number_theory_reference_1')\nassert type_of_note(sample_vn_5) == PersonalNoteTypeEnum.GLOSSARY_NOTE\n\nsample_vn_6 = VaultNote(vault, name='_common_terms_ring')\nassert type_of_note(sample_vn_6) == PersonalNoteTypeEnum.COMMON_TERMS_NOTE\n\nsample_vn_7 = VaultNote(vault, name='_template_number_theory_reference_1')\nassert type_of_note(sample_vn_7) == PersonalNoteTypeEnum.TEMPLATE_NOTE\n\nsample_vn_8 = VaultNote(vault, name='kim_hyun_jong')\nassert type_of_note(sample_vn_8) == PersonalNoteTypeEnum.MATHEMATICIAN_NOTE\n\nsample_vn_9 = VaultNote(vault, name='_reference_number_theory_reference_1')\nassert type_of_note(sample_vn_9) == PersonalNoteTypeEnum.REFERENCE_NOTE\n\nIf the note does not exist, then a NoteDoesNotExistError is raised:\n\nnon_existent_vn = VaultNote(vault, name='non_existent_note')\nwith ExceptionExpected(ex=NoteDoesNotExistError):\n    type_of_note(non_existent_vn)\n\n\n\nNoteTypeError\n\nsource\n\n\nassert_note_is_of_type\n\n assert_note_is_of_type (note:trouver.markdown.obsidian.vault.VaultNote,\n                         expected_type:__main__.PersonalNoteTypeEnum)\n\n*Raises a NoteTypeError if the note is not of the expected type.\nRaises - NoteTypeError - If the type of note is not expected_type.*\n\nsource\n\n\nNoteTypeError\n\n NoteTypeError (note:trouver.markdown.obsidian.vault.VaultNote,\n                expected_note_type:__main__.PersonalNoteTypeEnum)\n\n*Exception raised when the type of note is not of the expected type.\nAttributes - note - VaultNote - expected_note_type - PersonalNoteTypeEnum*\nWe can raise NoteTypeError when a note of some type is expected, but a note of a different type is passed:\n\nvault = _test_directory() / 'test_vault_4'\n\nnot_a_notation_note = VaultNote(vault, name='number_theory_reference_1_Definition 1.7')\nwith ExceptionExpected(ex=NoteTypeError, regex=\"PersonalNoteTypeEnum.NOTATION_NOTE\"):\n    exception = NoteTypeError(not_a_notation_note, PersonalNoteTypeEnum.NOTATION_NOTE)\n    print(exception)\n    raise exception\n\nExpected a note of type PersonalNoteTypeEnum.NOTATION_NOTE, but got a note of a different type instead: number_theory_reference_1_Definition 1.7\n\n\nFor convenience, the assert_note_is_of_type method checks that a note is of a specified type:\n\nassert_note_is_of_type(not_a_notation_note, PersonalNoteTypeEnum.STANDARD_INFORMATION_NOTE)\nwith ExceptionExpected(ex=NoteTypeError, regex=\"PersonalNoteTypeEnum.NOTATION_NOTE\"):\n    assert_note_is_of_type(not_a_notation_note, PersonalNoteTypeEnum.NOTATION_NOTE)",
    "crumbs": [
      "markdown.obsidian.personal.note_type"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.machine_learning.tokenize.def_and_notat_token_classification.html",
    "href": "markdown.obsidian.personal.machine_learning.tokenize.def_and_notat_token_classification.html",
    "title": "markdown.obsidian.personal.machine_learning.tokenize.def_and_notat_token_classification",
    "section": "",
    "text": "Previous, trouver just had functionalities for using ML models to identify newly introduced notations in text and for gathering data to train such models. Moreover, such models were merely classification models, and using these models to identify newly introduced notations had a lot of computational redundancies.\nThis module aims to provide the same functionalities for both definitions and notations by training and using token classification models instead.\n# TODO: Create a new module dedicated to definition and notation identification and move approparite functions over there.\nfrom unittest import mock\nimport shutil\nimport tempfile\n\nfrom datasets import ClassLabel, Dataset, Features, Sequence, Value\nfrom transformers import AutoTokenizer\nfrom fastcore.test import *\n\nfrom trouver.helper.tests import _test_directory",
    "crumbs": [
      "markdown.obsidian.personal.machine_learning.tokenize.def_and_notat_token_classification"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.machine_learning.tokenize.def_and_notat_token_classification.html#gather-ml-data-from-information-notes",
    "href": "markdown.obsidian.personal.machine_learning.tokenize.def_and_notat_token_classification.html#gather-ml-data-from-information-notes",
    "title": "markdown.obsidian.personal.machine_learning.tokenize.def_and_notat_token_classification",
    "section": "Gather ML data from information notes",
    "text": "Gather ML data from information notes\n\nsource\n\nconvert_double_asterisks_to_html_tags\n\n convert_double_asterisks_to_html_tags (text:str)\n\nReplace the double asterisks, which signify definitions and notations, in text with HTML tags.\n\nprint(convert_double_asterisks_to_html_tags(\"**hi**. Here is a notation **$asdf$**\"))\ntest_eq(convert_double_asterisks_to_html_tags(\"**hi**. Here is a notation **$asdf$**\"), '&lt;b definition=\"\"&gt;hi&lt;/b&gt;. Here is a notation &lt;span notation=\"\"&gt;$asdf$&lt;/span&gt;')\n\n&lt;b definition=\"\"&gt;hi&lt;/b&gt;. Here is a notation &lt;span notation=\"\"&gt;$asdf$&lt;/span&gt;\n\n\n\nsource\n\n\nraw_text_with_html_tags_from_markdownfile\n\n raw_text_with_html_tags_from_markdownfile\n                                            (mf:trouver.markdown.markdown.\n                                            file.MarkdownFile,\n                                            vault:os.PathLike)\n\nProcess the MarkdownFile, replacing the double asterisk surrounded text indicating definitions and notations to be HTML tags instead.\nIn the following example, let mf be the following MarkdownFile:\n\nprint(str(mf))\n\n---\naliases: []\ntags: []\n---\n# Galois group of a separable and normal finite field extension\n\nLet $L/K$ be a separable and normal finite field extension. Its &lt;b definition=\"Galois group of a separable and normal finite field extension\"&gt;Galois group&lt;/b&gt; &lt;span notation=\"\"&gt;$\\operatorname{Gal}(L/K)$&lt;/span&gt; is...\n\n# Galois group of a separable and normal profinite field extension\n\nIn fact, the notion of a Galois group can be defined for profinite field extensions. Given a separable and normal profinite field extension $L/K$, say that\n$L = \\varinjlim_i L_i$ where $L_i/K$ are finite extensions. Its **Galois group** **$\\operatorname{Gal}(L/K)$**\n\n# See Also\n# Meta\n## References and Citations\n\n\nThe raw_text_with_html_tags_from_markdownfile function processes the MarkdownFile much in the same way as the process_standard_information_note function, except it 1. preserves HTML tags, and 2. replaces text surrounded by double asterisks ** with HTML tags signifiying whether the text displays a definition or a notation.\nIn the below example, note that the vault parameter is set to None; this is fine for this example becaues the process_standard_information_note function only needs a vault argument when embedded links need to be replaced with text (via the MarkdownFile.replace_embedded_links_with_text function), but mf has no embedded links.\n\nprint(raw_text_with_html_tags_from_markdownfile(mf, None))\n\nLet $L/K$ be a separable and normal finite field extension. Its &lt;b definition=\"Galois group of a separable and normal finite field extension\"&gt;Galois group&lt;/b&gt; &lt;span notation=\"\"&gt;$\\operatorname{Gal}(L/K)$&lt;/span&gt; is...\n\nIn fact, the notion of a Galois group can be defined for profinite field extensions. Given a separable and normal profinite field extension $L/K$, say that\n$L = \\varinjlim_i L_i$ where $L_i/K$ are finite extensions. Its &lt;b definition=\"\"&gt;Galois group&lt;/b&gt; &lt;span notation=\"\"&gt;$\\operatorname{Gal}(L/K)$&lt;/span&gt;\n\n\n\n\nsource\n\n\nhtml_data_from_note\n\n html_data_from_note (note_or_mf:Union[trouver.markdown.obsidian.vault.Vau\n                      ltNote,trouver.markdown.markdown.file.MarkdownFile],\n                      vault:Optional[os.PathLike]=None,\n                      note_name:Optional[str]=None)\n\n*Obtain html data for token classification from the information note.\nCurrently, the token types mainly revolve around definitions and notations.\nIf note has the tag _auto/def_and_notat_identified, then the data in the note is assumed to be auto-generated and not verified and None is returned.\nReturns - Union[dict, None] - The keys-value pairs are - \"Note name\" - The name of the note - \"Raw text\" - The raw text to include in the data. - \"Tag data\" - The list with HTML tags carrying definition/notation data and their locations in the Raw text. See the second output to the function remove_html_tags_in_text. - Each element of the list is a tuple consisting of a bs4.element.Tag and two ints.*\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nnote_or_mf\nUnion\n\nEither a VaultNoteobject to a note or a [MarkdownFile](https://hyunjongkimmath.github.io/trouver/markdown.markdown.file.html#markdownfile) object from which to extra html data. | | vault | Optional | None | If vault to use when processing the [MarkdownFile](https://hyunjongkimmath.github.io/trouver/markdown.markdown.file.html#markdownfile) objects (ifnote_of_mfis a [VaultNote](https://hyunjongkimmath.github.io/trouver/markdown.obsidian.vault.html#vaultnote), then this [MarkdownFile](https://hyunjongkimmath.github.io/trouver/markdown.markdown.file.html#markdownfile) object is created from the text of the note), cf. the [process_standard_information_note](https://hyunjongkimmath.github.io/trouver/markdown.obsidian.personal.note_processing.html#process_standard_information_note) function. | | note_name | Optional | None | Ifnote_or_mfis a [MarkdownFile](https://hyunjongkimmath.github.io/trouver/markdown.markdown.file.html#markdownfile),note_nameshould be the name of the note from which the [MarkdownFile](https://hyunjongkimmath.github.io/trouver/markdown.markdown.file.html#markdownfile) comes from if applicable. Ifnote_or_mfis a [VaultNote](https://hyunjongkimmath.github.io/trouver/markdown.obsidian.vault.html#vaultnote) object, thennote_nameis ignored andnote_or_mf.nameis used instead. | | **Returns** | **Optional** |  | **The keys to the dict are \"Note name\", \"Raw text\", \"Tag data\". However,Noneis returned ifnote` does not exist or the note is marked with auto-generated, unverified data.**\n\n\n\nIn the following example, we mock a VaultNote whose content is that of mf in the example for the raw_text_with_html_tags_from_markdownfile function. Note that there is some text surrounded by double within mf surrounded by double asterisks ** and some text surrounded by HTML tags to indicate definitions and notations introduced.\n\nmf = MarkdownFile.from_string(\n    r\"\"\"---\naliases: []\ntags: []\n---\n# Galois group of a separable and normal finite field extension\n\nLet $L/K$ be a separable and normal finite field extension. Its &lt;b definition=\"Galois group of a separable and normal finite field extension\"&gt;Galois group&lt;/b&gt; &lt;span notation=\"\"&gt;$\\operatorname{Gal}(L/K)$&lt;/span&gt; is...\n\n# Galois group of a separable and normal profinite field extension\n\nIn fact, the notion of a Galois group can be defined for profinite field extensions. Given a separable and normal profinite field extension $L/K$, say that\n$L = \\varinjlim_i L_i$ where $L_i/K$ are finite extensions. Its **Galois group** **$\\operatorname{Gal}(L/K)$**\n\n# See Also\n# Meta\n## References and Citations\n\"\"\")\n\nwith (mock.patch('__main__.VaultNote') as mock_VaultNote,\n      mock.patch('__main__.MarkdownFile.from_vault_note') as mock_from_vault_note,\n      mock.patch('__main__.isinstance') as mock_isinstance):\n    mock_VaultNote.exists.return_value = True\n    mock_VaultNote.name = \"Note's name\"\n    mock_from_vault_note.return_value = mf\n    mock_isinstance.return_value = True\n\n    print(f\"The following is the text from mf:\\n\\n{str(mf)}\")\n\n    html_data = html_data_from_note(mock_VaultNote, None)\n    print(html_data)\n\n    test_eq(html_data['Note name'], \"Note's name\")\n    assert '**' not in html_data['Raw text']\n    assert '&lt;' not in html_data['Raw text']  # Test the lack of HTML tags in the raw text\n\n    print(html_data['Tag data'])\n    test_eq(len(html_data['Tag data']), 4)\n    assert isinstance(html_data['Tag data'][0][0], bs4.element.Tag)\n    assert html_data['Tag data'][0][0].has_attr('definition')\n    assert not html_data['Tag data'][0][0].has_attr('notation')\n    assert html_data['Tag data'][1][0].has_attr('notation')\n    assert not html_data['Tag data'][1][0].has_attr('definition')\n    assert html_data['Tag data'][2][0].has_attr('definition')\n    assert not html_data['Tag data'][2][0].has_attr('notation')\n    assert html_data['Tag data'][3][0].has_attr('notation')\n    assert not html_data['Tag data'][3][0].has_attr('definition')\n\nThe following is the text from mf:\n\n---\naliases: []\ntags: []\n---\n# Galois group of a separable and normal finite field extension\n\nLet $L/K$ be a separable and normal finite field extension. Its &lt;b definition=\"Galois group of a separable and normal finite field extension\"&gt;Galois group&lt;/b&gt; &lt;span notation=\"\"&gt;$\\operatorname{Gal}(L/K)$&lt;/span&gt; is...\n\n# Galois group of a separable and normal profinite field extension\n\nIn fact, the notion of a Galois group can be defined for profinite field extensions. Given a separable and normal profinite field extension $L/K$, say that\n$L = \\varinjlim_i L_i$ where $L_i/K$ are finite extensions. Its **Galois group** **$\\operatorname{Gal}(L/K)$**\n\n# See Also\n# Meta\n## References and Citations\n{'Note name': \"Note's name\", 'Raw text': 'Let $L/K$ be a separable and normal finite field extension. Its Galois group $\\\\operatorname{Gal}(L/K)$ is...\\n\\nIn fact, the notion of a Galois group can be defined for profinite field extensions. Given a separable and normal profinite field extension $L/K$, say that\\n$L = \\\\varinjlim_i L_i$ where $L_i/K$ are finite extensions. Its Galois group $\\\\operatorname{Gal}(L/K)$\\n', 'Tag data': [(&lt;b definition=\"Galois group of a separable and normal finite field extension\"&gt;Galois group&lt;/b&gt;, 64, 76), (&lt;span notation=\"\"&gt;$\\operatorname{Gal}(L/K)$&lt;/span&gt;, 77, 102), (&lt;b definition=\"\"&gt;Galois group&lt;/b&gt;, 330, 342), (&lt;span notation=\"\"&gt;$\\operatorname{Gal}(L/K)$&lt;/span&gt;, 343, 368)]}\n[(&lt;b definition=\"Galois group of a separable and normal finite field extension\"&gt;Galois group&lt;/b&gt;, 64, 76), (&lt;span notation=\"\"&gt;$\\operatorname{Gal}(L/K)$&lt;/span&gt;, 77, 102), (&lt;b definition=\"\"&gt;Galois group&lt;/b&gt;, 330, 342), (&lt;span notation=\"\"&gt;$\\operatorname{Gal}(L/K)$&lt;/span&gt;, 343, 368)]\n\n\nWe can also just pass a MarkdonwFile object instead of a VaultNote object. In this case, we can specify the note_name parameter to indicate which note the MarkdownFile object came from, if applicable.\n\nhtml_data = html_data_from_note(mf, vault=None, note_name=\"Note's name\")\nprint(html_data)\n\ntest_eq(html_data['Note name'], \"Note's name\")\nassert '**' not in html_data['Raw text']\nassert '&lt;' not in html_data['Raw text']  # Test the lack of HTML tags in the raw text\n\nprint(html_data['Tag data'])\ntest_eq(len(html_data['Tag data']), 4)\nassert isinstance(html_data['Tag data'][0][0], bs4.element.Tag)\nassert html_data['Tag data'][0][0].has_attr('definition')\nassert not html_data['Tag data'][0][0].has_attr('notation')\nassert html_data['Tag data'][1][0].has_attr('notation')\nassert not html_data['Tag data'][1][0].has_attr('definition')\nassert html_data['Tag data'][2][0].has_attr('definition')\nassert not html_data['Tag data'][2][0].has_attr('notation')\nassert html_data['Tag data'][3][0].has_attr('notation')\nassert not html_data['Tag data'][3][0].has_attr('definition')\n\n{'Note name': \"Note's name\", 'Raw text': 'Let $L/K$ be a separable and normal finite field extension. Its Galois group $\\\\operatorname{Gal}(L/K)$ is...\\n\\nIn fact, the notion of a Galois group can be defined for profinite field extensions. Given a separable and normal profinite field extension $L/K$, say that\\n$L = \\\\varinjlim_i L_i$ where $L_i/K$ are finite extensions. Its Galois group $\\\\operatorname{Gal}(L/K)$\\n', 'Tag data': [(&lt;b definition=\"Galois group of a separable and normal finite field extension\"&gt;Galois group&lt;/b&gt;, 64, 76), (&lt;span notation=\"\"&gt;$\\operatorname{Gal}(L/K)$&lt;/span&gt;, 77, 102), (&lt;b definition=\"\"&gt;Galois group&lt;/b&gt;, 330, 342), (&lt;span notation=\"\"&gt;$\\operatorname{Gal}(L/K)$&lt;/span&gt;, 343, 368)]}\n[(&lt;b definition=\"Galois group of a separable and normal finite field extension\"&gt;Galois group&lt;/b&gt;, 64, 76), (&lt;span notation=\"\"&gt;$\\operatorname{Gal}(L/K)$&lt;/span&gt;, 77, 102), (&lt;b definition=\"\"&gt;Galois group&lt;/b&gt;, 330, 342), (&lt;span notation=\"\"&gt;$\\operatorname{Gal}(L/K)$&lt;/span&gt;, 343, 368)]\n\n\nIf we do not specify note_name, then None is used for the 'Note name' key in the output:\n\nhtml_data = html_data_from_note(mf, vault=None, note_name=None)\nprint(html_data)\n\nassert html_data['Note name'] is None\n\n{'Note name': None, 'Raw text': 'Let $L/K$ be a separable and normal finite field extension. Its Galois group $\\\\operatorname{Gal}(L/K)$ is...\\n\\nIn fact, the notion of a Galois group can be defined for profinite field extensions. Given a separable and normal profinite field extension $L/K$, say that\\n$L = \\\\varinjlim_i L_i$ where $L_i/K$ are finite extensions. Its Galois group $\\\\operatorname{Gal}(L/K)$\\n', 'Tag data': [(&lt;b definition=\"Galois group of a separable and normal finite field extension\"&gt;Galois group&lt;/b&gt;, 64, 76), (&lt;span notation=\"\"&gt;$\\operatorname{Gal}(L/K)$&lt;/span&gt;, 77, 102), (&lt;b definition=\"\"&gt;Galois group&lt;/b&gt;, 330, 342), (&lt;span notation=\"\"&gt;$\\operatorname{Gal}(L/K)$&lt;/span&gt;, 343, 368)]}\n\n\nFor the following example, the note has an HTML tag already with extra data (attributes other than 'definition' or 'notation'). We assert that the extra data is preserved.\n\nwith (mock.patch('__main__.VaultNote') as mock_VaultNote,\n      mock.patch('__main__.MarkdownFile.from_vault_note') as mock_from_vault_note,\n      mock.patch('__main__.isinstance') as mock_isinstance):\n    mock_VaultNote.exists.return_value = True\n    mock_VaultNote.name = \"Note's name\"\n    mock_isinstance.return_value = True\n\n    text = 'Let $X$ be a topological space and let $U \\subseteq X$ be an subspace. The &lt;b definition=\"Closure of a subspace of a topological space\" typo=\"dosure of $U$\"&gt;closure of $U$&lt;/b&gt; is defined as...'\n    mf = MarkdownFile.from_string(text)\n    mock_from_vault_note.return_value = mf\n    print(f\"The following is the text of the mocked note: \\n\\n {text}\\n\\n\")\n\n    html_data = html_data_from_note(mock_VaultNote, None)\n    print(html_data)\n    assert html_data['Tag data'][0][0].has_attr('typo')\n    test_eq(html_data['Tag data'][0][0].attrs['typo'], 'dosure of $U$')\n\nThe following is the text of the mocked note: \n\n Let $X$ be a topological space and let $U \\subseteq X$ be an subspace. The &lt;b definition=\"Closure of a subspace of a topological space\" typo=\"dosure of $U$\"&gt;closure of $U$&lt;/b&gt; is defined as...\n\n\n{'Note name': \"Note's name\", 'Raw text': 'Let $X$ be a topological space and let $U \\\\subseteq X$ be an subspace. The closure of $U$ is defined as...', 'Tag data': [(&lt;b definition=\"Closure of a subspace of a topological space\" typo=\"dosure of $U$\"&gt;closure of $U$&lt;/b&gt;, 75, 89)]}\n\n\nIn the following example, the (mocked) note has the #_auto/def_and_notats_identified tag to indicate that its definition and notation markings were auto-generated by a model (trained with data processed by the tokenize_html_data function) using the auto_mark_def_and_notats function. In this case, the html_data_from_note function returns None to prevent gathering data that is unverified and auto-generated by a model.\n\n# with (mock.patch('__main__.VaultNote') as mock_VaultNote,\n#       mock.patch('__main__.MarkdownFile.from_vault_note') as mock_from_vault_note):\n#     mock_VaultNote.exists.return_value = True\n#     mock_VaultNote.name = \"Note's name\"\ntext = r'''---\ntags: [_auto/def_and_notat_identified]\n---\nLet $X$ be a topological space and let $U \\subseteq X$ be an subspace. The &lt;b definition=\"Closure of a subspace of a topological space\" typo=\"dosure of $U$\"&gt;closure of $U$&lt;/b&gt; is defined as...'''\n\nmf = MarkdownFile.from_string(text)\nmock_from_vault_note.return_value = mf\nprint(f\"The following is the text of the mocked note: \\n\\n{text}\\n\\n\")\n\nhtml_data = html_data_from_note(note_or_mf=mf)\nassert(html_data is None)\n\nThe following is the text of the mocked note: \n\n---\ntags: [_auto/def_and_notat_identified]\n---\nLet $X$ be a topological space and let $U \\subseteq X$ be an subspace. The &lt;b definition=\"Closure of a subspace of a topological space\" typo=\"dosure of $U$\"&gt;closure of $U$&lt;/b&gt; is defined as...\n\n\n\n\n\nsource\n\n\ndef_or_notat_from_html_tag\n\n def_or_notat_from_html_tag (tag:bs4.element.Tag)\n\n*Can be passed as the ner_tag_from_html_tag argument in tokenize_html_data for the purposes of compiling a dataset for definition and notation identification.\nThe strings f”I-{output}” and f”B-{output}” are valid ner_tags. To use for*\n\nsource\n\n\ntokenize_html_data\n\n tokenize_html_data (html_locus:dict, tokenizer:Union[transformers.tokeniz\n                     ation_utils.PreTrainedTokenizer,transformers.tokeniza\n                     tion_utils_fast.PreTrainedTokenizerFast],\n                     max_length:int, ner_tag_from_html_tag:&lt;built-\n                     infunctioncallable&gt;, label2id:dict[str,int],\n                     default_label:str='O')\n\n*Actually tokenize the html data outputted by html_data_from_note.\nTo account for the possibility that the raw text is long, this function uses the tokenizer.batch_encode_plus function to tokenize the text into sequences.*\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nhtml_locus\ndict\n\nAn output of html_data_from_note\n\n\ntokenizer\nUnion\n\n\n\n\nmax_length\nint\n\nMax length for each sequence of tokens\n\n\nner_tag_from_html_tag\ncallable\n\ntakes in a bs4.element.Tag and outputs the ner_tag (as a string or None)\n\n\nlabel2id\ndict\n\nThe keys ner_tag’s of the form f”I-{output}” or f”B-{output}” where output is an output of ner_tag_from_html_tag.\n\n\ndefault_label\nstr\nO\nThe default label for the NER tagging.\n\n\nReturns\ntuple\n\nThe first list consists of the tokens and the second list consists of the named entity recognition tags.\n\n\n\nWe continue with an example using the HTML data from the example for the html_data_from_note function.\n\nmf = MarkdownFile.from_string(\n    r\"\"\"---\naliases: []\ntags: []\n---\n# Galois group of a separable and normal finite field extension\n\nLet $L/K$ be a separable and normal finite field extension. Its &lt;b definition=\"Galois group of a separable and normal finite field extension\"&gt;Galois group&lt;/b&gt; &lt;span notation=\"\"&gt;$\\operatorname{Gal}(L/K)$&lt;/span&gt; is...\n\n# Galois group of a separable and normal profinite field extension\n\nIn fact, the notion of a Galois group can be defined for profinite field extensions. Given a separable and normal profinite field extension $L/K$, say that\n$L = \\varinjlim_i L_i$ where $L_i/K$ are finite extensions. Its **Galois group** **$\\operatorname{Gal}(L/K)$**\n\n# See Also\n# Meta\n## References and Citations\n\"\"\")\n\nhtml_data = html_data_from_note(mf, vault=None, note_name=None)\nprint(html_data)\n\n# assert html_data['Note name'] is None\n\n{'Note name': None, 'Raw text': 'Let $L/K$ be a separable and normal finite field extension. Its Galois group $\\\\operatorname{Gal}(L/K)$ is...\\n\\nIn fact, the notion of a Galois group can be defined for profinite field extensions. Given a separable and normal profinite field extension $L/K$, say that\\n$L = \\\\varinjlim_i L_i$ where $L_i/K$ are finite extensions. Its Galois group $\\\\operatorname{Gal}(L/K)$\\n', 'Tag data': [(&lt;b definition=\"Galois group of a separable and normal finite field extension\"&gt;Galois group&lt;/b&gt;, 64, 76), (&lt;span notation=\"\"&gt;$\\operatorname{Gal}(L/K)$&lt;/span&gt;, 77, 102), (&lt;b definition=\"\"&gt;Galois group&lt;/b&gt;, 330, 342), (&lt;span notation=\"\"&gt;$\\operatorname{Gal}(L/K)$&lt;/span&gt;, 343, 368)]}\n\n\n\nhtml_data['Raw text']\nhtml_data[\"Tag data\"]\n\n[(&lt;b definition=\"Galois group of a separable and normal finite field extension\"&gt;Galois group&lt;/b&gt;,\n  64,\n  76),\n (&lt;span notation=\"\"&gt;$\\operatorname{Gal}(L/K)$&lt;/span&gt;, 77, 102),\n (&lt;b definition=\"\"&gt;Galois group&lt;/b&gt;, 330, 342),\n (&lt;span notation=\"\"&gt;$\\operatorname{Gal}(L/K)$&lt;/span&gt;, 343, 368)]\n\n\n\ntokenizer = AutoTokenizer.from_pretrained(\"distilbert-base-uncased\")\n\nc:\\Users\\hyunj\\Documents\\Development\\Python\\trouver_py310_venv\\lib\\site-packages\\transformers\\tokenization_utils_base.py:1601: FutureWarning: `clean_up_tokenization_spaces` was not set. It will be set to `True` by default. This behavior will be depracted in transformers v4.45, and will be then set to `False` by default. For more details check this issue: https://github.com/huggingface/transformers/issues/31884\n  warnings.warn(\n\n\n\nlabel2id = {\n    \"O\": 0,\n    \"B-definition\": 1,\n    \"I-definition\": 2,\n    \"B-notation\": 3,\n    \"I-notation\": 4\n}\ntokens, ner_tag_ids = tokenize_html_data(html_data, tokenizer, 510, def_or_notat_from_html_tag, label2id)\n\nFor this example, max_length is set to 510 (tokens). The string (“Raw text”) is not very long, so only one sequence should be present.\n\ntest_eq(len(tokens), 1)\ntest_eq(len(ner_tag_ids), 1)\n\nNow let us see what has been tagged:\n\nid2label = {value: key for key, value in label2id.items()}\nid2label\n\n{0: 'O',\n 1: 'B-definition',\n 2: 'I-definition',\n 3: 'B-notation',\n 4: 'I-notation'}\n\n\n\nfor token, ner_tag in zip(tokens[0], ner_tag_ids[0]):\n    if ner_tag != 0:\n        print(f\"{token}\\t\\t{id2label[ner_tag]}\")\n\ngal     B-definition\n##ois       I-definition\ngroup       I-definition\n$       B-notation\n\\       I-notation\noperator        I-notation\n##name      I-notation\n{       I-notation\ngal     I-notation\n}       I-notation\n(       I-notation\nl       I-notation\n/       I-notation\nk       I-notation\n)       I-notation\n$       I-notation\ngal     B-definition\n##ois       I-definition\ngroup       I-definition\n$       B-notation\n\\       I-notation\noperator        I-notation\n##name      I-notation\n{       I-notation\ngal     I-notation\n}       I-notation\n(       I-notation\nl       I-notation\n/       I-notation\nk       I-notation\n)       I-notation\n$       I-notation\n\n\nLet us set max_length to be shorter to observe an example of a tokenization of a single text across multiple sequences (Of course, in practice, the max token length would be set to be longer, say around 512 or 1024.):\n\ntoken_ids, ner_tag_ids = tokenize_html_data(html_data, tokenizer, 20, def_or_notat_from_html_tag, label2id)\n\n\nprint(len(token_ids))\nprint(len(ner_tag_ids))\n\n7\n7\n\n\n\nner_tag_ids\n\n[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2],\n [2, 2, 2, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 3, 4, 4],\n [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0]]",
    "crumbs": [
      "markdown.obsidian.personal.machine_learning.tokenize.def_and_notat_token_classification"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.machine_learning.tokenize.def_and_notat_token_classification.html#gathering-data",
    "href": "markdown.obsidian.personal.machine_learning.tokenize.def_and_notat_token_classification.html#gathering-data",
    "title": "markdown.obsidian.personal.machine_learning.tokenize.def_and_notat_token_classification",
    "section": "Gathering data",
    "text": "Gathering data\nThe following is sample code to then gather data for definition/notation identification\n\n# TODO: test\n\nnotes = [] # Replace with actual notes\nvault = '' # Replace with actual vault\n\n# vault = 'C:' # Replace with actual vault\n# notes = [] # Replace with actual notes\n\nhtml_data = [html_data_from_note(note, vault) for note in notes]\nmax_length = 1022\n\ntokenized_html_data = [tokenize_html_data(html_locus, tokenizer, max_length, def_or_notat_from_html_tag, label2id) for html_locus in html_data]\ntoken_id_data = [token_ids for token_ids, _ in tokenized_html_data]\nner_tag_data = [ner_tag_ids for _, ner_tag_ids in tokenized_html_data]\ntoken_seqs = [token_seq for token_seq in token_ids for token_ids in token_id_data]\nner_tag_seqs = [ner_tag_seq for ner_tag_seq in ner_tag_ids for ner_tag_ids in ner_tag_data]\n\n\ntokenizer = AutoTokenizer.from_pretrained(\"distilbert-base-uncased\")\nmax_length = 1022\nlabel2id = {\n    \"O\": 0,\n    \"B-definition\": 1,\n    \"I-definition\": 2,\n    \"B-notation\": 3,\n    \"I-notation\": 4\n} \nid2label = {value: key for key, value in label2id.items()}\n\n\nnote_names, token_seqs, ner_tag_seqs = [], [], []\nfor html_locus, (token_ids, ner_tag_ids) in zip(html_data, tokenized_html_data):\n    note_names.extend([html_locus[\"Note name\"]] * len(token_ids))\n    token_seqs.extend(token_ids)\n    ner_tag_seqs.extend(ner_tag_ids)\n\n\n# ner_tags = ClassLabel(names=list(label2id))\n\n# ds = Dataset.from_dict(\n#         {\"note_name\": note_names,\n#         \"tokens\": token_ids,\n#         \"ner_tags\": ner_tag_ids},\n#         features=Features(\n#             {\n#              \"note_name\": Value(dtype='string'),\n#              \"tokens\": Sequence(Value(dtype='string')),\n#              \"ner_tags\": Sequence(ner_tags)}\n#         ))\n\n# ds.save_to_disk(\".\")\n\n# ds.load_from_disk(\".\")",
    "crumbs": [
      "markdown.obsidian.personal.machine_learning.tokenize.def_and_notat_token_classification"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.machine_learning.tokenize.def_and_notat_token_classification.html#use-the-trained-model",
    "href": "markdown.obsidian.personal.machine_learning.tokenize.def_and_notat_token_classification.html#use-the-trained-model",
    "title": "markdown.obsidian.personal.machine_learning.tokenize.def_and_notat_token_classification",
    "section": "Use the trained model",
    "text": "Use the trained model\nSee https://huggingface.co/docs/transformers/tasks/token_classification for training a token classification model.\n\n# Helper functions\n\n\nsoup = bs4.BeautifulSoup('', 'html.parser')\ntag = soup.new_tag('b', style=\"border-width:1px;border-style:solid;padding:3px\", definition=\"\")\ntag.string = 'hi'\ntag\n\n&lt;b definition=\"\" style=\"border-width:1px;border-style:solid;padding:3px\"&gt;hi&lt;/b&gt;\n\n\n\nsource\n\ndef_and_notat_preds_by_model\n\n def_and_notat_preds_by_model (text:str, pipeline)\n\n*Predict where definitions and notations occur in text\nThis function uses some of the same helper functions as auto_mark_def_and_notats, but does not raise warning messages as in auto_mark_def_and_notats.*\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ntext\nstr\n\n\n\npipeline\n\nThe pipeline object created using the token classification model and its tokenizer\n\n\nReturns\nlist\nEach tuple consists of an HTML tag carrying the data of the prediction and ints marking where in text the definition or notation is at.\n\n\n\n\n# TODO: test\n\n\nsource\n\n\nauto_mark_def_and_notats\n\n auto_mark_def_and_notats (note:trouver.markdown.obsidian.vault.VaultNote,\n                           pipeline:transformers.pipelines.token_classific\n                           ation.TokenClassificationPipeline,\n                           excessive_space_threshold:int=2, add_boxing_att\n                           r_to_existing_def_and_notat_markings:bool=True)\n\n*Predict and mark where definitions and notation occur in a note using a token classification ML model.\nAssumes that the note is a standard information note that does not have a lot of “user modifications”, such as footnotes, links, and HTML tags. If there are many modifications, then these might be deleted.\nAssumes that the paragraphs in the text of the note are “not too long”. Currently, this means that the paragraphs in the number of tokens in the text of the note should (roughly) not exceed pipeline.tokenizer.model_max_length.\nExisting markings for definition and notation data (i.e. by surrounding with double asterisks or by HTML tags) are preserved (and turned into HTML tags), unless the markings overlap with predictions, in which case the original is preserved (and still turned into an HTML tag if possible)\nSince the model can make “invalid” predictions (mostly those which start or end within a LaTeX math mode str), the actual markings are not necessarily direct translates from the model’s predictions. See the helper function _consolidate_token_preds for more details on how this is implemented.\nRaises Warning messages (UserWarning) are printed in the following situations:\n\nThere are two consecutive tokens within the pipeline’s predictions of different entity types (e.g. one is predicted to belong within a definition and the other within a notation), but the latter token’s predicted 'entity' more specifically begins with 'I-' (i.e. is 'I-definition' or 'I-notation') as opposed to 'B-'.\n\nnote’s name, and path are included in the warning message in this case.\n\nThere are two consecutive tokens within the pipeline’s predictions which the pipeline predicts to belong to the same entity, and yet there is excessive space (specified by excessive_space_threshold) between the end of the first token and the start of the second.*\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nnote\nVaultNote\n\nThe standard information note in which to find the definitions and notations.\n\n\npipeline\nTokenClassificationPipeline\n\nThe token classification pipeline that is used to predict whether tokens are part of definitions or notations introduced in the text.\n\n\nexcessive_space_threshold\nint\n2\nremove_existing_def_and_notat_markings: bool = False, # If True, remove definition and notation markings (both via surrounding by double asterisks ** as per the legacy method and via HTML tags)\n\n\nadd_boxing_attr_to_existing_def_and_notat_markings\nbool\nTrue\nIf True, then nice attributes are added to the existing notation HTML tags, if not already present.\n\n\nReturns\nNone\n\n\n\n\n\nIn the following examples, we mock pipeline objects instead of using actual ones.\nIn the below example, we run the auto_mark_def_and_notats function on a note that has double asterisks ** surrounding parts of the text that introduced definitions or notations. In these cases, appropriate HTML tags replace the double asterisks instead.\n\nwith (tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir,\n      mock.patch('__main__.pipelines.token_classification.TokenClassificationPipeline') as mock_pipeline):\n    temp_vault = Path(temp_dir) / 'test_vault_6'\n    shutil.copytree(_test_directory() / 'test_vault_6', temp_vault)\n\n    mock_pipeline.tokenizer.model_max_length = 512\n\n    vn = VaultNote(temp_vault, name='reference_with_tag_labels_Definition 2')\n    print(\"Text before:\\n\\n\")\n    print(vn.text())\n    print(\"\\n\\n\\nText after:\\n\")\n    auto_mark_def_and_notats(vn, mock_pipeline)\n    print(vn.text())\n    mf = MarkdownFile.from_vault_note(vn)\n    assert mf.has_tag('_auto/def_and_notat_identified')\n\nText before:\n\n\n---\ncssclass: clean-embeds\naliases: []\ntags: [_meta/literature_note, _meta/definition, _meta/notation]\n---\n# Ring of integers modulo $n$[^1]\n\nLet $n \\geq 1$ be an integer. The **ring of integers modulo $n$**, denoted by **$\\mathbb{Z}/n\\mathbb{Z}$**, is, informally, the ring whose elements are represented by the integers with the understanding that $0$ and $n$ are equal.\n\nMore precisely, $\\mathbb{Z}/n\\mathbb{Z}$ has the elements $0,1,\\ldots,n-1$.\n\n...\n\n\n# See Also\n- [[reference_with_tag_labels_Exercise 1|reference_with_tag_labels_Z_nZ_is_a_ring]]\n# Meta\n## References\n\n## Citations and Footnotes\n[^1]: Kim, Definition 2\n\n\n\nText after:\n\n---\ncssclass: clean-embeds\naliases: []\ntags: [_meta/notation, _auto/def_and_notat_identified, _meta/literature_note, _meta/definition]\n---\n# Ring of integers modulo $n$[^1]\n\nLet $n \\geq 1$ be an integer. The &lt;b definition=\"\" style=\"border-width:1px;border-style:solid;padding:3px\"&gt;ring of integers modulo $n$&lt;/b&gt;, denoted by &lt;span notation=\"\" style=\"border-width:1px;border-style:solid;padding:3px\"&gt;$\\mathbb{Z}/n\\mathbb{Z}$&lt;/span&gt;, is, informally, the ring whose elements are represented by the integers with the understanding that $0$ and $n$ are equal.\n\nMore precisely, $\\mathbb{Z}/n\\mathbb{Z}$ has the elements $0,1,\\ldots,n-1$.\n\n...\n\n\n# See Also\n- [[reference_with_tag_labels_Exercise 1|reference_with_tag_labels_Z_nZ_is_a_ring]]\n# Meta\n## References\n\n## Citations and Footnotes\n[^1]: Kim, Definition 2\n\n\n\n# TODO: more examples with pipeline mocking actual outputs",
    "crumbs": [
      "markdown.obsidian.personal.machine_learning.tokenize.def_and_notat_token_classification"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.machine_learning.definition_and_notation_naming.html",
    "href": "markdown.obsidian.personal.machine_learning.definition_and_notation_naming.html",
    "title": "markdown.obsidian.personal.machine_learning.definition_and_notation_naming",
    "section": "",
    "text": "trouver.markdown.obsidian.personal.machine_learning.tokenize.def_and_notat_token_classification has functions for gathering and processing data to train and for using ML models to identify definitions and notations introduced in notes via token classification. Identified definition and notations are marked using HTML tags. It would be convenient to predict the “names” for these definitions and notations.\nTODO: insert examples of definitions and notations with HTML tags and examples of what the “names” of these definitions and notation should be",
    "crumbs": [
      "markdown.obsidian.personal.machine_learning.definition_and_notation_naming"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.machine_learning.definition_and_notation_naming.html#gather-ml-data-from-information-notes",
    "href": "markdown.obsidian.personal.machine_learning.definition_and_notation_naming.html#gather-ml-data-from-information-notes",
    "title": "markdown.obsidian.personal.machine_learning.definition_and_notation_naming",
    "section": "Gather ML data from information notes",
    "text": "Gather ML data from information notes\n\nsource\n\ndata_from_information_note\n\n data_from_information_note\n                             (info_note:trouver.markdown.obsidian.vault.Va\n                             ultNote)\n\n*Obtain data for naming definitions and notations for a standard information note.\nDefinitions and notations should be marked by HTML tags (see markdown.obsidian.personal.machine_learning.tokenize.def_and_notat_token_classification). - A definition is to be marked by an HTML tag with a definition attribute, which is the definition’s “name”, i.e. words and/or phrases describing what the definition is called and to what objects/situations the definition is applicable. If multiple combinations of words/phrases are appropriate, then they are separated by a single semicolon ;. If the definition attribute is \"\", then the definition name has not been marked, both manually and automatically. - A notation (technically the full LaTeX string in which the notation is introducedis) is to be marked by an HTML tag with a notation attribute, which is the notation’s “name”, i.e. the actual notation introduced in the LaTeX string (without surrounding dollar signs ($ or $$)). If multiple notations are appropriate, then they are separated by double semicolons ;;. If the notation attribute is \"\", then it means that either the notation has not been marked, or that the LaTeX string (minus the surrounding dollar signs) is exactly the introduced notation.\nReturns - list[dict[str, str]] - Each dict corresponds to a single datapoint, which holds the data of the naming of a single definition or notation (latex str) introduced in info_note. The keys are 'text' and 'definition’ or 'notation’. The text entry should be the processed text of info_note, see process_standard_information_note*\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ninfo_note\nVaultNote\nThe standard information note from which to draw data.\n\n\nReturns\nlist\nEach dict corresponds to a single datapoint, which holds the data of the naming of a single definition or notation (latex str) introduced in info_note.",
    "crumbs": [
      "markdown.obsidian.personal.machine_learning.definition_and_notation_naming"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.machine_learning.definition_and_notation_naming.html#use-the-ml-model",
    "href": "markdown.obsidian.personal.machine_learning.definition_and_notation_naming.html#use-the-ml-model",
    "title": "markdown.obsidian.personal.machine_learning.definition_and_notation_naming",
    "section": "Use the ML model",
    "text": "Use the ML model\n\nsource\n\npredict_names\n\n predict_names (info_note:trouver.markdown.obsidian.vault.VaultNote, def_a\n                nd_notat_pipeline:Optional[transformers.pipelines.text2tex\n                t_generation.SummarizationPipeline], def_pipeline:Optional\n                [transformers.pipelines.text2text_generation.Summarization\n                Pipeline], notat_pipeline:Optional[transformers.pipelines.\n                text2text_generation.SummarizationPipeline])\n\n*Predict the names of the definitions and notations using the trained ML models\nEither def_and_notat_pipeline or both def_pipeline and notat_pipeline should be provided.*\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ninfo_note\nVaultNote\n\n\n\ndef_and_notat_pipeline\nOptional\nA pipeline wrapping an ML model which predicts the naming of both definition and notations.\n\n\ndef_pipeline\nOptional\nA pipeline wrapping an ML model which predicts the naming of definitions.\n\n\nnotat_pipeline\nOptional\nA pipeline wrapping an ML model which predicts the naming of notations.\n\n\nReturns\nlist\n\n\n\n\n\nsource\n\n\nadd_names_to_html_tags_in_info_note\n\n add_names_to_html_tags_in_info_note\n                                      (info_note:trouver.markdown.obsidian\n                                      .vault.VaultNote, def_and_notat_pipe\n                                      line:Optional[transformers.pipelines\n                                      .text2text_generation.SummarizationP\n                                      ipeline]=None, def_pipeline:Optional\n                                      [transformers.pipelines.text2text_ge\n                                      neration.SummarizationPipeline]=None\n                                      , notat_pipeline:Optional[transforme\n                                      rs.pipelines.text2text_generation.Su\n                                      mmarizationPipeline]=None,\n                                      overwrite:bool=False,\n                                      fix_formatting:bool=True,\n                                      correct_syntax:bool=True)\n\n*Predict the names of definitions and notations marked with HTML tags within info_note and write those names in the \"definition\" or \"notation\" attributes in each tag.\nEither def_and_notat_pipeline or both def_pipeline and notat_pipeline should be provided.\nAn #_auto/notation_notes_linked tag is added to origin_notation_note if such a tag is not already present.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ninfo_note\nVaultNote\n\n\n\n\ndef_and_notat_pipeline\nOptional\nNone\nA pipeline wrapping an ML model which predicts the naming of both definition and notations.\n\n\ndef_pipeline\nOptional\nNone\nA pipeline wrapping an ML model which predicts the naming of definitions.\n\n\nnotat_pipeline\nOptional\nNone\nA pipeline wrapping an ML model which predicts the naming of notations.\n\n\noverwrite\nbool\nFalse\nIf True, overwrite pre-existing, nonempty attributes. If False, ignore pre-existing, nonempty attributes and only write on attributes that are empty.\n\n\nfix_formatting\nbool\nTrue\nIf True, fix the formatting for notation names.\n\n\ncorrect_syntax\nbool\nTrue\nIf True, attempt to fix syntax errors for notation names.\n\n\nReturns\nNone",
    "crumbs": [
      "markdown.obsidian.personal.machine_learning.definition_and_notation_naming"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.machine_learning.note_division.html",
    "href": "markdown.obsidian.personal.machine_learning.note_division.html",
    "title": "markdown.obsidian.personal.machine_learning.note_division",
    "section": "",
    "text": "The latex module (specifically the latex.divide module) offers soem functionality to divide a LaTeX file into “parts”. This is a systematic process and may often not divide the file in a semantically optimal way.\nThis module provides functionalities to determine where to divide mathematical text.\n\nGather ML data from information notes linked in index notes\n\nsource\n\ncombine_info_notes_in_index_notes\n\n combine_info_notes_in_index_notes\n                                    (index_note:trouver.markdown.obsidian.\n                                    vault.VaultNote)",
    "crumbs": [
      "markdown.obsidian.personal.machine_learning.note_division"
    ]
  },
  {
    "objectID": "latex.__init__.html",
    "href": "latex.__init__.html",
    "title": "latex",
    "section": "",
    "text": "The latex module contains the following submodules:\nfrom trouver.helper.tests import _test_directory\n# from trouver.latex.preamble import divide_preamble",
    "crumbs": [
      "latex"
    ]
  },
  {
    "objectID": "latex.__init__.html#identify-the-main-tex-file-in-a-folder",
    "href": "latex.__init__.html#identify-the-main-tex-file-in-a-folder",
    "title": "latex",
    "section": "Identify the main tex file in a folder",
    "text": "Identify the main tex file in a folder\n\n\nfind_main_latex_file\n\n find_main_latex_file (directory:os.PathLike)\n\n*Identify the main LaTeX file in a given directory.\nThe main LaTeX file is determined based on the presence of: - A \\documentclass command - A \\begin{document} command\nParameters: - directory: The path to the directory containing LaTeX files.\nReturns: - The full path to the main LaTeX file if found; otherwise, raises an error.\nRaises: - FileNotFoundError: If no suitable main LaTeX file is found.*\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ndirectory\nPathLike\n\n\n\nReturns\nPath\nThe full path to the main LaTeX file if found; otherwise, raises an error.\n\n\n\n\nlatex_folder = _test_directory() / 'latex_examples' / 'latex_example_with_inputs_and_includes'\nfind_main_latex_file(latex_folder)\n# main_file = latex_folder / 'main.tex'\n# with open(main_file, 'r', encoding='utf-8') as file:\n#     document = file.read()\n# preamble, body = divide_preamble(document)\n# commands = custom_commands(preamble)\n# output = replace_input_and_include(body, latex_folder, commands)\n\nWindowsPath('c:/Users/hyunj/Documents/Development/Python/trouver/nbs/_tests/latex_examples/latex_example_with_inputs_and_includes/main.tex')",
    "crumbs": [
      "latex"
    ]
  },
  {
    "objectID": "release_notes.html",
    "href": "release_notes.html",
    "title": "release_notes",
    "section": "",
    "text": "Implemented various functions culminating to auto_mark_def_and_notats in 28_markdown.obsidian.persona.machine_learning.tokenize.ipynb\nAdded the repeat_replacing_custom_commands parameter in setup_references_from_latex_parts in 16_latex.convert.ipynb.\nReorganized 16_latex.convert.ipynb, moving parts of the code to the newly created 29_latex.divide.ipynb, 30_latex.folders.ipynb, 31_latex.formatting.ipynb, 32_latex.preamble.ipynb, and 33_latex.comments.ipynb.\n\nFixed an issue with numbering involving equation environments — some LaTeX files are formatted so that theorem-like environments share the same counter with the equation environment. However, previous versions of trouver did not account for counter changes from equation environments.\nChanged how divide_latex_text deals with subsubsections — in general, subsusections are divided out into their own “parts” (and the functions in 16_latex.convert.ipynb create notes corresponding to these parts, but do not create subfolders for subsubsections).\nCertain environments (such as gather, gather*, displaymath, displaymath* will no longer be divided into their own parts). See the list DEFAULT_ENVIRONMENTS_TO_NOT_DIVIDE_ALONG in 29_latex.divide.ipynb.\nMade the adjust_common_syntax_to_markdown (which is now moved to 31_latex.formatting.ipynb from 16_latex.convert.ipynb) function accept an options parameter, which allows for more choices when modifying formats in text from LaTeX files as they are converted into Markdown notes for viewing on Obsidian.md.\n\nModified one of the returned values of parse_notation_notes in 20_markdown.obsidian.personal.notation.ipynb to be a list of tuples of two str’s instead of a MarkdownFile; this returned value is supposed to capture the information of the bulleted list of notation notes to which the argument notation_note links.\nIntroduced 34_markdown.obsidian.machine_learning.notation_linking.ipynb, 35_markdown.obsidian.personal.machine_learning.definition_and_notation_naming.ipynb\nSeparated 00_helper.ipynb into 36_helper.tests.ipynb, 37_helper.regex.ipynb, 38_helper.html.ipynb, 39_helper.definiton_and_notation.ipynb, 40_helper.numbers.ipynb, 41_helper.accented_characters.ipynb, 42_helper.date_and_time.ipynb, 43_helper.topological_sort.ipynb, 44_helper.alphabet.ipynb, 45_helper.path_accepted_string.ipynb, 46_helper.files_and_folders.ipynb\nAdded 47_helper.latex.ipynb and implemented experimental, rudimentary functions for detecting syntax validity of LaTeX math mode strings and for cleaning up LaTeX math mode strings.\nAdded correct_latex_syntax_error in 25_markdown.obsidian.persoal.machine_learning.notation_summarzation.ipynb to attempt to correct syntax errors present in autogenerated summaries. Also added an invocation of this function to summarize_notation.\nAdded __copy__ and __eq__ methods to VaultNote class.\nCreated 50_markdown.obsidian.vault_and_links.ipynb, moved some functions from 06_markdown.obsidian.links.ipynb into there.\nAdded replace_links_in_text in 06_markdown.obsidian.links.ipynb\nSeparated 20_markdown.obsidian.personal.notation.ipynb into 51_markdown.obsidian.personal.notation.parse and 52_markdown.obsidian.personal.notation.in_standard_information_note\nautomatically_add_note_type_tags in 23_markdown.obsidian.personal.machine_learning.information_note_types.ipynb can now use multiple models/TextLearner objects to add note type label predictions to information notes.\nChanged the name of find_links_in_markdown_text in 06_markdown.obsidian.links.ipynb to link_ranges_in_text\nDeprecated gather_information_note_types and append_to_information_note_type_database in 23_markdown.obsidian.personal.machine_learning.information_note_types.ipynb and implemented labels_and_identifying_info_from_notes and information_note_types_as_dataset to compile information note type data into Dataset’s instead of pandas.DataFrame’s.\nRenamed 28_markdown.obsidian.personal.machine_learning.tokenize to 28_markdown.obsidian.personal.machine_learning.tokenize.def_and_notat_token_classification.\nImplemented 49_helper.arxiv.ipynb to with functions to download arxiv articles (source code or pdf).\nImplemented in adjust_common_syntax_to_markdown in 31_latex.formatting.ipynb the ability to remove invocations of \\xspace and \\ensuremath.\nImplemented replace_inclusion_of_style_file_with_code in 32_latex.premable.ipynb\nImplemented find_main_latex_file in 15_latex.__init__.ipynb\nCreated 54_app.__init__.ipynb to develop code for a GUI app.\n\nCurrently, the app can get the user to download an arXiv source file, divide the latex file into parts of an Obsidian.md vault, make note type and def/notat token predictions, and the compile the arXiv source file back into a single .tex file.\nImplemented get_huggingface_cache_dir in 46_helper.files_and_folders.ipynb.\nImplemented convert_notes_to_latex_code in 16_latex.convert.ipynb.\nImplemented find_main_latex_file in 15_latex.__init__.ipynb.\nModified setup_reference_from_latex_parts in 16_latex.convert.ipynb.\n\nThe function no longer requires reference and template folders to exist in the “main” vault.\n\nImplemented replace_inclusion_of_style_file_with_code in 32_latex.preamble.ipynb.\n\nCreated 55_helper.packages.ipynb to check that packages are installed and if not, install them during runtime.",
    "crumbs": [
      "release_notes"
    ]
  },
  {
    "objectID": "release_notes.html#ver-1.0.1",
    "href": "release_notes.html#ver-1.0.1",
    "title": "release_notes",
    "section": "",
    "text": "Implemented various functions culminating to auto_mark_def_and_notats in 28_markdown.obsidian.persona.machine_learning.tokenize.ipynb\nAdded the repeat_replacing_custom_commands parameter in setup_references_from_latex_parts in 16_latex.convert.ipynb.\nReorganized 16_latex.convert.ipynb, moving parts of the code to the newly created 29_latex.divide.ipynb, 30_latex.folders.ipynb, 31_latex.formatting.ipynb, 32_latex.preamble.ipynb, and 33_latex.comments.ipynb.\n\nFixed an issue with numbering involving equation environments — some LaTeX files are formatted so that theorem-like environments share the same counter with the equation environment. However, previous versions of trouver did not account for counter changes from equation environments.\nChanged how divide_latex_text deals with subsubsections — in general, subsusections are divided out into their own “parts” (and the functions in 16_latex.convert.ipynb create notes corresponding to these parts, but do not create subfolders for subsubsections).\nCertain environments (such as gather, gather*, displaymath, displaymath* will no longer be divided into their own parts). See the list DEFAULT_ENVIRONMENTS_TO_NOT_DIVIDE_ALONG in 29_latex.divide.ipynb.\nMade the adjust_common_syntax_to_markdown (which is now moved to 31_latex.formatting.ipynb from 16_latex.convert.ipynb) function accept an options parameter, which allows for more choices when modifying formats in text from LaTeX files as they are converted into Markdown notes for viewing on Obsidian.md.\n\nModified one of the returned values of parse_notation_notes in 20_markdown.obsidian.personal.notation.ipynb to be a list of tuples of two str’s instead of a MarkdownFile; this returned value is supposed to capture the information of the bulleted list of notation notes to which the argument notation_note links.\nIntroduced 34_markdown.obsidian.machine_learning.notation_linking.ipynb, 35_markdown.obsidian.personal.machine_learning.definition_and_notation_naming.ipynb\nSeparated 00_helper.ipynb into 36_helper.tests.ipynb, 37_helper.regex.ipynb, 38_helper.html.ipynb, 39_helper.definiton_and_notation.ipynb, 40_helper.numbers.ipynb, 41_helper.accented_characters.ipynb, 42_helper.date_and_time.ipynb, 43_helper.topological_sort.ipynb, 44_helper.alphabet.ipynb, 45_helper.path_accepted_string.ipynb, 46_helper.files_and_folders.ipynb\nAdded 47_helper.latex.ipynb and implemented experimental, rudimentary functions for detecting syntax validity of LaTeX math mode strings and for cleaning up LaTeX math mode strings.\nAdded correct_latex_syntax_error in 25_markdown.obsidian.persoal.machine_learning.notation_summarzation.ipynb to attempt to correct syntax errors present in autogenerated summaries. Also added an invocation of this function to summarize_notation.\nAdded __copy__ and __eq__ methods to VaultNote class.\nCreated 50_markdown.obsidian.vault_and_links.ipynb, moved some functions from 06_markdown.obsidian.links.ipynb into there.\nAdded replace_links_in_text in 06_markdown.obsidian.links.ipynb\nSeparated 20_markdown.obsidian.personal.notation.ipynb into 51_markdown.obsidian.personal.notation.parse and 52_markdown.obsidian.personal.notation.in_standard_information_note\nautomatically_add_note_type_tags in 23_markdown.obsidian.personal.machine_learning.information_note_types.ipynb can now use multiple models/TextLearner objects to add note type label predictions to information notes.\nChanged the name of find_links_in_markdown_text in 06_markdown.obsidian.links.ipynb to link_ranges_in_text\nDeprecated gather_information_note_types and append_to_information_note_type_database in 23_markdown.obsidian.personal.machine_learning.information_note_types.ipynb and implemented labels_and_identifying_info_from_notes and information_note_types_as_dataset to compile information note type data into Dataset’s instead of pandas.DataFrame’s.\nRenamed 28_markdown.obsidian.personal.machine_learning.tokenize to 28_markdown.obsidian.personal.machine_learning.tokenize.def_and_notat_token_classification.\nImplemented 49_helper.arxiv.ipynb to with functions to download arxiv articles (source code or pdf).\nImplemented in adjust_common_syntax_to_markdown in 31_latex.formatting.ipynb the ability to remove invocations of \\xspace and \\ensuremath.\nImplemented replace_inclusion_of_style_file_with_code in 32_latex.premable.ipynb\nImplemented find_main_latex_file in 15_latex.__init__.ipynb\nCreated 54_app.__init__.ipynb to develop code for a GUI app.\n\nCurrently, the app can get the user to download an arXiv source file, divide the latex file into parts of an Obsidian.md vault, make note type and def/notat token predictions, and the compile the arXiv source file back into a single .tex file.\nImplemented get_huggingface_cache_dir in 46_helper.files_and_folders.ipynb.\nImplemented convert_notes_to_latex_code in 16_latex.convert.ipynb.\nImplemented find_main_latex_file in 15_latex.__init__.ipynb.\nModified setup_reference_from_latex_parts in 16_latex.convert.ipynb.\n\nThe function no longer requires reference and template folders to exist in the “main” vault.\n\nImplemented replace_inclusion_of_style_file_with_code in 32_latex.preamble.ipynb.\n\nCreated 55_helper.packages.ipynb to check that packages are installed and if not, install them during runtime.",
    "crumbs": [
      "release_notes"
    ]
  },
  {
    "objectID": "release_notes.html#ver-0.0.5",
    "href": "release_notes.html#ver-0.0.5",
    "title": "release_notes",
    "section": "Ver 0.0.5",
    "text": "Ver 0.0.5\n\nModified the latex_to_path_accepted_string function to remove some more LaTeX commands and to substitute a few symbols with designated strings.\n\nThe function may be subject to more changes in the near future.\n\nsingle_input_for_notation_summarization now takes a parameter latex_in_original_comes_first with a default value of True. This default value for the parameter makes it so that inputs/data points for the notation summarization task first lists the latex_in_original field containing the notation to be summarized before the mathematical excerpt; previously, the mathematical excerpt was first listed before the latex_in_original field.\n\nThe notation_summarizations_model repo now contains a model trained on data points that first list the latex_in_original field. Set the latex_in_original_comes_first parameter of the single_input_for_notation_summarization function to False to use the older model.\nFunctions using single_input_for_notation_summarization now also take a parameter latex_in_original_comes_first.\n\nModified dict_to_metadata_lines and MarkdownFile.replace_metadata in 04_markdown.markdown.file.ipynb to take the enquote_entries_in_fields parameter that specifies whether or not to enquote string values in fields in YAML metadata of an Obsidian Markdown note.\n\nOther functions and methods that depend on MarkdownFile.replace_metadata were also modified to have enquote_entries_in_metadata_fields parameters. These include MarkdownFile.add_tags, MarkdownFile.remove_tags, MarkdownFile.replace_auto_tags_with_regular_tags, and _write_summary_to_notation_note in 25_markdown.obsidian.personal.machine_learning.notation_summarization.ipynb.\nThe issue involving append_summary_to_notation_note where the modified notation note has non-enquoted text in the latex_in_original field should have been at least partially resolved.\n\nAdded parse_metadata_string to 04_markdown.markdown.file.ipynb and made MarkdownFile.metadata use it.\nAdded MarkdownFile.metadata_parts to 04_markdown.markdown.file.ipynb.\nAdded 27_markdown.obsidian.personal.vault.ipynb.\n\nAdded setup_obsidian_vault_for_trouver which is intended to add directories required by trouver in an Obsidian.md vault\n\nFixed a bug in the subfunction _index_note_in_parent_directory of index_note_of_note in 21_markdown.obsidian.personal.information_notes.ipynb; this bug was preventing the function from properly finding the index note of an information note when the two notes are in the same directory.",
    "crumbs": [
      "release_notes"
    ]
  },
  {
    "objectID": "release_notes.html#ver.-0.0.4",
    "href": "release_notes.html#ver.-0.0.4",
    "title": "release_notes",
    "section": "Ver. 0.0.4",
    "text": "Ver. 0.0.4\n\nCreated tutorial.walkthrough as a end-to-end walkthrough on setting up a trouver workflow.\nAdded toml as a requirement in settings.ini.\nMoved pathvalidate from a Dev requirement to a requirement in settings.ini.\nMade release_notes and moved the version release notes from index to release_notes.\nMade how_to.install_trouver and Updated installation instructions.\nUpdated the docstring of the MarkdownFile.has_tag method to more clearly state when it returns True.\nModified the append_summary_to_notation_note function in markdown.obsidian.personal.machine_learning.notation_summarization to take a parameter overwrite_previous_autogenerated_summary which, when set to True, tells the function to overwrite autogenerated summaries in the notation note (a notation note is considered to have an autogenerated summary if it has the _auto/notation_summary tag in its YAML frontmatter metadata).\nModified the MarkdownFile.remove_tags method in markdown.markdown.file to simply return and not change the MarkdownFile object if the MarkdownFile object does not have YAML frontmatter metadata or if the frontmatter YAML metadata does not include a tags line. In particular, MarkdownFile.remove_tags does not raise an Error in either of these cases.\nMade the constructor of the VaultNote class in markdown.obsidian.vault raise a ValueError as opposed to an AssertionError if both the name and rel_path parameters are given the argument None.\nAdded some examples for markdown.obsidian.personal.machine_learning.notation_summarization\nChanged append_to_notation_note_summarization_database to use the 'Notation note name' column as the pivot in invoking the append_to_database function; previously, the 'Processed main note contents' column was used as the pivot column, which meant that data for notation notes sharing the same main note would be lost in making the database csv file.\nMade markdown.obsidian.personal.machine_learning.notation_summarization import the os.Path class; the notation_summarization module was previously using the os.Path class but not importing it.\nModified copy_obisidian_vault_configs and copy_obsidian_vault_configs_with_nice_modifications in markdown.obsidian.personal.reference.ipynb to take the parameter dirs_exist_ok; if this is set to False, then attempting to copy configs into an existing configs directory is prevented. Otherwise, existing files in the pre-existing configs directory are overwritten. See also the dirs_exist_ok parameter of the shutil.copytree function.\nModified latex_to_path_accepted_string in helper to use the sanitize_filename function from the pathvalidate library. In particular, this should ensure that make_notation_notes_from_double_asts only attempts to create notation notes with names which are valid as file names.\nThe custom_commands function in latex.convert can parse LaTeX \\newcommand and \\command invocations in which the defined command is not surrounded by parentheses, e.g. \\newcommand\\A{{\\mathbb A}} is recognized as defining the command \\A which has display text {\\mathbb A}.\nMade adjust_common_syntax_to_markdown in latex.convert recognize the eqnarray environment as an environment to adjust.",
    "crumbs": [
      "release_notes"
    ]
  },
  {
    "objectID": "release_notes.html#ver.-0.0.3",
    "href": "release_notes.html#ver.-0.0.3",
    "title": "release_notes",
    "section": "Ver. 0.0.3",
    "text": "Ver. 0.0.3\n\nFixed issue # 32 in which setting up an Obsidian.md vault folder from a LaTeX document was not numbering sections and theorem-like environments correctly with a theorem-like environment of the form \\numbertheorem{theorem}{Theorem}[section] was being defined.\nFinished implementing append_summary_to_notation_note\nModified dict_to_metadata function to escape and enquote strings if necessary to take into consideration that yaml.safe_load does uses quotations to consider strings as escaped.\nFixed a bug in notation_notes_linked_in_see_also_section where the main of notation where the VaultNote objects were incorrectly constructed by passing an argument to the rel_path parameter as opposed to the name parameter.\nFixed a bug in _obsidian_vault_plugin_configs_file; I had realized that files for non-core Obsidian.md plugins are stored in .obsidian/plugins/&lt;plugin_name&gt; in the vault directory.\nChanged the default template_location argument from '.' to '/' in markdown.obsidian.personal.reference.\nMove latex_to_path_accepted_string function from 20_markdown.obsidian.personal.notation.ipynb to 00_helper.ipynb\nModify _consider_part_to_add in 16_latex.convert so that multi-line section titles in LaTeX documents get parsed as single-line titles\nModify convert_title_to_folder_name in 12_markdown.obsidian.personal.index_notes.ipynb and _create_note_for_part in 16_latex.convert.ipynb to use sanitize_filename",
    "crumbs": [
      "release_notes"
    ]
  },
  {
    "objectID": "release_notes.html#ver.-0.0.2",
    "href": "release_notes.html#ver.-0.0.2",
    "title": "release_notes",
    "section": "Ver. 0.0.2",
    "text": "Ver. 0.0.2\n\nI made the mistake of note including much of the contents of index.ipynb in the pypi library release, so that should be fixed..",
    "crumbs": [
      "release_notes"
    ]
  },
  {
    "objectID": "release_notes.html#ver.-0.0.1",
    "href": "release_notes.html#ver.-0.0.1",
    "title": "release_notes",
    "section": "Ver. 0.0.1",
    "text": "Ver. 0.0.1\n\nInitial release",
    "crumbs": [
      "release_notes"
    ]
  },
  {
    "objectID": "how_to.train_ml_model.fastai.html",
    "href": "how_to.train_ml_model.fastai.html",
    "title": "how_to.train_ml_model.fastai",
    "section": "",
    "text": "import pandas as pd\nfrom fastai.text.all import *\nfrom trouver.helper.tests import _test_directory\n\nimport warnings\n# A lot of warnings can be printed out\nwarnings.filterwarnings(\"ignore\")",
    "crumbs": [
      "how_to.train_ml_model.fastai"
    ]
  },
  {
    "objectID": "how_to.train_ml_model.fastai.html#general",
    "href": "how_to.train_ml_model.fastai.html#general",
    "title": "how_to.train_ml_model.fastai",
    "section": "General",
    "text": "General\nWe use the ULMFiT approach (cf. fast.ai documentation, fast.ai tutorial on text transfer learning) to train a text categorization model.\nThis approach first trains a language model from the corpus of text in the data and then uses the encoder - the model not including the final layer - of this language model to then train the classification model.\n\n# This line is only present for the sake of this example so that the code in this notebook can run even\n# if the device does not have a gpu.\ndevice = torch.device(\"cpu\")",
    "crumbs": [
      "how_to.train_ml_model.fastai"
    ]
  },
  {
    "objectID": "how_to.train_ml_model.fastai.html#train-information-note-type-model",
    "href": "how_to.train_ml_model.fastai.html#train-information-note-type-model",
    "title": "how_to.train_ml_model.fastai",
    "section": "Train information note type model",
    "text": "Train information note type model\nThe append_to_information_note_type_database function in markdown.obsidian.personal.machine_learning.information_note_types creates/appends to a csv file containing data of note types.\n\n# Replace this file with the appropriate file\ncsv_file = _test_directory() / 'ml_examples' / 'information_note_type_labels.csv'\nfolder = _test_directory() / 'ml_examples'\n\ndf = pd.read_csv(csv_file)\ndf\n\n\n\n\n\n\n\n\nTime added\nTime modified\nNote name\nFull note content\nProcessed note content\n#_meta/concept\n#_meta/exercise\n#_meta/definition\n#_meta/example\n#_meta/narrative\n...\n#_meta/proof\n#_meta/remark\n#_meta/TODO/split\n#_meta/TODO/merge\n#_meta/TODO/delete\n#_meta/hint\n#_meta/how_to\n#_meta/conjecture\n#_meta/convention\n#_meta/context\n\n\n\n\n0\n2023-01-13T00:37\n2023-01-13T00:37\nreference_with_tag_labels_something_something\n---\\ncssclass: clean-embeds\\naliases: []\\ntags: [_meta/literature_note, _meta/narrative]\\n---\\n# Topic[^1]\\n\\nIn this chapter, we describe some basics of ring theory. Rings are mathematical structures which generalize the structures of the familiar integers, rational numbers, real numbers, complex numberes, etc.\\n\\n\\n\\n# See Also\\n\\n# Meta\\n## References\\n\\n## Citations and Footnotes\\n[^1]: Kim, Page 1\nIn this chapter, we describe some basics of ring theory. Rings are mathematical structures which generalize the structures of the familiar integers, rational numbers, real numbers, complex numberes, etc.\\n\nNOT #_meta/concept\nNOT #_meta/exercise\nNOT #_meta/definition\nNOT #_meta/example\nIS #_meta/narrative\n...\nNOT #_meta/proof\nNOT #_meta/remark\nNOT #_meta/TODO/split\nNOT #_meta/TODO/merge\nNOT #_meta/TODO/delete\nNOT #_meta/hint\nNOT #_meta/how_to\nNOT #_meta/conjecture\nNOT #_meta/convention\nNOT #_meta/context\n\n\n1\n2023-01-13T00:37\n2023-01-13T00:37\nreference_with_tag_labels_Definition 1\n---\\ncssclass: clean-embeds\\naliases: []\\ntags: [_meta/literature_note, _meta/definition_note]\\n---\\n# Ring[^1]\\n\\nA **ring** is a set with binary operators $+$ and $\\cdot$ such that ...\\n\\n# See Also\\n\\n# Meta\\n## References\\n\\n## Citations and Footnotes\\n[^1]: Kim, Definition 1\nA ring is a set with binary operators $+$ and $\\cdot$ such that ...\\n\nNOT #_meta/concept\nNOT #_meta/exercise\nNOT #_meta/definition\nNOT #_meta/example\nNOT #_meta/narrative\n...\nNOT #_meta/proof\nNOT #_meta/remark\nNOT #_meta/TODO/split\nNOT #_meta/TODO/merge\nNOT #_meta/TODO/delete\nNOT #_meta/hint\nNOT #_meta/how_to\nNOT #_meta/conjecture\nNOT #_meta/convention\nNOT #_meta/context\n\n\n2\n2023-01-13T00:37\n2023-01-13T00:37\nreference_with_tag_labels_Definition 2\n---\\ncssclass: clean-embeds\\naliases: []\\ntags: [_meta/literature_note, _meta/definition, _meta/notation]\\n---\\n# Ring of integers modulo $n$[^1]\\n\\nLet $n \\geq 1$ be an integer. The **ring of integers modulo $n$**, denoted by **$\\mathbb{Z}/n\\mathbb{Z}$**, is, informally, the ring whose elements are represented by the integers with the understanding that $0$ and $n$ are equal.\\n\\nMore precisely, $\\mathbb{Z}/n\\mathbb{Z}$ has the elements $0,1,\\ldots,n-1$.\\n\\n...\\n\\n\\n# See Also\\n- [[reference_with_tag_labels_Exercise 1|reference_with_tag_labels_Z_nZ_is_a_ring]]\\n# Meta\\n## References\\n\\n## ...\nLet $n \\geq 1$ be an integer. The ring of integers modulo $n$, denoted by $\\mathbb{Z}/n\\mathbb{Z}$, is, informally, the ring whose elements are represented by the integers with the understanding that $0$ and $n$ are equal.\\n\\nMore precisely, $\\mathbb{Z}/n\\mathbb{Z}$ has the elements $0,1,\\ldots,n-1$.\\n\\n...\\n\nNOT #_meta/concept\nNOT #_meta/exercise\nIS #_meta/definition\nNOT #_meta/example\nNOT #_meta/narrative\n...\nNOT #_meta/proof\nNOT #_meta/remark\nNOT #_meta/TODO/split\nNOT #_meta/TODO/merge\nNOT #_meta/TODO/delete\nNOT #_meta/hint\nNOT #_meta/how_to\nNOT #_meta/conjecture\nNOT #_meta/convention\nNOT #_meta/context\n\n\n3\n2023-01-13T00:37\n2023-01-13T00:37\nreference_with_tag_labels_Exercise 1\n---\\ncssclass: clean-embeds\\naliases: [reference_with_tag_labels_Z_nZ_is_a_ring]\\ntags: [_meta/literature_note, _meta/exercise]\\n---\\n# $\\mathbb{Z}/n\\mathbb{Z}$ is a ring[^1]\\n\\nShow that $\\mathbb{Z}/n\\mathbb{Z}$ is a ring.\\n\\n# See Also\\n\\n# Meta\\n## References\\n\\n## Citations and Footnotes\\n[^1]: Exercise 1\nShow that $\\mathbb{Z}/n\\mathbb{Z}$ is a ring.\\n\nNOT #_meta/concept\nIS #_meta/exercise\nNOT #_meta/definition\nNOT #_meta/example\nNOT #_meta/narrative\n...\nNOT #_meta/proof\nNOT #_meta/remark\nNOT #_meta/TODO/split\nNOT #_meta/TODO/merge\nNOT #_meta/TODO/delete\nNOT #_meta/hint\nNOT #_meta/how_to\nNOT #_meta/conjecture\nNOT #_meta/convention\nNOT #_meta/context\n\n\n4\n2023-01-13T00:37\n2023-01-13T00:37\nreference_with_tag_labels_Theorem 1\n---\\ncssclass: clean-embeds\\naliases: []\\ntags: [_meta/literature_note, _meta/concept, _meta/proof]\\n---\\n# The polynomial ring of a UFD is a UFD[^1]\\n\\nTheorem 1. Let $R$ be a UFD. Then $R[x]$ is a UFD.\\n\\nProof. Let $f,g \\in R[x]$ and suppose that $fg = 0$. Write $f = \\sum_{i=0}^n a_i x^i$ and $g = \\sum_{j=0}^m b_j x^j$ for some $a_i,b_j \\in R$.\\n\\n...\\n\\n# See Also\\n\\n# Meta\\n## References\\n\\n## Citations and Footnotes\\n[^1]: Kim, Theorem 1\nTheorem 1. Let $R$ be a UFD. Then $R[x]$ is a UFD.\\n\\nProof. Let $f,g \\in R[x]$ and suppose that $fg = 0$. Write $f = \\sum_{i=0}^n a_i x^i$ and $g = \\sum_{j=0}^m b_j x^j$ for some $a_i,b_j \\in R$.\\n\\n...\\n\nIS #_meta/concept\nNOT #_meta/exercise\nNOT #_meta/definition\nNOT #_meta/example\nNOT #_meta/narrative\n...\nIS #_meta/proof\nNOT #_meta/remark\nNOT #_meta/TODO/split\nNOT #_meta/TODO/merge\nNOT #_meta/TODO/delete\nNOT #_meta/hint\nNOT #_meta/how_to\nNOT #_meta/conjecture\nNOT #_meta/convention\nNOT #_meta/context\n\n\n\n\n5 rows × 21 columns\n\n\n\n\nTrain language model\nTo train the language model, we need to create the TextDataLoaders object. For our purposes, the column containing the input is the Processed note content column.\n\ndls_lm = TextDataLoaders.from_df(\n    df, path=folder / 'information_note_type', text_col='Processed note content', bs=16,\n    valid_pct=0.2, is_lm=True, seq_len=256)  #  label_col='#_meta/definition' for later\ndls_lm.show_batch(max_n=3)\n\nDue to IPython and Windows limitation, python multiprocessing isn't available now.\nSo `n_workers` has to be changed to 0 to avoid getting stuck\n\n\n\n\n\n\ntext\ntext_\n\n\n\n\n0\nxxbos xxmaj xxunk xxunk . xxmaj let $ xxunk xxunk a xxup xxunk\nxxmaj xxunk xxunk . xxmaj let $ xxunk xxunk a xxup xxunk .\n\n\n1\n. xxmaj xxunk $ xxunk is a xxup xxunk . xxunk xxmaj xxunk\nxxmaj xxunk $ xxunk is a xxup xxunk . xxunk xxmaj xxunk .\n\n\n2\n. xxmaj let $ xxunk , xxunk \\ in xxmaj xxunk and xxunk\nxxmaj let $ xxunk , xxunk \\ in xxmaj xxunk and xxunk that\n\n\n\n\n\nWe now create the TextLearner object, which is the language model.\nInvoking to_fp16 on the Learner lets the model train with 16-bit floats (as opposed to 32-bit floats) and thus memory usage is (in theory) halved. Alternatively, training with 16-bit floats allows one to double the size of the model and double the batch size for training.\n\nlearn = language_model_learner(\n    dls_lm, AWD_LSTM, drop_mult=0.3,\n    metrics=[accuracy, Perplexity()]).to_fp16()\n\nTraining an ML model can take a long time, depending on the amount of data with which to train. As such, it can be useful to save your model and/or its weights in between training cycles. The below demonstrates two ways to load weights:\n\nThe first way assumes that the weights to load are from a model trained with the same dataset as learn. learn.load just loads these weights to learn.\nThe second way is for a model trained with a different dataset. A model trained with a different dataset is likely to have a different vocabulary, so the pretrained_fnames argument contains this different vocabulary to take into account when loading weights.\n\nIf such weights are not loaded to the model learn, then learn is initially a language model that was pretrained on Wikipedia, cf. fast.ai on the ULMFiT approach\n\n# Only use the below code if you want to continue training a model of the same dataset.\n# TODO: test the below code and see where the weights have to be. \n\n# learn.load('information_note_type_LM_weights')\n\n\n# only use the below code if you want to use weights from another pretrained model (whose data points).\n# are different from those used to build dls_lm.\n\n# TODO: think about how to set up vocab.\n# vocab=  load_learner(folder / 'information_note_type' / 'models' / 'information_note_type_LM.pkl').dls.vocab\n\n# pretrained_fnames = ['information_note_type_LM_weights', 'information_note_type_LM_vocab']\n# learn = language_model_learner(\n#     dls_lm, AWD_LSTM, drop_mult=0.3,\n#     metrics=[accuracy, Perplexity()], pretrained_fnames=pretrained_fnames)\n# learn = learn.to_fp16()\n\nNow we train the model:\n\n# Feel free to run the below code multiple times\n\n# Get a good learning rate\n# lrfind = learn.lr_find()\n\n# The code below should be uncommented when actually training.\n# Note that `learn` is frozen except for this last layer\n# Feel free to change up the number of cycles.\n\n# learn.fit_one_cycle(3, lrfind.valley)\n\n\n# Save the weights; note that this overwrites the existing weights file.\n# learn.save('information_note_type_LM_weights')\n\nNow we train the model unfrozen\n\nlearn.unfreeze()\n\n\n# Feel free to run the below code multiple times\n\n# Get a good learning rate\n# lrfind = learn.lr_find()\n\n# Note that `learn` is frozen except for this last layer\n# Feel free to change up the number of cycles.\n# learn.fit_one_cycle(3, lrfind)\n\nThere are some components of learn that can be worthwhile to save;\n\nAn encoder - as explained above, the encoder of the language model is used to then train the categorization model.\nlearn.dls.vocab - as explained above, the vocabulary of the model needs to be preserved if the weights of learn are to be used in a new language model that uses a different dataset.\nlearn itself - This can be done with learn.export.\n\n\n# learn.save_encoder('information_note_type_LM_encoder')\n# save_pickle(folder / 'information_note_type' / 'models' / 'information_note_type_LM_vocab.pkl', learn.dls.vocab)\n# learn = learn.to_fp32()  \n# learn.export('information_note_type_LM')\n\n\n\nTesting the language model\n\n# TEXT = ''\n# N_WORDS = 20\n# N_SENTENCES = 5\n# preds = [learn.predict(TEXT, N_WORDS, temperature=0.75) for _ in range(N_SENTENCES)]\n\n\n# print('\\n'.join(preds))\n\n\n\nTrain classification model\nNow we use the encoder for the language model that we trained to train a classification model.\nWe first process the DataFrame to combine the labels into a single column:\n\n# Replace this file with the appropriate file\ncsv_file = _test_directory() / 'ml_examples' / 'information_note_type_labels.csv'\nfolder = _test_directory() / 'ml_examples'\n\ndf = pd.read_csv(csv_file)\ndf\n\n\n\n\n\n\n\n\nTime added\nTime modified\nNote name\nFull note content\nProcessed note content\n#_meta/concept\n#_meta/exercise\n#_meta/definition\n#_meta/example\n#_meta/narrative\n...\n#_meta/proof\n#_meta/remark\n#_meta/TODO/split\n#_meta/TODO/merge\n#_meta/TODO/delete\n#_meta/hint\n#_meta/how_to\n#_meta/conjecture\n#_meta/convention\n#_meta/context\n\n\n\n\n0\n2023-01-13T00:37\n2023-01-13T00:37\nreference_with_tag_labels_something_something\n---\\ncssclass: clean-embeds\\naliases: []\\ntags: [_meta/literature_note, _meta/narrative]\\n---\\n# Topic[^1]\\n\\nIn this chapter, we describe some basics of ring theory. Rings are mathematical structures which generalize the structures of the familiar integers, rational numbers, real numbers, complex numberes, etc.\\n\\n\\n\\n# See Also\\n\\n# Meta\\n## References\\n\\n## Citations and Footnotes\\n[^1]: Kim, Page 1\nIn this chapter, we describe some basics of ring theory. Rings are mathematical structures which generalize the structures of the familiar integers, rational numbers, real numbers, complex numberes, etc.\\n\nNOT #_meta/concept\nNOT #_meta/exercise\nNOT #_meta/definition\nNOT #_meta/example\nIS #_meta/narrative\n...\nNOT #_meta/proof\nNOT #_meta/remark\nNOT #_meta/TODO/split\nNOT #_meta/TODO/merge\nNOT #_meta/TODO/delete\nNOT #_meta/hint\nNOT #_meta/how_to\nNOT #_meta/conjecture\nNOT #_meta/convention\nNOT #_meta/context\n\n\n1\n2023-01-13T00:37\n2023-01-13T00:37\nreference_with_tag_labels_Definition 1\n---\\ncssclass: clean-embeds\\naliases: []\\ntags: [_meta/literature_note, _meta/definition_note]\\n---\\n# Ring[^1]\\n\\nA **ring** is a set with binary operators $+$ and $\\cdot$ such that ...\\n\\n# See Also\\n\\n# Meta\\n## References\\n\\n## Citations and Footnotes\\n[^1]: Kim, Definition 1\nA ring is a set with binary operators $+$ and $\\cdot$ such that ...\\n\nNOT #_meta/concept\nNOT #_meta/exercise\nNOT #_meta/definition\nNOT #_meta/example\nNOT #_meta/narrative\n...\nNOT #_meta/proof\nNOT #_meta/remark\nNOT #_meta/TODO/split\nNOT #_meta/TODO/merge\nNOT #_meta/TODO/delete\nNOT #_meta/hint\nNOT #_meta/how_to\nNOT #_meta/conjecture\nNOT #_meta/convention\nNOT #_meta/context\n\n\n2\n2023-01-13T00:37\n2023-01-13T00:37\nreference_with_tag_labels_Definition 2\n---\\ncssclass: clean-embeds\\naliases: []\\ntags: [_meta/literature_note, _meta/definition, _meta/notation]\\n---\\n# Ring of integers modulo $n$[^1]\\n\\nLet $n \\geq 1$ be an integer. The **ring of integers modulo $n$**, denoted by **$\\mathbb{Z}/n\\mathbb{Z}$**, is, informally, the ring whose elements are represented by the integers with the understanding that $0$ and $n$ are equal.\\n\\nMore precisely, $\\mathbb{Z}/n\\mathbb{Z}$ has the elements $0,1,\\ldots,n-1$.\\n\\n...\\n\\n\\n# See Also\\n- [[reference_with_tag_labels_Exercise 1|reference_with_tag_labels_Z_nZ_is_a_ring]]\\n# Meta\\n## References\\n\\n## ...\nLet $n \\geq 1$ be an integer. The ring of integers modulo $n$, denoted by $\\mathbb{Z}/n\\mathbb{Z}$, is, informally, the ring whose elements are represented by the integers with the understanding that $0$ and $n$ are equal.\\n\\nMore precisely, $\\mathbb{Z}/n\\mathbb{Z}$ has the elements $0,1,\\ldots,n-1$.\\n\\n...\\n\nNOT #_meta/concept\nNOT #_meta/exercise\nIS #_meta/definition\nNOT #_meta/example\nNOT #_meta/narrative\n...\nNOT #_meta/proof\nNOT #_meta/remark\nNOT #_meta/TODO/split\nNOT #_meta/TODO/merge\nNOT #_meta/TODO/delete\nNOT #_meta/hint\nNOT #_meta/how_to\nNOT #_meta/conjecture\nNOT #_meta/convention\nNOT #_meta/context\n\n\n3\n2023-01-13T00:37\n2023-01-13T00:37\nreference_with_tag_labels_Exercise 1\n---\\ncssclass: clean-embeds\\naliases: [reference_with_tag_labels_Z_nZ_is_a_ring]\\ntags: [_meta/literature_note, _meta/exercise]\\n---\\n# $\\mathbb{Z}/n\\mathbb{Z}$ is a ring[^1]\\n\\nShow that $\\mathbb{Z}/n\\mathbb{Z}$ is a ring.\\n\\n# See Also\\n\\n# Meta\\n## References\\n\\n## Citations and Footnotes\\n[^1]: Exercise 1\nShow that $\\mathbb{Z}/n\\mathbb{Z}$ is a ring.\\n\nNOT #_meta/concept\nIS #_meta/exercise\nNOT #_meta/definition\nNOT #_meta/example\nNOT #_meta/narrative\n...\nNOT #_meta/proof\nNOT #_meta/remark\nNOT #_meta/TODO/split\nNOT #_meta/TODO/merge\nNOT #_meta/TODO/delete\nNOT #_meta/hint\nNOT #_meta/how_to\nNOT #_meta/conjecture\nNOT #_meta/convention\nNOT #_meta/context\n\n\n4\n2023-01-13T00:37\n2023-01-13T00:37\nreference_with_tag_labels_Theorem 1\n---\\ncssclass: clean-embeds\\naliases: []\\ntags: [_meta/literature_note, _meta/concept, _meta/proof]\\n---\\n# The polynomial ring of a UFD is a UFD[^1]\\n\\nTheorem 1. Let $R$ be a UFD. Then $R[x]$ is a UFD.\\n\\nProof. Let $f,g \\in R[x]$ and suppose that $fg = 0$. Write $f = \\sum_{i=0}^n a_i x^i$ and $g = \\sum_{j=0}^m b_j x^j$ for some $a_i,b_j \\in R$.\\n\\n...\\n\\n# See Also\\n\\n# Meta\\n## References\\n\\n## Citations and Footnotes\\n[^1]: Kim, Theorem 1\nTheorem 1. Let $R$ be a UFD. Then $R[x]$ is a UFD.\\n\\nProof. Let $f,g \\in R[x]$ and suppose that $fg = 0$. Write $f = \\sum_{i=0}^n a_i x^i$ and $g = \\sum_{j=0}^m b_j x^j$ for some $a_i,b_j \\in R$.\\n\\n...\\n\nIS #_meta/concept\nNOT #_meta/exercise\nNOT #_meta/definition\nNOT #_meta/example\nNOT #_meta/narrative\n...\nIS #_meta/proof\nNOT #_meta/remark\nNOT #_meta/TODO/split\nNOT #_meta/TODO/merge\nNOT #_meta/TODO/delete\nNOT #_meta/hint\nNOT #_meta/how_to\nNOT #_meta/conjecture\nNOT #_meta/convention\nNOT #_meta/context\n\n\n\n\n5 rows × 21 columns\n\n\n\n\n# Make a list of columns\n# Change the indices here if the labels change.\nlabel_cols = list(df.columns[5:-1])\n\n# Create a column of texts which has a list of all the categories.\n# When no tag is applicable, let's label it with `'NO TAG'`\ndef row_to_single_label(row, label_cols):\n    indices = np.array([i for i, tag_info in enumerate(row) if tag_info.startswith('IS')])\n    if len(indices) == 0:\n        return 'NO_TAG'\n    return ';'.join([label_cols[i] for i in indices])\n\nlabels = df[label_cols].apply(lambda row: row_to_single_label(row, label_cols), axis = 1)\ndf[\"Single label\"] = labels\n\nWe now create the DataLoaders using the DataBlock API\n\ndls_blk = DataBlock(blocks = (TextBlock.from_df(text_cols = 'Processed note content', seq_len=256),\n                              MultiCategoryBlock),\n                    get_x = ColReader(cols = 'text'),\n                    get_y = ColReader(cols = 'Single label', label_delim = ';'),\n                    splitter = TrainTestSplitter(test_size = 0.2, random_state = None))\ndls_clf = dls_blk.dataloaders(df, bs=32, seed=None)\n\nDue to IPython and Windows limitation, python multiprocessing isn't available now.\nSo `n_workers` has to be changed to 0 to avoid getting stuck\n\n\n\ndls_clf.show_batch(max_n=3)\n\n\nlearn_clf = text_classifier_learner(dls_clf, AWD_LSTM, drop_mult=0.5, metrics=accuracy_multi).to_fp16()\n\nIn the above line, - AWD_LSTM is the model architecture for the learner. - drop_mult specifies the % in dropout layer for regularization.\nBefore exporting the model, convert the learner learn_clf back to full-precision via the .to_fp32() method.\n\n# Uncomment the below code to actually load the encoder.\n\n# learn_clf.load_encoder(folder / 'information_note_type' / 'models' / 'information_note_type_encoder')  # Load the previously trained language model.\n\nWe train the model by unfreezing one layer at a time\n\n# lrfind = learn_clf.lr_ifnd()\n# learn_clf.fit_one_cycle(1, lrfind.valley)\n\n\n# learn_clf.freeze_to(-2)\n# lrfind = learn_clf.lr_find()\n# lrfind\n# learn_clf.fit_one_cycle(1, lrfind.valley)\n\n\n# learn_clf.freeze_to(-3)\n# lrfind = learn_clf.lr_find()\n# lrfind\n# learn_clf.fit_one_cycle(1, lrfind.valley)\n\n\n\nTry out results\n\n# n = random.randint(0, len(df)-1)\n# stringy = df['Processed note content'][n]\n# print(stringy)\n# print(learn_clf.predict(stringy))\n# print(df['Single label'][n])\n#for df[:5]",
    "crumbs": [
      "how_to.train_ml_model.fastai"
    ]
  },
  {
    "objectID": "helper.arxiv.html",
    "href": "helper.arxiv.html",
    "title": "helper.arxiv",
    "section": "",
    "text": "import glob\nimport tempfile\nfrom unittest.mock import patch, MagicMock\nimport shutil\n\n\nfrom fastcore.test import *\nfrom fastcore.test import test_is\nfrom nbdev.showdoc import show_doc\n\nfrom trouver.helper.tests import _test_directory\nsource",
    "crumbs": [
      "helper.arxiv"
    ]
  },
  {
    "objectID": "helper.arxiv.html#metadata-extraction",
    "href": "helper.arxiv.html#metadata-extraction",
    "title": "helper.arxiv",
    "section": "Metadata extraction",
    "text": "Metadata extraction\n\nsource\n\nextract_metadata\n\n extract_metadata (results:Union[list[arxiv.Result],arxiv.Result])\n\nReturn the metadata from the arxiv search results\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nresults\nUnion\n\n\n\nReturns\nlist\nEach dict corresponds to the metadata for each result.\n\n\n\n\nmock_result = arxiv.Result(\n    entry_id='http://arxiv.org/abs/1605.08386v1',\n    updated=datetime.datetime(2016, 5, 26, 17, 59, 46, tzinfo=datetime.timezone.utc),\n    published=datetime.datetime(2016, 5, 26, 17, 59, 46, tzinfo=datetime.timezone.utc),\n    title='Heat-bath random walks with Markov bases',\n    authors=[arxiv.Result.Author('Caprice Stanley'), arxiv.Result.Author('Tobias Windisch')],\n    summary='Graphs on lattice points are studied whose edges come from a finite set of\\nallowed moves of arbitrary length. We show that the diameter of these graphs on\\nfibers of a fixed integer matrix can be bounded from above by a constant. We\\nthen study the mixing behaviour of heat-bath random walks on these graphs. We\\nalso state explicit conditions on the set of moves so that the heat-bath random\\nwalk, a generalization of the Glauber dynamics, is an expander in fixed\\ndimension.',\n    comment='20 pages, 3 figures',\n    journal_ref=None,\n    doi=None,\n    primary_category='math.CO',\n    categories=['math.CO', 'math.ST', 'stat.TH', 'Primary: 05C81, Secondary: 37A25, 11P21'],\n    links=[arxiv.Result.Link('http://arxiv.org/abs/1605.08386v1',\n                             title=None, rel='alternate', content_type=None),\n           arxiv.Result.Link('http://arxiv.org/pdf/1605.08386v1', title='pdf', rel='related',\n                             content_type=None),])\nextract_metadata(mock_result)\n\n[{'arxiv_id': '1605.08386v1',\n  'authors': ['Caprice Stanley', 'Tobias Windisch'],\n  'title': 'Heat-bath random walks with Markov bases',\n  'summary': 'Graphs on lattice points are studied whose edges come from a finite set of\\nallowed moves of arbitrary length. We show that the diameter of these graphs on\\nfibers of a fixed integer matrix can be bounded from above by a constant. We\\nthen study the mixing behaviour of heat-bath random walks on these graphs. We\\nalso state explicit conditions on the set of moves so that the heat-bath random\\nwalk, a generalization of the Glauber dynamics, is an expander in fixed\\ndimension.',\n  'primary_category': 'math.CO',\n  'categories': ['math.CO',\n   'math.ST',\n   'stat.TH',\n   'Primary: 05C81, Secondary: 37A25, 11P21'],\n  'published': datetime.datetime(2016, 5, 26, 17, 59, 46, tzinfo=datetime.timezone.utc),\n  'updated': datetime.datetime(2016, 5, 26, 17, 59, 46, tzinfo=datetime.timezone.utc),\n  'doi': None,\n  'comment': '20 pages, 3 figures',\n  'journal_ref': None,\n  'links': [arxiv.Result.Link('http://arxiv.org/abs/1605.08386v1', title=None, rel='alternate', content_type=None),\n   arxiv.Result.Link('http://arxiv.org/pdf/1605.08386v1', title='pdf', rel='related', content_type=None)]}]\n\n\n\nsource\n\n\nArxivMetadataEncoder\n\n ArxivMetadataEncoder (skipkeys=False, ensure_ascii=True,\n                       check_circular=True, allow_nan=True,\n                       sort_keys=False, indent=None, separators=None,\n                       default=None)\n\njson encoder to accomapny the extract_metadta function when using json.dump.\n\n# Your dictionary with datetime and arxiv.Result.Link objects\ndata = {\n    \"timestamp\": datetime.datetime.now(),\n    \"link\": arxiv.Result.Link(href=\"https://example.com\", title=\"Example\")\n}\n\n# Convert the dictionary to JSON\njson_data = json.dumps(data, cls=ArxivMetadataEncoder, indent=4)\nprint(json_data)\n\n{\n    \"timestamp\": \"2024-12-26T15:31:58.139186\",\n    \"link\": \"https://example.com\"\n}",
    "crumbs": [
      "helper.arxiv"
    ]
  },
  {
    "objectID": "helper.arxiv.html#downloading-arxiv-files",
    "href": "helper.arxiv.html#downloading-arxiv-files",
    "title": "helper.arxiv",
    "section": "Downloading arxiv files",
    "text": "Downloading arxiv files\n\nsource\n\nextract_last_names\n\n extract_last_names (authors:list[str])\n\nThe extract_last_names function is a convenient helper function for naming downloaded arxiv files.\n\n# Example usage\nauthors = [\"John Smith\", \"Maria Garcia-Lopez\", \"Pieter de Jong\", \"Xin Li\"]\nlast_names = extract_last_names(authors)\ntest_eq(last_names, ['Smith', 'Garcia-Lopez', 'de Jong', 'Li'])\n\ntest_eq(extract_last_names([author.name for author in mock_result.authors]), ['Stanley', 'Windisch'])\n\n\nsource\n\n\ncreate_acronym\n\n create_acronym (title)\n\n\nsource\n\n\nfolder_name_for_source\n\n folder_name_for_source (result:arxiv.Result, lowercase:bool=True)\n\nfolder_name_for_source and create_acronym are convenient helper functions for naming folders newly created when downloading source code for arxiv files; the author of trouver roughly uses these conventions for organizing source code files.\n\n# Test cases\ntitles = [\n    \"Lectures on K3 surfaces\",\n    \"Positivity in Algebraic Geometry I\",\n    \"On the Cohomology of Finite Groups\",\n    \"An Introduction to A-infinity Algebras\",\n    \"Quantum Field Theory and the Standard Model\",\n    \"Category O for gl(n,C) and the Cohomology of Flag Varieties\"\n]\n\nfor title in titles:\n    print(f\"Title: {title}\")\n    print(f\"Acronym: {create_acronym(title)}\")\n    print()\n\nTitle: Lectures on K3 surfaces\nAcronym: lks\n\nTitle: Positivity in Algebraic Geometry I\nAcronym: pagI\n\nTitle: On the Cohomology of Finite Groups\nAcronym: cfg\n\nTitle: An Introduction to A-infinity Algebras\nAcronym: iAia\n\nTitle: Quantum Field Theory and the Standard Model\nAcronym: qftsm\n\nTitle: Category O for gl(n,C) and the Cohomology of Flag Varieties\nAcronym: cOgnCcfv\n\n\n\n\nmock_result = arxiv.Result(\n    entry_id='http://arxiv.org/abs/1605.08386v1',\n    updated=datetime.datetime(2016, 5, 26, 17, 59, 46, tzinfo=datetime.timezone.utc),\n    published=datetime.datetime(2016, 5, 26, 17, 59, 46, tzinfo=datetime.timezone.utc),\n    title='Heat-bath random walks with Markov bases',\n    authors=[arxiv.Result.Author('Caprice Stanley'), arxiv.Result.Author('Tobias Windisch')],\n    summary='Graphs on lattice points are studied whose edges come from a finite set of\\nallowed moves of arbitrary length. We show that the diameter of these graphs on\\nfibers of a fixed integer matrix can be bounded from above by a constant. We\\nthen study the mixing behaviour of heat-bath random walks on these graphs. We\\nalso state explicit conditions on the set of moves so that the heat-bath random\\nwalk, a generalization of the Glauber dynamics, is an expander in fixed\\ndimension.',\n    comment='20 pages, 3 figures',\n    journal_ref=None,\n    doi=None,\n    primary_category='math.CO',\n    categories=['math.CO', 'math.ST', 'stat.TH', 'Primary: 05C81, Secondary: 37A25, 11P21'],\n    links=[arxiv.Result.Link('http://arxiv.org/abs/1605.08386v1',\n                             title=None, rel='alternate', content_type=None),\n           arxiv.Result.Link('http://arxiv.org/pdf/1605.08386v1', title='pdf', rel='related',\n                             content_type=None),])\nextract_metadata(mock_result)\nprint(mock_result.title)\noutput = folder_name_for_source(mock_result)\nprint(output)\nassert ' ' not in output\nassert output.startswith('stanley_windisch')\n\nHeat-bath random walks with Markov bases\nstanley_windisch_hbrwmb\n\n\n\nsource\n\n\nfile_name_for_pdf\n\n file_name_for_pdf (result:arxiv.Result)\n\nfile_name_for_pdf could be a good convention for naming downloaded pdf files of arxiv articles. Pass this as the file_or_folder_names parameter for download_from_results.\n\nmock_result = arxiv.Result(\n    entry_id='http://arxiv.org/abs/1605.08386v1',\n    updated=datetime.datetime(2016, 5, 26, 17, 59, 46, tzinfo=datetime.timezone.utc),\n    published=datetime.datetime(2016, 5, 26, 17, 59, 46, tzinfo=datetime.timezone.utc),\n    title='Heat-bath random walks with Markov bases',\n    authors=[arxiv.Result.Author('Caprice Stanley'), arxiv.Result.Author('Tobias Windisch')],\n    summary='Graphs on lattice points are studied whose edges come from a finite set of\\nallowed moves of arbitrary length. We show that the diameter of these graphs on\\nfibers of a fixed integer matrix can be bounded from above by a constant. We\\nthen study the mixing behaviour of heat-bath random walks on these graphs. We\\nalso state explicit conditions on the set of moves so that the heat-bath random\\nwalk, a generalization of the Glauber dynamics, is an expander in fixed\\ndimension.',\n    comment='20 pages, 3 figures',\n    journal_ref=None,\n    doi=None,\n    primary_category='math.CO',\n    categories=['math.CO', 'math.ST', 'stat.TH', 'Primary: 05C81, Secondary: 37A25, 11P21'],\n    links=[arxiv.Result.Link('http://arxiv.org/abs/1605.08386v1',\n                             title=None, rel='alternate', content_type=None),\n           arxiv.Result.Link('http://arxiv.org/pdf/1605.08386v1', title='pdf', rel='related',\n                             content_type=None),])\nfile_name_for_pdf(mock_result)\n\n'Stanley, Windisch - Heat-bath random walks with Markov bases'\n\n\n\nsource\n\n\nextract_tex_from_gz\n\n extract_tex_from_gz (filepath)\n\n\nsource\n\n\nget_tex_filename_from_gz\n\n get_tex_filename_from_gz (filepath)\n\n\nsource\n\n\nread_gz_file\n\n read_gz_file (filepath)\n\n\nsource\n\n\nanalyze_arxiv_tarfile\n\n analyze_arxiv_tarfile (filepath:os.PathLike)\n\n*Analyzes the contents of an arXiv download file, which can be either a tar.gz archive or a plain .gz file.\nThis function attempts to determine the structure of the file downloaded from arXiv. It can identify several different types of content structures commonly found in arXiv downloads.\nParameters: filepath (Union[str, Path]): The path to the file to be analyzed. Can be a string or a Path object.\nReturns: Literal[“nested_archive”, “direct_tex”, “unknown_tar_structure”, “plain_gz”, “invalid_file”]: - “nested_archive”: If the tar.gz contains another compressed file - “direct_tex”: If the tar.gz contains .tex files directly - “unknown_tar_structure”: If the tar.gz structure doesn’t match known patterns - “plain_gz”: If the file is a plain .gz file (not a tar.gz) - “invalid_file”: If the file is neither a valid tar.gz nor a valid .gz file\nRaises: No exceptions are raised; all errors are handled internally and returned as “invalid_file”. Determine what kind of contents the*\n\n\n\n\nType\nDetails\n\n\n\n\nfilepath\nPathLike\nThe path to the tar file.\n\n\nReturns\nLiteral\n\n\n\n\n\n# Usage\n# file = _test_directory() / 'arxiv_file_download_example_folder' / 'math_0512085v2.Finding_large_Selmer_rank_via_an_arithmetic_theory_of_local_constants.tar.gz'\n# result = analyze_arxiv_tarfile(file)\n# print(f\"The tar.gz file contains: {result}\")\n\n# # Usage\n# # content = read_gz_file(file)\n# # print(content[:100])  # Print the first 100 characters\n\n# filename = get_tex_filename_from_gz(file)\n# if filename:\n#     print(f\"The .tex file inside the .gz archive is: {filename}\")\n# else:\n#     print(\"No .tex file found in the archive.\")\n\n# extracted_file = extract_tex_from_gz(file)\n# print(f\"Extracted .tex file: {extracted_file}\")\n\nThe tar.gz file contains: plain_gz\nNo .tex file found in the archive.\nExtracted .tex file: math_0512085v2.Finding_large_Selmer_rank_via_an_arithmetic_theory_of_local_constants.tar.tex\n\n\n\nsource\n\n\ndownload_from_results\n\n download_from_results (results:arxiv.Result|list[arxiv.Result],\n                        dir:os.PathLike, source:bool=True,\n                        decompress_compressed_file:bool=True, file_or_fold\n                        er_names:Union[NoneType,str,list[str],Callable[[ar\n                        xiv.Result],str]]=&lt;function\n                        folder_name_for_source&gt;,\n                        delete_compressed_file:bool=True,\n                        download_metadata:bool=True, verbose:bool=False)\n\n*Download either the source files or pdfs of the arxiv article encoded in the results.\n\nIf source = True and decompress_compressed_file = True, then\n\nDownload the source file/folder into a newly created folder (whose name is specified by file_or_folder_names) within dir and decompress the source (if applicable) in this newly created folder.\nIf delete_compressed_file = True, then delete the compressed file.\n\nIf source = False, then just download a pdf.\n\nFor file_or_folder_names, the recommanded Callable arguments are folder_name_for_source for downloading source files and file_name_for_pdf for downloading pdf files.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nresults\narxiv.Result | list[arxiv.Result]\n\n\n\n\ndir\nPathLike\n\nThe directory into which to download the files\n\n\nsource\nbool\nTrue\nIf True, download the source file. Otherweise, download a pdf file.\n\n\ndecompress_compressed_file\nbool\nTrue\nIf Trueand if source is True, then decompress the source file after downloading it.\n\n\nfile_or_folder_names\nUnion\nfolder_name_for_source\nIf None, then the file/folder is named the arxiv id. If a str (in which case results must be a single Result or a list[Result] of length 1) or list[str] (whose length must equal that of results), then each file/folder is named by the specified corresponding str. If Callable[Result, str], then each file/folder is named using the specified Callable\n\n\ndelete_compressed_file\nbool\nTrue\nIf True and if source and decompress_compressed_file are True, then delete the compressed source file after downloading and then uncompressing it.\n\n\ndownload_metadata\nbool\nTrue\nIf True, and if source is True, then create a file called metadata.json and put it into the newly created folder, unless a file called metadata.json already exists, in which case, a unique file name is created\n\n\nverbose\nbool\nFalse\n\n\n\nReturns\nlist\n\nEach Path is the folder in which the source files are newly downloaded or the path to the pdf file that is newly downloaded.\n\n\n\ndownload_from_results downloads an arxiv article (the source or a pdf).\n\nmock_result_1 = arxiv.Result(\n    entry_id='http://arxiv.org/abs/1605.08386v1',\n    updated=datetime.datetime(2016, 5, 26, 17, 59, 46, tzinfo=datetime.timezone.utc),\n    published=datetime.datetime(2016, 5, 26, 17, 59, 46, tzinfo=datetime.timezone.utc),\n    title='Heat-bath random walks with Markov bases',\n    authors=[arxiv.Result.Author('Caprice Stanley'), arxiv.Result.Author('Tobias Windisch')],\n    summary='Graphs on lattice points are studied whose edges come from a finite set of\\nallowed moves of arbitrary length. We show that the diameter of these graphs on\\nfibers of a fixed integer matrix can be bounded from above by a constant. We\\nthen study the mixing behaviour of heat-bath random walks on these graphs. We\\nalso state explicit conditions on the set of moves so that the heat-bath random\\nwalk, a generalization of the Glauber dynamics, is an expander in fixed\\ndimension.',\n    comment='20 pages, 3 figures',\n    journal_ref=None,\n    doi=None,\n    primary_category='math.CO',\n    categories=['math.CO', 'math.ST', 'stat.TH', 'Primary: 05C81, Secondary: 37A25, 11P21'],\n    links=[arxiv.Result.Link('http://arxiv.org/abs/1605.08386v1',\n                            title=None, rel='alternate', content_type=None),\n        arxiv.Result.Link('http://arxiv.org/pdf/1605.08386v1', title='pdf', rel='related',\n                            content_type=None),])\nmock_result_2 = arxiv.Result(\n    entry_id='http://arxiv.org/abs/2106.10586v4',\n    updated=datetime.datetime(2024, 6, 28, 1, 36, 47, tzinfo=datetime.timezone.utc),\n    published=datetime.datetime(2021, 6, 19, 23, 50, 56, tzinfo=datetime.timezone.utc),\n    title='Global $\\\\mathbb{A}^1$ degrees of covering maps between modular curves',\n    authors=[arxiv.Result.Author('Hyun Jong Kim'), arxiv.Result.Author('Sun Woo Park')],\n    summary=\"Given a projective smooth curve $X$ over any field $k$, we discuss two\\nnotions of global $\\\\mathbb{A}^1$ degree of a finite morphism of smooth curves\\n$f: X \\\\to \\\\mathbb{P}^1_k$ satisfying certain conditions. One originates from\\ncomputing the Euler number of the pullback of the line bundle\\n$\\\\mathscr{O}_{\\\\mathbb{P}^1}(1)$ as a generalization of Kass and Wickelgren's\\nconstruction of Euler numbers. The other originates from the construction of\\nglobal $\\\\mathbb{A}^1$ degree of morphisms of projective curves by Kass, Levine,\\nSolomon, and Wickelgren as a generalization of Morel's construction of\\n$\\\\mathbb{A}^1$-Brouwer degree of a morphism $f: \\\\mathbb{P}^1_k \\\\to\\n\\\\mathbb{P}^1_k$. We prove that under certain conditions on $N$, both notions of\\nglobal $\\\\mathbb{A}^1$ degrees of covering maps between modular curves $X_0(N)\\n\\\\to X(1)$, $X_1(N) \\\\to X(1)$, and $X(N) \\\\to X(1)$ agree to be equal to sums of\\nhyperbolic elements $\\\\langle 1 \\\\rangle + \\\\langle -1 \\\\rangle$ in the\\nGrothendieck-Witt ring $\\\\mathrm{GW}(k)$ for any field $k$ whose characteristic\\nis coprime to $N$ and the pullback of $\\\\mathscr{O}_{\\\\mathbb{P}^1}(1)$ is\\nrelatively oriented.\",\n    comment='35 pages. Modified various statements to more precisely speak of\\n  \"relatively oriented\" maps or vector bundles instead of \"relatively\\n  orientable\" maps or vector bundles where appropriate --- the former phrasing\\n  suggests that a relative orientation is fixed. Additional minor edits',\n    journal_ref=None,\n    doi=None,\n    primary_category='math.AG',\n    categories=['math.AG', 'math.NT', '14F42, 14G35'],\n    links=[arxiv.Result.Link('http://arxiv.org/abs/2106.10586v4', title=None, rel='alternate', content_type=None), arxiv.Result.Link('http://arxiv.org/pdf/2106.10586v4', title='pdf', rel='related', content_type=None)])\n\n\nmock_result_3 = arxiv.Result(\n    entry_id='http://arxiv.org/abs/math/0512085v2',\n    updated=datetime.datetime(2006, 9, 2, 22, 10, 49, tzinfo=datetime.timezone.utc),\n    published=datetime.datetime(2005, 12, 5, 16, 13, 53, tzinfo=datetime.timezone.utc),\n    title='Finding large Selmer rank via an arithmetic theory of local constants',\n    authors=[arxiv.Result.Author('Barry Mazur'), arxiv.Result.Author('Karl Rubin')],\n    summary='We obtain lower bounds for Selmer ranks of elliptic curves over dihedral\\nextensions of number fields.\\n  Suppose $K/k$ is a quadratic extension of number fields, $E$ is an elliptic\\ncurve defined over $k$, and $p$ is an odd prime. Let $F$ denote the maximal\\nabelian $p$-extension of $K$ that is unramified at all primes where $E$ has bad\\nreduction and that is Galois over $k$ with dihedral Galois group (i.e., the\\ngenerator $c$ of $Gal(K/k)$ acts on $Gal(F/K)$ by -1). We prove (under mild\\nhypotheses on $p$) that if the rank of the pro-$p$ Selmer group $S_p(E/K)$ is\\nodd, then the rank of $S_p(E/L)$ is at least $[L:K]$ for every finite extension\\n$L$ of $K$ in $F$.',\n    comment='Revised and improved. To appear in Annals of Mathematics',\n    journal_ref=None,\n    doi=None,\n    primary_category='math.NT',\n    categories=['math.NT', '11G05, 11R20 (Primary) 11G10, 11R23, 14G05 (Secondary)'],\n    links=[arxiv.Result.Link('http://arxiv.org/abs/math/0512085v2', title=None, rel='alternate', content_type=None), arxiv.Result.Link('http://arxiv.org/pdf/math/0512085v2', title='pdf', rel='related', content_type=None)])\n\n\nsingle_result = mock_result_1\nmultiple_results = [mock_result_1, mock_result_2] \nfolder_name_1 = folder_name_for_source(mock_result_1)\nfolder_name_2 = folder_name_for_source(mock_result_2)\n\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'arxiv_file_download_example_folder'\n    shutil.copytree(_test_directory() / 'arxiv_file_download_example_folder', temp_vault)\n    # 1. Single Result vs. List of Results\n    # Test with single Result\n    downloaded_paths = download_from_results(mock_result_1, temp_vault, source=True)\n    assert (temp_vault / folder_name_1).exists()\n    assert downloaded_paths\n\n    # os.startfile(temp_vault)\n    download_from_results(mock_result_3, temp_vault, source=True)\n    # input()\n\nWe can also pass multiple results to download_from_results.\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'arxiv_file_download_example_folder'\n    shutil.copytree(_test_directory() / 'arxiv_file_download_example_folder', temp_vault)\n    # Test with multiple Results\n    download_from_results(multiple_results, temp_vault, source=True)\n    # os.startfile(temp_vault)\n    # input()\n    assert (temp_vault / folder_name_1).exists()\n    assert (temp_vault / folder_name_2).exists()\n\nSpecifying source=False downloads the pdf instead of the source files.\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'arxiv_file_download_example_folder'\n    shutil.copytree(_test_directory() / 'arxiv_file_download_example_folder', temp_vault)\n    # 2. Source vs. PDF download\n    download_from_results(single_result, temp_vault, source=False)\n    assert (temp_vault / f'{folder_name_1}.pdf').exists()\n\nBy specifying source=True and decompress_compressed_file=False, we can just download the compressed file.\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'arxiv_file_download_example_folder'\n    shutil.copytree(_test_directory() / 'arxiv_file_download_example_folder', temp_vault)\n    # 3. Decompression options\n    download_from_results(single_result, temp_vault, source=True, decompress_compressed_file=False)\n    tar_gz_files = glob.glob(str(temp_vault / folder_name_1 / '*.tar.gz')) \n    assert len(tar_gz_files) &gt; 0\n\nThe folder or pdf file can get a custon name\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'arxiv_file_download_example_folder'\n    shutil.copytree(_test_directory() / 'arxiv_file_download_example_folder', temp_vault)\n    # 4. File/folder naming\n    download_from_results(single_result, temp_vault, file_or_folder_names='custom_name')\n    assert (temp_vault / 'custom_name').exists()\n\n    download_from_results(multiple_results, temp_vault, file_or_folder_names=['name1', 'name2'])\n    assert (temp_vault / 'name1').exists()\n    assert (temp_vault / 'name2').exists()\n\ndelete_compresed_file can be set to False to preserve the compressed file after decomppressing.\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'arxiv_file_download_example_folder'\n    shutil.copytree(_test_directory() / 'arxiv_file_download_example_folder', temp_vault)\n    # 5. Compressed file handling\n    download_from_results(single_result, temp_vault, delete_compressed_file=False)\n    tar_gz_files = glob.glob(str(temp_vault / folder_name_1 / '*.tar.gz')) \n    gz_files = glob.glob(str(temp_vault / folder_name_1 / '*.gz')) \n    # os.startfile(temp_vault)\n    # input()\n    assert len(tar_gz_files) &gt; 0 or len(gz_files) &gt; 0\n\nBy default, if the source is downloaded into a folder, then the metadata of the arxiv article is stored in a json file.\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'arxiv_file_download_example_folder'\n    shutil.copytree(_test_directory() / 'arxiv_file_download_example_folder', temp_vault)\n\n    # 6. Metadata file\n    download_from_results(single_result, temp_vault, download_metadata=True)\n    assert (temp_vault / folder_name_1 / 'metadata.json').exists()\n\n    # 7. Edge cases\n    download_from_results([], temp_vault)  # Empty list\n    # Test with non-existent arxiv ID (should handle gracefully)\n    # non_existent = next(arxiv.Search(id_list=['0000.00000']).results())\n    # download_from_results(non_existent, temp_vault)\n\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'arxiv_file_download_example_folder'\n    shutil.copytree(_test_directory() / 'arxiv_file_download_example_folder', temp_vault)\n    # 8. Folder creation (duplicate handling)\n    download_from_results(single_result, temp_vault)\n    download_from_results(single_result, temp_vault)  # Should create a duplicate folder\n    assert (temp_vault / folder_name_1).exists()\n\n    # 9. File types (if you have examples of different source types)\n    # This would require specific known arxiv IDs with different source types\n\n    # 10. Error handling\n    with ExceptionExpected(Exception):\n    # with pytest.raises(Exception):  # Replace with specific exception\n        download_from_results(single_result, '/non/existent/path')",
    "crumbs": [
      "helper.arxiv"
    ]
  },
  {
    "objectID": "markdown.markdown.heading.html",
    "href": "markdown.markdown.heading.html",
    "title": "markdown.markdown.heading",
    "section": "",
    "text": "from fastcore.test import *\n\n\nsource\n\nheading_level\n\n heading_level (heading_str:str)\n\nReturn the level of the heading string.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nheading_str\nstr\nA str representing a markdown heading. Starts with 1 to 6 sharps '#'.\n\n\nReturns\nint\nBetween 1 and 6, inclusive.\n\n\n\n\ntest_eq(heading_level('## Title'), 2)\n\n\nsource\n\n\nheading_title\n\n heading_title (heading_str:str)\n\nReturn the heading title, without the starting sharps.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nheading_str\nstr\nA str representing a markdown heading. Starts with 1 to 6 sharps '#'.\n\n\nReturns\nstr\n\n\n\n\n\ntest_eq(heading_title('# Separable isogeny '), 'Separable isogeny')\ntest_eq(heading_title('#  Test title#'),  'Test title#')",
    "crumbs": [
      "markdown.markdown.heading"
    ]
  },
  {
    "objectID": "how_to.install_trouver.html",
    "href": "how_to.install_trouver.html",
    "title": "how_to.install_trouver",
    "section": "",
    "text": "Install Python. Note that trouver is currently (as of 12/24/2023) mostly tested on Python version 3.10.6.\nGo to a command-line (e.g. cmd on Windows, Terminal on Linux, etc.) and run\npython -m pip install trouver\nor\npip install trouver",
    "crumbs": [
      "how_to.install_trouver"
    ]
  },
  {
    "objectID": "how_to.install_trouver.html#basic-installation",
    "href": "how_to.install_trouver.html#basic-installation",
    "title": "how_to.install_trouver",
    "section": "",
    "text": "Install Python. Note that trouver is currently (as of 12/24/2023) mostly tested on Python version 3.10.6.\nGo to a command-line (e.g. cmd on Windows, Terminal on Linux, etc.) and run\npython -m pip install trouver\nor\npip install trouver",
    "crumbs": [
      "how_to.install_trouver"
    ]
  },
  {
    "objectID": "how_to.install_trouver.html#recommended-additional-installations",
    "href": "how_to.install_trouver.html#recommended-additional-installations",
    "title": "how_to.install_trouver",
    "section": "Recommended additional installations",
    "text": "Recommended additional installations\n\nWe recommend installing Obsidian.md to view, edit, and modify mathematical notes created by or which interact with trouver.\nWe recommend installing Jupyter to use notebooks to use the code from trouver. More specifically, we recommend installing JupyterLab via\npip install jupyterlab\nand opening JupyterLab via\njupyter-lab\nor installing the classic Jupyter Notebook via\npip install notebook\nand opening the notebook via\njupyter notebook\nAlternatively, we also recommend using notebooks via Visual Studio Code.",
    "crumbs": [
      "how_to.install_trouver"
    ]
  },
  {
    "objectID": "how_to.install_trouver.html#for-developersinstall-from-source",
    "href": "how_to.install_trouver.html#for-developersinstall-from-source",
    "title": "how_to.install_trouver",
    "section": "For Developers/Install from source",
    "text": "For Developers/Install from source\nTo use or develop the source code or documentation of trouver,\n\nclone the trouver GitHub repository. See GitHub’s instructions on cloning a repository for instance.\ntrouver is developed using nbdev. As such, nbdev Python library is required to effectively develop the source code and documentation of trouver. Install nbdev with\npip install nbdev\nTo install trouver from source, go to the cloned trouver folder in a terminal, and run\npip install -e '.[dev]'\nSee the nbdev tutorial page for more details on using nbdev.",
    "crumbs": [
      "how_to.install_trouver"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "trouver",
    "section": "",
    "text": "Author’s academic website\nGitHub repository\nDocumentation website\npypi page\nSurvey\nMathematicians constantly need to learn and read about concepts with which they are unfamiliar. Keeping mathematical notes in an Obsidian.md vault can help with this learning process as Obsidian.md makes it easy to edit notes, link notes to one another, organize notes, read notes, and access notes.\nThis library currently includes functionalities (see also the below) to\nAs some of these functionalities use machine learning models, they ultimately cannot run perfectly. Nevertheless, some of these models, particularly those described in 2 and 3, perform well enough that these functionalities are quite useful as tools to help reading mathematical papers (when used in conjunction with Obsidian.md).\nMoreover, the results of the machine learning models are recorded in the notes/.md files. One can very well correct these recorded results by manually editing the affected .md files with any file editor.\nAs of Version 1.0.1, trouver has a graphical user interface wrapping some (but not all) of its functionalities.",
    "crumbs": [
      "trouver"
    ]
  },
  {
    "objectID": "index.html#disclaimer",
    "href": "index.html#disclaimer",
    "title": "trouver",
    "section": "Disclaimer",
    "text": "Disclaimer\nAt the time of this writing (12/23/2024), there is only one author/contributor of this library. Nevertheless, the author often refers to himself as the author, the authors, or the author/authors in writing this library. Moreover, the author often uses the editorial we in writing this library.\nUse this library at your own risk as using this library can write or modify files in your computer and as the documentation of components of this library may be inaccurate, outdated, or not-well-maintained. Moreover, future components of this library may use external API’s (including but possibly not limited to OpenAI’s API) that may not be free to use. By using this library, you agree that the author/authors of this library is/are not responsible for any damages or losses, including but not limited to data or monetary losses, from this library and related components.\nThis library is still somewhere in-between prototype and alpha. Moreover, the library itself may be unstable and subject to abrupt changes.\nThe author/authors of this library is/are also not affiliated with Obsidian.md, fast.ai, Hugging Face, and arXiv.",
    "crumbs": [
      "trouver"
    ]
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "trouver",
    "section": "Install",
    "text": "Install\nSee also how_to.install_trouver\nWe recommend having at least 5GB of free disk space to install trouver and related components (mostly the ML models).\npip install trouver\nYou may also have to manually install other libraries which are required by the fast.ai and/or Hugging Face libraries.\nWe recommend installing Obsidian.md to view, edit, and modify mathematical notes created by or which interact with trouver.\nSee how_to.install_trouver for more details on installation.\n\nWarning At the time of this writing, trouver has not been tested on MacOS extensively. We have also found that running the latest Python versions in Jupyter notebooks on modern MacOS machines (e.g. those using the M1 processor and in particular the arm64 architecture) lead to some issues. cf. stackexchange discussions such as\n\nhttps://apple.stackexchange.com/questions/436801/m1-mac-mach-o-file-but-is-an-incompatible-architecture-have-x86-64-need-a\nhttps://stackoverflow.com/questions/71502583/jupiter-wont-launch-from-terminal-on-m1-macbook.",
    "crumbs": [
      "trouver"
    ]
  },
  {
    "objectID": "index.html#descriptions-of-functionalities",
    "href": "index.html#descriptions-of-functionalities",
    "title": "trouver",
    "section": "Descriptions of functionalities",
    "text": "Descriptions of functionalities\nWe describe some of trouver’s ML functionalities. Sample code is available in tutorial.walkthrough. See below for some rationale for these functionalities.\nThe predictions in the examples below are just for illustration; actual predictions by the ML models may differ — what constitutes as “ideal predictions” is ultimately subjective and users’ opinions on how the ML models should actually predict will vary. All of the ML models are hosted on the page for the user hyunjongkimmath on huggingface.\nTODO: mention the functions for each of the functionalities\n\n1. Predict types of excerpts of mathematical text.\nThe model hyunjongkimmath/information_note_type predicts what type a given excerpt of text is (using Markdown tags). See markdown.obsidian.personal.machine_learning.information_note_types for more details.\nFor example, the model should predict that the following excerpt is a #_meta/definition and a #_meta/notation.\n\nLet \\((X, d)\\) be a metric space and \\(x \\in X\\).\nDefinition 1.3.1: The open ball centered at \\(x\\) with radius \\(r &gt; 0\\) is defined as:\n\\[B(x, r) = \\{y \\in X : d(x, y) &lt; r\\}\\]\nDefinition 1.3.2: The closed ball centered at \\(x\\) with radius \\(r \\geq 0\\) is defined as:\n\\[\\overline{B}(x, r) = \\{y \\in X : d(x, y) \\leq r\\}\\]\n\nFor another example, the model should predict that the following excerpt is a #_meta/concept and a #_meta/proof.\n\nTheorem 3.2.1: Let \\(A\\) be an \\(n \\times n\\) matrix. If \\(A\\) is invertible, then its columns are linearly independent.\nProof: Let \\(c_1, c_2, ..., c_n\\) be the columns of \\(A\\). Suppose\n\\[a_1c_1 + a_2c_2 + ... + a_nc_n = 0\\]\nfor some scalars \\(a_1, a_2, ..., a_n\\). This is equivalent to\n\\[A\\mathbf{x} = \\mathbf{0}\\]\nwhere \\(\\mathbf{x} = (a_1, a_2, ..., a_n)^T\\). Since \\(A\\) is invertible,\n\\[\\mathbf{x} = A^{-1}\\mathbf{0} = \\mathbf{0}\\]\nThus, \\(a_1 = a_2 = ... = a_n = 0\\), proving that the columns are linearly independent.\n\nFor yet another example, the model should predict that the following excerpt is a #_meta/narrative.\n\nIn this section, we explore the fundamental concepts of eigenvalues and eigenvectors. These powerful tools allow us to:\n\nUnderstand the action of a linear transformation on specific vectors\nDiagonalize matrices, simplifying many computations\nAnalyze dynamical systems and their long-term behavior\n\nWe begin by defining eigenvalues and eigenvectors, then proceed to develop methods for finding them. The characteristic equation will play a crucial role in our analysis. Finally, we’ll examine some applications, including the diagonalization of matrices and solving systems of differential equations.\n\nThe following are some tags that the model is adept at predicting:\n\n#_meta/definition labels a note that introduces a definition.\n#_meta/notation labels a note that introduces a notation.\n#_meta/concept labels a note that contains a general concept, e.g. by virtue of stating a theorem/proposiiton/lemma/corollary.\n#_meta/proof labels a note that contains a proof.\n#_meta/narrative labels a note that contains narrative - explainations of the material that is presented. Narratives most usually occur at the start/end of a chapter/section of a book/text/paper and in-between definitions/theorems/etc.\n#_meta/exercise labels a note that contains an exercise problem.\n#_meta/remark labels a note that contains a remark.\n#_meta/example labels a note that contains an example.\n#_meta/context labels a note that contains “contextual information”, i.e. information that other notes might depend on (e.g. “in this section, \\(k\\) is an algebraically closed field”, “For the rest of this section, we assume that \\(X\\) is a pointed topological space”).\n\n\n\n2. Mark definitions and notations introduced in an excerpt of mathematical text.\nThe model hyunjongkimmath/def_and_notat_token_classification_model attempts to find where exactly definitions and notations are introduced in a given excerpt of text. See markdown.obsidian.personal.machine_learning.tokenize.def_and_notat_token_classification\nFor example, take the following excerpt.\n\nLet \\((X, d)\\) be a metric space and \\(x \\in X\\).\nDefinition 1.3.1: The open ball centered at \\(x\\) with radius \\(r &gt; 0\\) is defined as:\n\\[B(x, r) = \\{y \\in X : d(x, y) &lt; r\\}\\]\nWe denote this open ball as \\(B(x, r)\\).\nDefinition 1.3.2: The closed ball centered at \\(x\\) with radius \\(r \\geq 0\\) is defined as:\n\\[\\overline{B}(x, r) = \\{y \\in X : d(x, y) \\leq r\\}\\]\nWe use the notation \\(\\overline{B}(x, r)\\) for closed balls.\n\nThe model should predict (and functions in the module markdown.obsidian.personal.machine_learning.tokenize.def_and_notat_token_classification should mark) the following definitions and notations as introduced in the text:\n\nLet \\((X, d)\\) be a metric space and \\(x \\in X\\).\nDefinition 1.3.1: The open ball centered at \\(x\\) with radius \\(r &gt; 0\\) is defined as:\n\n\\[B(x, r) = \\{y \\in X : d(x, y) &lt; r\\}.\\]\n\nDefinition 1.3.2: The closed ball centered at \\(x\\) with radius \\(r \\geq 0\\) is defined as:\n\n\\[\\overline{B}(x, r) = \\{y \\in X : d(x, y) \\leq r\\}.\\]\n\n\n\n\n3. Name definitions and notations introduced in an excerpt of mathematical text.\nThe models hyunjongkimmath/definition_naming_model and hyunjongkimmath/notation_naming_model attempt to “name” definitions and notations (marked either manually or with the hyunjongkimmath/def_and_notat_token_classification_model discussed above).\nIn the example above, the hyunjongkimmath/definition_naming_model model ideally would name the definition encapsulated by the marked phrases\n\nopen ball centered at \\(x\\) with radius \\(r &gt; 0\\) and\nclosed ball centered at \\(x\\) with radius \\(r \\geq 0\\)\n\nas (something along the lines of)\n\n“Open ball centered at a point of a metric space with radius \\(r\\)” and\n“Closed ball centered at a point of a metric space with radius \\(r\\)”\n\nrespectively.\nMoreover, the hyunjongkimmath/notation_naming_model ideally would name the notation encapsulated by the marked LaTeX math mode texts\n\n\\[B(x, r) = \\{y \\in X : d(x, y) &lt; r\\}\\]\n\\[\\overline{B}(x, r) = \\{y \\in X : d(x, y) \\leq r\\}\\]\n\nas\n\n\\(B(x, r)\\) and\n\\(\\overline{B}(x, r)\\)\n\nrespectively — the aim of the notation-naming process is to only extract the actual notation itself, not other parts of the LaTeX math mode texts that are not part of the notation.\nThere may sometimes be more than one “good” way to name a definition/notation and a given marked phrase may actually encapsulate more than one definition/notation. In the above example, one might argue that the marked phrases\n\nopen ball centered at \\(x\\) with radius \\(r &gt; 0\\) and\nclosed ball centered at \\(x\\) with radius \\(r \\geq 0\\)\n\nencapsulate not only the notions of “open ball” and “closed ball” (centered at a point and with radius \\(r\\)), but also the notions of “the center of an open/closed ball” or “the radius of an open/closed ball”.\n\n\n4. Summarize what a notation denotes as introduced in an excerpt of mathematical text.\nThe model hyunjongkimmath/notation_summarizations_model attempts to summarize what a notation introduced in a excerpt (marked either manually or with the hyunjongkimmath/def_and_notat_token_classification_model discussed above and named with the hyunjongkimmath/notation_naming_model discussed above) is supposed to denote.\nIn the above examples, the marked (and named) notations of \\(B(x,r)\\) and \\(\\overline{B}(x,r)\\) may be ideally summarized as follows:\n\n\\(B(x,r)\\) denotes the open ball centered at \\(x\\) with radius \\(r\\) where \\(x\\) is a point of a metric space \\(X\\) and \\(r &gt; 0\\). It is defined as \\[B(x, r) = \\{y \\in X : d(x, y) &lt; r\\}\\]\n\n\n\\(\\overline{B}(x,r)\\) denotes the closed ball centered at \\(x\\) with radius \\(r\\) where \\(x\\) is a point of a metric space \\(X\\) and \\(r &gt; 0\\). It is defined as \\[\\overline{B}(x, r) = \\{y \\in X : d(x, y) \\leq r\\}\\]\n\nIdeally, such a generated notation should contain the following information (as available):\n\nThe name/intuitive description of the notion denoted by the notation (in the above examples, “open ball” and “closed ball”).\nThe way the notion is defined/constructed (in the above examples, \\(B(x, r) = \\{y \\in X : d(x, y) &lt; r\\}\\), etc.)\nOther helpful information about the notation as introduced in the text.",
    "crumbs": [
      "trouver"
    ]
  },
  {
    "objectID": "index.html#rationale-for-the-functionalities-and-intended-use",
    "href": "index.html#rationale-for-the-functionalities-and-intended-use",
    "title": "trouver",
    "section": "Rationale for the functionalities and intended use",
    "text": "Rationale for the functionalities and intended use\nThe sheer amount and interconnectedness of definitions and notations that one has to understand (or at least be aware of) make it difficult to learn mathemamatics, especially at the graduate or research levels (and beyond). The above functionalities aim to make learning mathematics more tractable by making it easier to locate (and remind oneself of) definitions and notations introduced in mathematical text.\n\nDifficulties in reading mathematical papers\nFor example, take the following (very much fake) mathematical theorem from Hyun Jong Kim’s talk at the AMS Student Chapter Seminar1 at the University of Wisconsin-Madison during the Spring 2024 semester:\n\nTheorem.\nGiven a smooth, flavorful, gastroidal toroid \\(\\mathscr{T}_\\mathscr{G}\\) of rank \\(n\\), we have a natural isomorphism \\[H_{\\text{suc}}^i(\\mathscr{T}_\\mathscr{G}) \\cong H_{\\text{Betti}} ( |\\mathscr{T}_\\mathscr{G}|(\\mathbb{C}), \\mathbb{Q}(\\mathscr{T}_\\mathscr{G}))^{3n-i}.\\]\n\nEven in this short (fake) theorem, a first time reader may not understand a multitude of defintions/notations:\n\nGastroidal toroid\nSmooth gastroidal toroid\nflavorful gastroidal toroid\nrank of a gastroidal toroid\n\\(H_{\\text{suc}}^i\\)\n\\(|\\mathscr{T}_\\mathscr{G}|\\)\n\\(|\\mathscr{T}_\\mathscr{G}|(\\mathbb{C})\\)\n\\(\\mathbb{Q}(\\mathscr{T}_\\mathscr{G})\\).\n\nHypothetically, say that the reader finds some definitions/notations (which may very well take several minutes):\n\nA gastroidal toroid is a toroid constructed as a fried dough and equipped with a sucrose structure. The space \\(|\\mathscr{T}_\\mathscr{G}|\\) of a gastroidal toroid \\(\\mathscr{T}_\\mathscr{G}\\) is the underlying topological space structure of the friend dough. We say that a gastroidal toroid is flavorful is \\(\\lim_{n \\to \\infty} \\operatorname{swt}_n(\\mathscr{T}_\\mathscr{G}) \\geq 1\\)\n\nHowever, this excerpt requires the reader to understand more definitions and notations:\n\na fried dough\na sucrose structure\n\\(\\operatorname{swt}_n\\)\n\nIn practice, as one sets out to learn about numerous definitions and notations, say in a given mathematical paper, one can often forget details and thus need to spend much time to re-find such definitions and notations.\n\n\nA workaround using Obsidian.md\nThe functionalities of trouver, used in conjunction with Obsidian.md, can help work around these difficulties to reduce the amount of time and effort needed to re-find and re-learn these definitions and notations. trouver can divide a LaTeX document into not-too-long notes (see the divide_latex_text function in latex.divide and the setup_reference_from_latex_parts function in latex.convert) for an Obsidian.md vault.\nSome of Obsidian.md strengths include the ease with which links/embeddings between notes can be made and the ease with which notes can be searched and opened. In essence, one can use the aforementioned functionalities to automatically identify definitions and notations introduced throughout the mathematical text, create new notes dedicated to each notation (see the make_notation_notes_from_HTML_tags function in markdown.obsidian.personal.notation), and write summaries of what the notations denote.\nThese notation notes can then be linked/embedded into other notes as needed, thereby making it much easier to view what a notation denotes.\nTODO: include example image",
    "crumbs": [
      "trouver"
    ]
  },
  {
    "objectID": "index.html#gui",
    "href": "index.html#gui",
    "title": "trouver",
    "section": "GUI",
    "text": "GUI\ntrouver now has a prototype GUI for some of the aforementioned funcionalities.\nTODO: include link to GUI download",
    "crumbs": [
      "trouver"
    ]
  },
  {
    "objectID": "index.html#miscellaneous",
    "href": "index.html#miscellaneous",
    "title": "trouver",
    "section": "Miscellaneous",
    "text": "Miscellaneous\nThis repository is still in its preliminary stages and much of the code and documentation may be faulty or not well formatted. The author greatly appreciates reports of these issues, notifications of typos, and suggestions on edits; please feel free to report them on the Issues section of the GitHub repository for this library. The author of this repository, who is primarily a mathematician (a postdoctoral associate at the time of this writing), does not guarantee quick responses or resolutions to such issues, but will do his best to address them.",
    "crumbs": [
      "trouver"
    ]
  },
  {
    "objectID": "index.html#troubleshooting",
    "href": "index.html#troubleshooting",
    "title": "trouver",
    "section": "Troubleshooting",
    "text": "Troubleshooting\n\nIn the nbs/_tests folder, make sure that the folders that you want to test are not empty; since git does not track empty folders, empty folders will not be pushed in GitHub and the tests in GitHub Actions may yield different results than in a local computer.",
    "crumbs": [
      "trouver"
    ]
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "trouver",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nColloquially referred to as the “Donut seminar”, as the organizers purchase donuts with the funds provided by the AMS for the speakers and the audience to eat. The fake theorem/definition below are jokes about donuts.↩︎\ncf. nbdev’s End-To-End Walkthrough to see how to use nbdev_test↩︎\nThere are also tests which are hidden from the documentation website; one can find these tests in the jupyter notebook files in the nbs folder in the repository for this library as notebook cells marked with the #| hide flag, cf. nbdev’s End-to-End Walkthrough to see what the #| hide flag does.↩︎\nThe .github/workflows/test.yaml GitHub workflow file is set up in such a way that that allows GitHub Actions to access/use the contents of the nbs/_tests directory upon running the tests/examples.↩︎\nThe .github/workflows/test.yaml GitHub workflow file is set up in such a way that that allows GitHub Actions to access/use the contents of the nbs/_tests directory upon running the tests/examples.↩︎",
    "crumbs": [
      "trouver"
    ]
  },
  {
    "objectID": "markdown.obsidian.machine_learning.notation_linking.html",
    "href": "markdown.obsidian.machine_learning.notation_linking.html",
    "title": "markdown.obsidian.personal.machine_learning.notation_linking",
    "section": "",
    "text": "In a trouver-styled Obsidian.md vault, notation notes summarize the definitions of various notations introduced in excerpts of mathematical text. They are also written to quickly indicate where each notation is introduced.\nStating the definition of a notation often depends on other notations, usually defined before the notation itself. In practice, a notation note lists links to other notation notes that it depends on. Some of the links are made within the “content” of the notation note. Some others are made in a bulleted list of links.\nThe following is an example of an notation note:\nTODO: insert example\nThis module contains functions to train and use models to predict whether one notation note depends on another.",
    "crumbs": [
      "markdown.obsidian.personal.machine_learning.notation_linking"
    ]
  },
  {
    "objectID": "markdown.obsidian.machine_learning.notation_linking.html#gather-ml-data-from-notation-notes",
    "href": "markdown.obsidian.machine_learning.notation_linking.html#gather-ml-data-from-notation-notes",
    "title": "markdown.obsidian.personal.machine_learning.notation_linking",
    "section": "Gather ML data from notation notes",
    "text": "Gather ML data from notation notes\nGathering data is done for each “reference folder”, which is a group of notes belonging to a single mathematical text. Each data point consists of 1. An ordered pair of notation notes, 2. Some miscellaneous, but precisely quantifiable information about the relationship between the notation notes, and 3. Whether or not the first notation note depends on the second (True/False).\nEach data point should be processed in such a way that training/predictions are\nWhen gathering such data, False data points are only partially gathered — this is to prevent bias against True data points, which are relatively rare.\n\nsource\n\ndata_from_notation_notes\n\n data_from_notation_notes\n                           (origin_notation_note:trouver.markdown.obsidian\n                           .vault.VaultNote, relied_notation_note:trouver.\n                           markdown.obsidian.vault.VaultNote,\n                           include_origin_content:bool,\n                           include_relied_content:bool,\n                           origin_parsed:Optional[tuple]=None,\n                           relied_parsed:Optional[tuple]=None,\n                           reference_name:Optional[str]=None,\n                           main_of_origin_content:Optional[str]=None,\n                           main_of_relied_content:Optional[str]=None, info\n                           rmation_notes_of_reference:Optional[list[trouve\n                           r.markdown.obsidian.vault.VaultNote]]=None)\n\n*Obtain data for a single pair of notation notes.\nAssumes that\n\norigin_notation_note and relied_notation_note have the same vault attribute.\norigin_parsed and relied_parsed are respectively the outputs of parse_notation_note applied to reference_name if specified.\nreference_name is the correct output of reference_of_information_note applied to main_of_origin and that this output is the same as that when applied to main_of_relied.\nmain_of_origin_content and main_of_relied_content are the outputs of process_standard_information_note(MarkdownFile.from_vault_note(main_of_origin)) and process_standard_information_note(MarkdownFile.from_vault_note(main_of_relied)) respectively if they are specified.\ninformation_notes_of_reference correctly lists the standard information notes from the reference in the vault of name reference_name.\n\nReturns - tuple[str, str, str, str, str, str, str, str, str, str, str, str, str, bool] - Consists of the following: 1. The name of the reference from which the notation notes and main information notes come from, 2. The name of origin_notation_note, 3. The name of relied_notation_note, 4. The name of the main information note of origin_notation_note, 5. The name of the main information note of relied_notation_note, 6. The (processed) content of main_of_origin_content, 7. The (processed) content of main_of_relied_content, 8. The content of origin_notation_note 9. The content of relied_notation_note 10. The first entry in the latex_in_original field in the YAML frontmatter metadata or, if unavailable, the notation that is summarized in origin_notation_note 11. The first entry in the latex_in_original field in the YAML frontmatter metadata or, if unavailable, the notation that is summarized in relied_notation_note 12. The notation that is summarized in origin_notation_note 13. The notation that is summarized in relied_notation_note 14. True if origin_notation_note links to relied_notation_note. False otherwises*\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\norigin_notation_note\nVaultNote\n\nThe notation note which potentially uses the notation introduced by relied_notation_note. In particular, there potentially ought to be a link to relied_notation_note in origin_notation_note.| | relied_notation_note | VaultNote |  | See the description fororigin_notation_note.,\n\n\ninclude_origin_content\nbool\n\nIf True, include the content of origin_notation_note, i.e. a summary of what the notation introduced by this note means.\n\n\ninclude_relied_content\nbool\n\nIf True, include the content of relied_notation_note, i.e. a summary of what the notation introduced by this note means.\n\n\norigin_parsed\nOptional\nNone\nThe output of parse_notation_note applied to origin_notation_note\n\n\nrelied_parsed\nOptional\nNone\nThe output of parse_notation_note applied to relied_notation_note\n\n\nreference_name\nOptional\nNone\nThe name of the reference folder in the vault from which the two notation notes comes from. If None, this is computed “on-the-fly” based on the reference of the main note of main_of_origin, see reference_of_information_note\n\n\nmain_of_origin_content\nOptional\nNone\nThe content of main_of_origin, i.e. the output of process_standard_information_note(MarkdownFile.from_vault_note(main_of_origin)). If None, this is computed “one-the-fly”.\n\n\nmain_of_relied_content\nOptional\nNone\nThe content of main_of_relied, i.e. the output of process_standard_information_note(MarkdownFile.from_vault_note(main_of_relied)). If None, this is computed “one-the-fly”.\n\n\ninformation_notes_of_reference\nOptional\nNone\nThe standard information notes for the reference folder in order (as arranged in the index notes of the reference folder)\n\n\nReturns\ntuple\n\n\n\n\n\n\nsource\n\n\ndata_points_for_reference\n\n data_points_for_reference\n                            (reference_index_note:trouver.markdown.obsidia\n                            n.vault.VaultNote,\n                            return_notation_note_parsings:bool=False)\n\n*Compile data points for notation note linking based on the information notes and notation notes in a reference folder.\n“Positive” linking data points are relatively rare in comparison to “Negative” data points, so “Negative” data points are randomly sampled (although the random samples will redundantly include “Positive” data as well).\nNote that it makes sense to draw data exclusively within each “reference” — notations tend to have dependencies within the same mathematical text.\nReturns - Union[list[tuple], tuple[list[tuple], dict[str, tuple]]] - Either 1. a list of tuples — in this case, each tuple is a “data point” and is an output of data_from_notation_notes — or 2. the list of tuples along with a dict whose keys are the names of the notation notes and whose values are the outputs of parse_notation_note applied to these notation notes.*\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nreference_index_note\nVaultNote\n\nThe index note for the reference from which to draw the data.\n\n\nreturn_notation_note_parsings\nbool\nFalse\nIf True, return the outputs of parse_notation_note applied to the notation notes in the reference folder\n\n\nReturns\nUnion\n\n\n\n\n\n\nsource\n\n\ntext_from_data_point\n\n text_from_data_point (data_point:tuple)\n\nFormat a data point to present it as a str.\n\n\n\n\nType\nDetails\n\n\n\n\ndata_point\ntuple\nAn output of data_from_notation_notes.\n\n\nReturns\nstr",
    "crumbs": [
      "markdown.obsidian.personal.machine_learning.notation_linking"
    ]
  },
  {
    "objectID": "markdown.obsidian.machine_learning.notation_linking.html#use-the-trained-model",
    "href": "markdown.obsidian.machine_learning.notation_linking.html#use-the-trained-model",
    "title": "markdown.obsidian.personal.machine_learning.notation_linking",
    "section": "Use the trained model",
    "text": "Use the trained model\n\nsource\n\nprediction_by_model_via_datapoint\n\n prediction_by_model_via_datapoint (learn, data_point:tuple)\n\n\n\n\n\nType\nDetails\n\n\n\n\nlearn\n\nThe fastai textlearner which makes the prediction.\n\n\ndata_point\ntuple\nAn output of data_from_notation_notes\n\n\nReturns\nbool\n\n\n\n\n\nsource\n\n\nprediction_by_model\n\n prediction_by_model\n                      (origin_notation_note:trouver.markdown.obsidian.vaul\n                      t.VaultNote, relied_notation_note:trouver.markdown.o\n                      bsidian.vault.VaultNote, learn,\n                      include_origin_content:bool,\n                      include_relied_content:bool,\n                      origin_parsed:Optional[tuple]=None,\n                      relied_parsed:Optional[tuple]=None,\n                      reference_name:Optional[str]=None,\n                      main_of_origin_content:Optional[str]=None,\n                      main_of_relied_content:Optional[str]=None, informati\n                      on_notes_of_reference:Optional[list[trouver.markdown\n                      .obsidian.vault.VaultNote]]=None)\n\n*Predict whether a notation note depends on the notation summarized by another notation note.\nSee data_from_notation_notes for details on the parameters, except learn.\nSee also prediction_by_model_via_datapoint for an alternative function for predictions.*\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\norigin_notation_note\nVaultNote\n\n\n\n\nrelied_notation_note\nVaultNote\n\n\n\n\nlearn\n\n\nThe fastai textlearner which makes the prediction.\n\n\ninclude_origin_content\nbool\n\nIf True, include the content of origin_notation_note, i.e. a summary of what the notation introduced by this note means.\n\n\ninclude_relied_content\nbool\n\nIf True, include the content of relied_notation_note, i.e. a summary of what the notation introduced by this note means.\n\n\norigin_parsed\nOptional\nNone\nThe output of parse_notation_note applied to origin_notation_note\n\n\nrelied_parsed\nOptional\nNone\nThe output of parse_notation_note applied to relied_notation_note\n\n\nreference_name\nOptional\nNone\nThe name of the reference folder in the vault from which the two notation notes comes from. If None, this is computed “on-the-fly” based on the reference of the main note of main_of_origin, see reference_of_information_note\n\n\nmain_of_origin_content\nOptional\nNone\nThe content of main_of_origin, i.e. the output of process_standard_information_note(MarkdownFile.from_vault_note(main_of_origin)). If None, this is computed “one-the-fly”.\n\n\nmain_of_relied_content\nOptional\nNone\nThe content of main_of_relied, i.e. the output of process_standard_information_note(MarkdownFile.from_vault_note(main_of_relied)). If None, this is computed “one-the-fly”.\n\n\ninformation_notes_of_reference\nOptional\nNone\nThe standard information notes for the reference folder in order (as arranged in the index notes of the reference folder)\n\n\nReturns\nbool\n\nTrue if model predicts that origin_notat_note depends on the notation summarized by relied_notat_note and hence should link to relied_notat_note.\n\n\n\n\nsource\n\n\nauto_add_link_to_notation_note\n\n auto_add_link_to_notation_note\n                                 (origin_notation_note:trouver.markdown.ob\n                                 sidian.vault.VaultNote, relied_notation_n\n                                 ote:trouver.markdown.obsidian.vault.Vault\n                                 Note, learn, include_origin_content:bool,\n                                 include_relied_content:bool,\n                                 origin_parsed:Optional[tuple]=None,\n                                 relied_parsed:Optional[tuple]=None,\n                                 reference_name:Optional[str]=None, main_o\n                                 f_origin_content:Optional[str]=None, main\n                                 _of_relied_content:Optional[str]=None, in\n                                 formation_notes_of_reference:Optional[lis\n                                 t[trouver.markdown.obsidian.vault.VaultNo\n                                 te]]=None)\n\n*Predict whether origin_notation_note depends on the notation summarized by relied_notation_note and add a link in origin_notation_note to relied_notation_note if so.\nIt is recommended to pass precomputed arguments for the optional parameters. In particular, passing a precomputed argument to origin_parsed prevents the link to relied_notation_note from being redundantly added if such a link already exists.\nIf a link to relied_notation_note is added, then an #_auto/notation_notes_linked tag is added to origin_notation_note if such a tag is not already present.*\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\norigin_notation_note\nVaultNote\n\n\n\n\nrelied_notation_note\nVaultNote\n\n\n\n\nlearn\n\n\nThe fastai textlearner which makes the prediction.\n\n\ninclude_origin_content\nbool\n\nIf True, include the content of origin_notation_note, i.e. a summary of what the notation introduced by this note means.\n\n\ninclude_relied_content\nbool\n\nIf True, include the content of relied_notation_note, i.e. a summary of what the notation introduced by this note means.\n\n\norigin_parsed\nOptional\nNone\nThe output of parse_notation_note applied to origin_notation_note\n\n\nrelied_parsed\nOptional\nNone\nThe output of parse_notation_note applied to relied_notation_note\n\n\nreference_name\nOptional\nNone\nThe name of the reference folder in the vault from which the two notation notes comes from. If None, this is computed “on-the-fly” based on the reference of the main note of main_of_origin, see reference_of_information_note\n\n\nmain_of_origin_content\nOptional\nNone\nThe content of main_of_origin, i.e. the output of process_standard_information_note(MarkdownFile.from_vault_note(main_of_origin)). If None, this is computed “one-the-fly”.\n\n\nmain_of_relied_content\nOptional\nNone\nThe content of main_of_relied, i.e. the output of process_standard_information_note(MarkdownFile.from_vault_note(main_of_relied)). If None, this is computed “one-the-fly”.\n\n\ninformation_notes_of_reference\nOptional\nNone\nThe standard information notes for the reference folder in order (as arranged in the index notes of the reference folder)\n\n\nReturns\nNone\n\n\n\n\n\n\nsource\n\n\nauto_add_link_to_notation_note_via_data_point\n\n auto_add_link_to_notation_note_via_data_point (learn, vault:os.PathLike,\n                                                data_point:tuple, origin_p\n                                                arsed:Optional[tuple]=None\n                                                , relied_parsed:Optional[t\n                                                uple]=None)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nlearn\n\n\nThe fastai textlearner which makes the prediction.\n\n\nvault\nPathLike\n\n\n\n\ndata_point\ntuple\n\nAn output of data_from_notation_notes\n\n\norigin_parsed\nOptional\nNone\nOptionally, the output of parse_notation_note applied to the origin_notation_note.\n\n\nrelied_parsed\nOptional\nNone\nOptionally, the output of parse_notation_note applied to the relied_notation_note.\n\n\nReturns\nNone",
    "crumbs": [
      "markdown.obsidian.personal.machine_learning.notation_linking"
    ]
  },
  {
    "objectID": "markdown.obsidian.footnotes.html",
    "href": "markdown.obsidian.footnotes.html",
    "title": "markdown.obsidian.footnotes",
    "section": "",
    "text": "from fastcore.test import *\nWe use the following example:\n# TODO The footnote below spans multiple lines  Find out if this affects any raw-text extraction.\n# r'''[^3]: Here is an embedded image,  \n# ![[Pasted image 20221009114121.png]]\n# This is still part of the footnote.\n#\n# This is not part of the footnote'''",
    "crumbs": [
      "markdown.obsidian.footnotes"
    ]
  },
  {
    "objectID": "markdown.obsidian.footnotes.html#finding-footnote-descriptions",
    "href": "markdown.obsidian.footnotes.html#finding-footnote-descriptions",
    "title": "markdown.obsidian.footnotes",
    "section": "Finding footnote descriptions",
    "text": "Finding footnote descriptions\nThings like\n\n[^1]: Hello, this is a footnote being described\n\n\nsource\n\nfind_footnote_descriptions_in_markdown_text\n\n find_footnote_descriptions_in_markdown_text (text:str)\n\n*Return ranges in the markdown text string where footnote descriptions occur.\nBy footnote descriptions, I mean some of the form [^label]: some description of the footnote.\nReturns\n\nlist[tuple]\n\nEach tuple is of the form (a,b) where text[a:b] is the full substring of a markdown footnote description.*\n\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ntext\nstr\n\n\n\nReturns\nlist\nEach tuple is of the form (a,b) where text[a:b] is the full substring of a markdown footnote description.\n\n\n\nExamples\n\ntext_1 = r\"\"\"\nThis is some text with a footnote[^1]. In Obsidian.md, there will be a `[^1]` showing up and it will be clickable.\n\n[^1]: And this is the text of the footnote. In the reading view of Obsidian.md, this will show in the bottom. This is also where the clickable `[^1]` sends us to.\n[^2]: I'm another footnote. Note that I'm written above where I am first used and that does not create any problems.\n\nThis is another text[^2] and the footnote here is written above this text instead of below.\n\n[^3]: I'm yet another footnote, but I'm not used. This will not create any problems, but this footnote will not appear in the reading view of Obsidian.md.\n\"\"\"\nranges = find_footnote_descriptions_in_markdown_text(text_1)\nfor match_range in ranges:\n    print(text_1[match_range[0]:match_range[1]])\ntest_eq(len(ranges), 3)\n\n[^1]: And this is the text of the footnote. In the reading view of Obsidian.md, this will show in the bottom. This is also where the clickable `[^1]` sends us to.\n[^2]: I'm another footnote. Note that I'm written above where I am first used and that does not create any problems.\n[^3]: I'm yet another footnote, but I'm not used. This will not create any problems, but this footnote will not appear in the reading view of Obsidian.md.",
    "crumbs": [
      "markdown.obsidian.footnotes"
    ]
  },
  {
    "objectID": "markdown.obsidian.footnotes.html#find-and-remove-footnote-mentions",
    "href": "markdown.obsidian.footnotes.html#find-and-remove-footnote-mentions",
    "title": "markdown.obsidian.footnotes",
    "section": "Find and remove footnote mentions",
    "text": "Find and remove footnote mentions\nThings like\n\nThere is going to be a footnote mention at the end here. 1\n\n\nsource\n\nfind_footnote_mentions_in_markdown_text\n\n find_footnote_mentions_in_markdown_text (text:str)\n\n*Return ranges in the markdown text string where footnote mentions occur.\nBy footnote mentions, I mean some of the form [^label] without any descriptions.\nReturns\n\nlist[tuple]\n\nEach tuple is of the form (a,b) where text[a:b] is a markdown footnote description.*\n\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ntext\nstr\n\n\n\nReturns\nlist\nEach tuple is of the form (a,b) where text[a:b] is a markdown footnote description.\n\n\n\nExamples\n\ntext_2 = \"\"\"\nNow behold these footnotes[^2][^1]!\n\n[^2]: Hi. I am footnote 2. I am written before footnote 1. In Obsidian.md's reading view, I will show up as with label `1` because I am the first footnote used.\n[^1]: I am footnote 1. I am written after footnote 2. In Obsidian.md's reading view, I will show up as with label `2` because I am the second footnote used. Also note that I am used twice.\n\nHere is a footnote[^not_a_number].\n\n[^not_a_number]: I am a footnote, but I do not have a number label. In Obsidian.md's reading view, I will show up with label `3` because I am the third footnote used.\n\nI am going to reuse footnote 1[^1], which will show with label `2`.\n\n\"\"\"\nranges = find_footnote_mentions_in_markdown_text(text_2)\n\nfootnote_mentions = [text_2[match_range[0]:match_range[1]] for match_range in ranges]\nfor mention in footnote_mentions:\n    print(mention)\ntest_eq(footnote_mentions, ['[^2]', '[^1]', '[^not_a_number]', '[^1]'])\n\n[^2]\n[^1]\n[^not_a_number]\n[^1]\n\n\n\nsource\n\n\nremove_footnote_mentions_in_markdown_text\n\n remove_footnote_mentions_in_markdown_text (text:str)\n\nRemove all footnote mentions from text.\n\ntext_3 = r\"\"\"\nThis is a text. See that there are two footnotes used here[^1][^2]?. The `remove_footnote_mentions_in_markdown_text` function\nwill remove these.\n\n[^1]: Hi. I am a footnote. Unlike the footnote mentions, I am not going anywhere.\n[^2]: Hi. I am another footnote. I am also not going anywhere.\n\n[^3]: Hi. I am yet another footnote. I am unused and I am also not going anywhere.\n\n\"\"\"\nfootnote_mentions_removed = remove_footnote_mentions_in_markdown_text(text_3)\n\ntest_eq([], find_footnote_mentions_in_markdown_text(footnote_mentions_removed))\nprint(footnote_mentions_removed)\n\n\nThis is a text. See that there are two footnotes used here?. The `remove_footnote_mentions_in_markdown_text` function\nwill remove these.\n\n[^1]: Hi. I am a footnote. Unlike the footnote mentions, I am not going anywhere.\n[^2]: Hi. I am another footnote. I am also not going anywhere.\n\n[^3]: Hi. I am yet another footnote. I am unused and I am also not going anywhere.",
    "crumbs": [
      "markdown.obsidian.footnotes"
    ]
  },
  {
    "objectID": "markdown.obsidian.footnotes.html#identifying-footnote",
    "href": "markdown.obsidian.footnotes.html#identifying-footnote",
    "title": "markdown.obsidian.footnotes",
    "section": "Identifying footnote",
    "text": "Identifying footnote\n\nsource\n\nembedded_note_of_footnote\n\n embedded_note_of_footnote (footnote:str)\n\nReturn the name of the note that the footnote description embeds assuming that the footnote only embeds a note.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nfootnote\nstr\nThe full footnote description. May start and end with '\\n' and other whitespace characters\n\n\nReturns\nOptional\nThe name of the note of the footnote, if applicable. None otherwise.\n\n\n\n\ntest_eq('note', embedded_note_of_footnote('[^1]:![[note#Hi]]'))\ntest_eq(None, embedded_note_of_footnote('[^1]: Hello'))\ntest_eq(None, embedded_note_of_footnote('[^1]:![[note#Hi]] but I have other stuff too'))\n\n\nsource\n\n\nfootnote_is_simple_embedded_note\n\n footnote_is_simple_embedded_note (footnote:str)\n\nReturn True if the footnote description is that of a simple embedded note.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nfootnote\nstr\nThe full footnote description. May start and end with '\\n' and other whitespace characters.\n\n\nReturns\nbool\n\n\n\n\n\nassert footnote_is_simple_embedded_note('[^1]:![[note#Hi]]')\nassert not footnote_is_simple_embedded_note('[^1]: Hello')\nassert not footnote_is_simple_embedded_note('[^1]:![[note#Hi]] but I have other stuff too')",
    "crumbs": [
      "markdown.obsidian.footnotes"
    ]
  },
  {
    "objectID": "markdown.obsidian.footnotes.html#footnotes",
    "href": "markdown.obsidian.footnotes.html#footnotes",
    "title": "markdown.obsidian.footnotes",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThis is the footnote!↩︎",
    "crumbs": [
      "markdown.obsidian.footnotes"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.machine_learning.notation_summarization.html",
    "href": "markdown.obsidian.personal.machine_learning.notation_summarization.html",
    "title": "markdown.obsidian.personal.machine_learning.notation_summarization",
    "section": "",
    "text": "In markdown.obsidian.personal.machine_learning.notation_identification, we defined functions to gather ML data to identify notations and functions to use an ML model to predict where notations are defined. In how_to.train_ml_model.fastai, we showed how to train this ML model from the data. markdown.obsidian.personal.notation also has some functions to create and interact with notation notes.\nIt would be further convenient to train an ML model to summarize details about notations. This module defines functions to gather data to train such a model.\n\nimport shutil\nimport tempfile\nfrom unittest import mock\n\nfrom fastcore.test import *\n# from torch import Tensor\n\nfrom trouver.helper.tests import _test_directory\n\n\nGather ML data from notation notes\n\nsource\n\nget_latex_in_original_from_parsed_notation_note_data\n\n get_latex_in_original_from_parsed_notation_note_data (metadata:dict[str],\n                                                       notation_str:str)\n\n*Return the string that should be considered the latex_in_original given part of the output of parse_notation_note\nlatex_in_original is intended to either be 1. a substring of the main note in which the notation is introduced, if available, or 2. the notation itself.\nIf the notation note has a latex_in_original field in its YAML frontmatter metadata, then the (first) str there is the latex_in_original.*\n\n# The metadata is empty, so the `notation_str` should be considered the `latex_in_original`.\ntest_eq(\n    get_latex_in_original_from_parsed_notation_note_data({}, r'\\mathbb{A}^n_k'),\n    r'\\mathbb{A}^n_k')\n\ntest_metadata_1 = {\n    'detect_regex': [],\n    'latex_in_original': [\n        r\"c_x: \\\\mathbb{P}_k^n/(\\\\mathbb{P}_k^{n-1}) \\\\to \\\\mathbb{P}_k^n/(\\\\mathbb{P}_k^{n} - \\\\{x\\\\}) \\\\cong \\\\mathbb{P}_k^n/(\\\\mathbb{P}_k^{n-1})\"\n        ]}\ntest_notation_str_1 = r'c_x'\ntest_eq(\n    get_latex_in_original_from_parsed_notation_note_data(test_metadata_1, test_notation_str_1),\n    test_metadata_1['latex_in_original'][0])\n\n\nsource\n\n\nnotation_summarization_data_from_note\n\n notation_summarization_data_from_note\n                                        (notation_note:trouver.markdown.ob\n                                        sidian.vault.VaultNote,\n                                        vault:os.PathLike, check_for_actua\n                                        l_summarization:bool=True)\n\n*Obtain notation summzarization data from the notation note.\nNone is returned instead of a `dict if\n\nthe notation is determined to have not been (fully) summarized,\n\nCurrently, this is implemented as follows: a notation note is not fully summarized if it does not have any content beyond &lt;notation&gt; denotes or if the notation note has #_meta/TODO marked in its content (except in the trailing bulleted list of notations used in the notation note)\n\nthe main note of the notation not does not exist or is essentially empty\n\nEssentially empty means that the process_standard_information_note function applied to the a MarkdownFile object of the main note yields a MarkdownFile object whose __str__ method returns a string of only blank characters.\n\nthe notation note is marked with an _auto/notation_summary tag in its YAML frontmatter meta.\n\nIf a notation note is marked with an _auto/notation_summary tag, then that means that its summary has been auto-generated by an ML model using the append_summary_to_notation_note function\n\n\nThe notion of whether the notation “has been summarized” is not exactly implemented, but should be sufficient for gathering data.\nThis function is mainly used in gather_notation_note_summaries.\nTODO: there are some notation notes drawing information from multiple notes; separate text in notation notes corresponding to each note.\nReturns\n\nUnion[dict[str, str], None]\n\nIf check_for_actual_summarization is False or the notation note is determined to have been summarized (i.e. contains text beyond &lt;notation&gt; denotes and does not have the #_meta/TODO tag) then the output is a dict whose key-value pairs are\n\n\"Notation note name\" - The name of the notation note\n\"Notation\" - The notation of the note\n\"Latex in original\"' - The entry of thelatex_in_originalfield of the note if available, cf.make_a_notation_note`\n\"Summary\" - The summary of the notation.\n\"Main note name\" - The name of the main note of the notation note\n\"Processed main note contents\" - The processed contents of the main note\n\nOtherwise, the output is `None.*\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nnotation_note\nVaultNote\n\n\n\n\nvault\nPathLike\n\n\n\n\ncheck_for_actual_summarization\nbool\nTrue\nIf True, then return None if notation_note is determined to not have a summary or if the summary is autogenerated.\n\n\nReturns\nOptional\n\nThe keys to the dict are “Notation note name”, “Notation”, “Latex in oiriginal”, “Summary”, and “Main note name”. However, None is returned instead of a dict if the notation note is determined to have not been summarized, if the main note of the notation note does not exist, or the notation note is marked with the _auto/notation_summary tag.\n\n\n\n\nvault = _test_directory() / 'test_vault_7'\n\nnotation_note = VaultNote(vault, name='some_reference_name_notation_Spec_A') \nsample_output = notation_summarization_data_from_note(notation_note, vault)\n\ndel sample_output['Processed main note contents']\n\ntest_eq(sample_output,\n    {'Notation note name': 'some_reference_name_notation_Spec_A',\n     'Notation': '$\\\\operatorname{Spec} A$',\n     'Latex in original': '\\\\operatorname{Spec} A',\n     'Summary': 'the spectrum of the ring $A$.',\n     'Main note name': 'spectrum_of_a_ring',\n     # 'Processed main note contents': 'Let $A$ be a ring.\\n\\nThe Spectrum $\\\\operatorname{Spec} A$ is the set of prime ideals of $A$. It is equipped with a topology, called the Zariski topology in which the followings sets, called the distinguished open subsets of $\\\\operatorname{Spec} A$, give a base for the topology:\\n\\n$$D(f) = \\\\{\\\\mathfrak{p} \\\\in \\\\operatorname{Spec} A: f \\\\not\\\\in \\\\mathfrak{p} \\\\}.$$\\n'}\n    })\n\nc:\\Users\\hyunj\\Documents\\Development\\Python\\trouver_py310_venv\\lib\\site-packages\\bs4\\__init__.py:435: MarkupResemblesLocatorWarning: The input looks more like a filename than markup. You may want to open this file and pass the filehandle into Beautiful Soup.\n  warnings.warn(\n\n\nIf the “main” note of the notation note cannot be identified, then notation_summarization_data_from_note returns None:\n\nvault = _test_directory() / 'test_vault_7'\nnotation_note = VaultNote(vault, name='some_reference_name_notation_O_X_this_file_has_no_links') \nprint(\"The following note has no main note link:\\n\")\nprint(notation_note.text())\ntest_eq(notation_summarization_data_from_note(notation_note, vault), None)\n\n\nnotation_note = VaultNote(vault, name='notation_note_with_main_note_link_but_main_note_does_not_exist') \nprint(\"\\n\\nThe following note has a main note link, but the main note does not actually exist:\\n\")\nprint(notation_note.text())\ntest_eq(notation_summarization_data_from_note(notation_note, vault), None)\n\nThe following note has no main note link:\n\n---\ndetect_regex: []\nlatex_in_original: [\"\\\\mathscr{O}_X\"]\n---\n$\\mathscr{O}_X$ denotes the structure sheaf of the scheme $X$.\n\n\nThe following note has a main note link, but the main note does not actually exist:\n\n$k[[t]]$ [[nonexistent_note|denotes]] the ring of formal power series where $k$ is a field.\n\n\n\n# TODO: example with embedded links\n\n\n# TODO: example of a notation note without any metadata\n\nIf the notation note has not been summarized, then notation_summarization_data_from_note returns None, even if the main note of the notation note exists:\n\n# TODO: example where main of notation note exists, but has basically no content;\n# The function should return `None` in this case.\nvault = _test_directory() / 'test_vault_7'\nnotation_note = VaultNote(vault, name='some_reference_name_notation_B_R') \n\nprint(\n    \"This is what a notation note that has not been summarized basically looks like.\"\n    \" Note that it has YAML frontmatter metadata and starts a sentence to describe\"\n    \" what a certain notation is supposed to denote, but ultimately does not contain\"\n    \" an actual summary:\\n\")\nprint(notation_note.text())\n\ntest_eq(notation_summarization_data_from_note(notation_note, vault), None)\n\nThis is what a notation note that has not been summarized basically looks like. Note that it has YAML frontmatter metadata and starts a sentence to describe what a certain notation is supposed to denote, but ultimately does not contain an actual summary:\n\n---\ndetect_regex: []\nlatex_in_original: [\"\\\\mathcal{B}(\\\\mathbb{R})\"]\n---\n$\\mathcal{B}(\\mathbb{R})$ [[note_with_some_excessive_notation_notes|denotes]]\n\n\n\n# TODO: example where notation note has _auto/notation_summary tag; the notation summarization data should not be added.\n\n\nsource\n\n\ngather_notation_note_summaries\n\n gather_notation_note_summaries (vault:os.PathLike,\n                                 notes:list[trouver.markdown.obsidian.vaul\n                                 t.VaultNote])\n\n*Return a pandas.DataFrame encapsulating the data of notation note summaries.\ncf. notation_summarization_data_from_note, which is the function from which the notation note summaries are drawn.\nThis function is mainly used in append_to_notation_note_summarization_database.*\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nvault\nPathLike\n\n\n\nnotes\nlist\n\n\n\nReturns\nDataFrame\nHas columns Time added, Time modified, Notation note name, Notation, Latex in original, ‘Summary’, ‘Main note name’, and ‘Processed main note contents’.\n\n\n\n\n# TODO: example\n\n\n# TODO: example verifying that outputs of `None` from `notation_summarization_data_from_note`\n# are weeded out.\n\n\nsource\n\n\nappend_to_notation_note_summarization_database\n\n append_to_notation_note_summarization_database (vault:os.PathLike,\n                                                 file:os.PathLike, notes:l\n                                                 ist[trouver.markdown.obsi\n                                                 dian.vault.VaultNote],\n                                                 backup:bool=True)\n\n*Either create a csv file containing data for notation note summarization or append to an existing csv file.\nThe columns of the database file are as follows:\n\nTime added - The time when the row was added.\nTime modified - The time when the labels of the row\nNotation note name - The name of the note from which the data for the row was derived.\n‘Notation’ - The notation which is being summarized\n‘Latex in original’ - The entry of the latex_in_original field of the note if available, cf. make_a_notation_note\n\"Summary\" - The summary of the notation.\n\"Main note name\" - The name of the main note of the notation note\n\"Processed main note contents\" - The processed contents of the main note\n\nAll timestamps are in UTC time and specify time to minutes (i.e. no seconds/microseconds).\nTODO: implement updating rows and rewrite the next paragraph to accurately reflect the implementation. I would like the ‘Notation’, ‘Latex in original’, ‘Summary’, ‘processed main note contents’ to be the “pivot_cols”\nIf a “new” note has the same processed content as a pre-existing note and anything is different about the “new” note, then update the row of the existing note. In particular, the following are updated: - Time modified (set to current time) - Notation (overwritten) - Latex in original (overwritten) - Summary (overwritten) - Main note name (overwritten) - Processed main note contents (overwritten)\nThis method assumes that all the processed content in the CSV file are all distinct if the CSV file exists.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nvault\nPathLike\n\nThe vault freom which the data is drawn\n\n\nfile\nPathLike\n\nThe path to a CSV file\n\n\nnotes\nlist\n\nthe notation notes to consider adding to the database.\n\n\nbackup\nbool\nTrue\nIf True, makes a copy of file in the same directory and with the same name, except with an added extension of .bak.\n\n\nReturns\nNone\n\n\n\n\n\n\n# TODO basic example\n\n\n# TODO: example of appending instead of making an entirely new CSV file\n\n\n# TODO: example of notation notes existing, but none of them are to be added to the database by virtue of either the notation summary\n# not being written or by virtue of their main notes not existing.\n\n\n# TODO basic example\n\n\n# TODO: example of appending instead of making an entirely new CSV file\n\n\n# TODO: example of notation notes existing, but none of them are to be added to the database by virtue of either the notation summary\n# not being written or by virtue of their main notes not existing.\n\n\n\n\nFormat Data\nGiven the contents of the CSV file generated in append_to_notation_note_summarization_database, we create a single column representing the data upon which the ML model should train.\nSince a single piece of text can introduce multiple notations, we should indicate which the notation we want summarized. The entry in the Latex in original column of the CSV file can indicate this notation; as explained in make_a_notation_note, this entry is not necessarily the notation itself, but rather the substring of the text in which the notation is introduced. For example, in the text\nLet $R$ be a ring and let $M$ be a module. We define the dual of $M$ as \n\n$$M^\\vee := \\operatorname{Hom}_R(R,M).$$\nThe notation M^\\vee is introduced, and it is in the display math mode string.\n\nsource\n\nsingle_input_for_notation_summarization\n\n single_input_for_notation_summarization (main_note_content:str,\n                                          latex_in_original:str, latex_in_\n                                          original_comes_first:bool=True)\n\n*Format an input for a transformers.pipelines.text2text_generation.SummarizationPipeline object to summarize a notation introduced in a mathematical text.\nThe input consists of main_note_content as well as a part that is formatted as f\"latex_in_original: {latex_in_original}\".\nNote that this function is used to format data used to train/validate the summarization model within the SummarizationPipeline.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nmain_note_content\nstr\n\nThe mathematical text that introduces the notation and from which to summarize a notation.\n\n\nlatex_in_original\nstr\n\nA substring in main_note_content which is a latex string in which the notation is introduced.\n\n\nlatex_in_original_comes_first\nbool\nTrue\nIf True, the latex_in_original piece appears before the main_note_content\n\n\nReturns\nstr\n\n\n\n\n\nThe single_input_for_notation_summarization function formats an input for the notation summarization model to train on or to predict. Such an input consists of a mathematical excerpt and the latex_in_original field, which is a latex string containing a notation supposedly introduced in the mathematical excerpt.\n\ntest_content = \"This is a test content introducing notation: $\\mathbb{Z}/n\\mathbb{Z}$ denotes this. $\\mathbb{F}_q$ denotes that\"\nlatex_in_original = \"\\mathbb{Z}/n\\mathbb{Z}\"\n\n# In this example, `latex_in_orignal_comex_first` is set to `False`.\nsample_output = single_input_for_notation_summarization(\n    test_content,\n    latex_in_original,\n    latex_in_original_comes_first=False)\nassert '\\n\\nlatex_in_original: ' in sample_output\nprint(sample_output, '\\n')\n\nThis is a test content introducing notation: $\\mathbb{Z}/n\\mathbb{Z}$ denotes this. $\\mathbb{F}_q$ denotes that\n\nlatex_in_original: \\mathbb{Z}/n\\mathbb{Z} \n\n\n\nOriginally, this function was implemented in a way that places the latex_in_original at the end of the string (tantamount to letting latex_in_original_comes_first=False in the current implementation). Letting latex_in_original_comes_first=False places the latex_in_original field before the mathematical excerpt.\nThis change in implementation is an experimental attempt to improve the model; the author hypothesizes that placing the latex_in_original field before the mathematical excerpt will improve the model by allowing it to know what notation it is supposed to summarize before considering the mathematical excerpt.\n\n# In this example, `latex_in_orignal_comex_first` is set to `True`.\nsample_output = single_input_for_notation_summarization(\n    test_content,\n    latex_in_original,\n    latex_in_original_comes_first=True)\nassert sample_output.startswith('latex_in_original: ')\nprint(sample_output)\n\nlatex_in_original: \\mathbb{Z}/n\\mathbb{Z}\n\nThis is a test content introducing notation: $\\mathbb{Z}/n\\mathbb{Z}$ denotes this. $\\mathbb{F}_q$ denotes that\n\n\nIf latex_in_original is None, TODO: finish explanation\n\n# TODO: finish example\n\n\nsource\n\n\nappend_column_for_single_text\n\n append_column_for_single_text (df:pandas.core.frame.DataFrame,\n                                latex_in_original_comes_first:bool=True)\n\nAppend a column \"Single text\" to the notation note summarization DataFrame to represent the input into an ML model as a single text\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndf\nDataFrame\n\nAssumed to be structured just as a dataframe of a CSV file created/modified by append_to_notation_note_summarization_database`| | latex_in_original_comes_first | bool | True | This is a parameter to pass to calls to the [single_input_for_notation_summarization](https://hyunjongkimmath.github.io/trouver/markdown.obsidian.personal.machine_learning.notation_summarization.html#single_input_for_notation_summarization) function. IfTrue, thelatex_in_originalpiece appears before themain_note_content`\n\n\nReturns\nNone\n\n\n\n\n\n\ncsv_file = _test_directory() / 'ml_examples' / 'notation_summarizations.csv'\ndf = pd.read_csv(csv_file)\ndf.head()\n\n\n\n\n\n\n\n\nTime added\nTime modified\nNotation note name\nNotation\nLatex in original\nSummary\nMain note name\nProcessed main note contents\n\n\n\n\n0\n2023-01-17T01:47\n2023-01-17T01:47\nreference_name_notation_Gal_L_K\n$\\operatorname{Gal}(L/K)$\n$\\operatorname{ann} M$\nthe Galois group of the Galois field extension...\nreference_name_Galois_group\nIf $L/K$ is a Galois field extension, then its...\n\n\n1\n2023-01-17T01:47\n2023-01-17T01:47\nreference_name_notation_I_J\n$\\mathbb{Z}/n\\mathbb{Z}$\n$\\mathbb{Z}/n\\mathbb{Z}$\nThe ring of integers modulo $n$. It is defined...\nreference_name_Definition 1\nThe ring $\\mathbb{Z}/n\\mathbb{Z}$, called the ...\n\n\n2\n2023-01-17T01:47\n2023-01-17T01:47\nreference_name_notation_M_vee_dual_of_a_module\n$M^\\vee$\n$M^\\vee$\nthe dual of the $R$-module $M$. It is defined ...\nreference_name_Definition 17\nLet $M$ be an $R$-module. We define the dual m...\n\n\n3\n2023-01-17T01:47\n2023-01-17T01:47\nreference_name_notation_F_q\n$\\mathbb{F}_q$\n$\\mathbb{F}_q$\nthe finite field of $q$ elements, where $q$ is...\nreference_name_Theorem 1\nTheorem. Let $q$ be a prime power. There is a ...\n\n\n4\n2023-01-17T01:47\n2023-01-17T01:47\nreference_name_notation_X_N\n$X(N)$\n$X(N)$\nthe quotient of $\\mathbb{H}^*$ by $\\Gamma(N)$,...\nreference_name_Definition 200\nNow we discuss modular curves, whose points pa...\n\n\n\n\n\n\n\n\nappend_column_for_single_text(df)\ndf\n\n\n\n\n\n\n\n\nTime added\nTime modified\nNotation note name\nNotation\nLatex in original\nSummary\nMain note name\nProcessed main note contents\nSingle text\n\n\n\n\n0\n2023-01-17T01:47\n2023-01-17T01:47\nreference_name_notation_Gal_L_K\n$\\operatorname{Gal}(L/K)$\n$\\operatorname{ann} M$\nthe Galois group of the Galois field extension...\nreference_name_Galois_group\nIf $L/K$ is a Galois field extension, then its...\nlatex_in_original: $\\operatorname{ann} M$\\n\\nI...\n\n\n1\n2023-01-17T01:47\n2023-01-17T01:47\nreference_name_notation_I_J\n$\\mathbb{Z}/n\\mathbb{Z}$\n$\\mathbb{Z}/n\\mathbb{Z}$\nThe ring of integers modulo $n$. It is defined...\nreference_name_Definition 1\nThe ring $\\mathbb{Z}/n\\mathbb{Z}$, called the ...\nlatex_in_original: $\\mathbb{Z}/n\\mathbb{Z}$\\n\\...\n\n\n2\n2023-01-17T01:47\n2023-01-17T01:47\nreference_name_notation_M_vee_dual_of_a_module\n$M^\\vee$\n$M^\\vee$\nthe dual of the $R$-module $M$. It is defined ...\nreference_name_Definition 17\nLet $M$ be an $R$-module. We define the dual m...\nlatex_in_original: $M^\\vee$\\n\\nLet $M$ be an $...\n\n\n3\n2023-01-17T01:47\n2023-01-17T01:47\nreference_name_notation_F_q\n$\\mathbb{F}_q$\n$\\mathbb{F}_q$\nthe finite field of $q$ elements, where $q$ is...\nreference_name_Theorem 1\nTheorem. Let $q$ be a prime power. There is a ...\nlatex_in_original: $\\mathbb{F}_q$\\n\\nTheorem. ...\n\n\n4\n2023-01-17T01:47\n2023-01-17T01:47\nreference_name_notation_X_N\n$X(N)$\n$X(N)$\nthe quotient of $\\mathbb{H}^*$ by $\\Gamma(N)$,...\nreference_name_Definition 200\nNow we discuss modular curves, whose points pa...\nlatex_in_original: $X(N)$\\n\\nNow we discuss mo...\n\n\n\n\n\n\n\n\n\n\nUse ML model to fill in notation notes\nAfter training the model (cf. how_to.train_ml_model.huggingface), we use it to summarize notations.\n\nUsing a HuggingFace pipeline to summarize a notation\n\nsource\n\n\nsummarize_notation\n\n summarize_notation\n                     (main_content:Union[str,trouver.markdown.markdown.fil\n                     e.MarkdownFile], latex_in_original:str, summarizer:tr\n                     ansformers.pipelines.text2text_generation.Summarizati\n                     onPipeline, fix_formatting:bool=True,\n                     latex_in_original_comes_first:bool=True,\n                     correct_syntax_error:bool=True)\n\n*Summarize a notation introduced in a mathematical text using a huggingface pipeline.\nAssumes that main_content is a mathematical text introducing a notation and that latex_in_original is a substring of main_content in which a notation is introduced.\nBy setting correct_latex_syntax_error to True, this function consider each math mode text in the generated summary, and attempts to, if not syntactically correct, replace it with a math mode text closely resembling it within main_content. More specifically, each math mode text within main_content is considered, and substrings within those math mode texts are considered. The syntactically correct substring (Determined via math_mode_string_is_syntactically_valid) that also most closely resembles (determined via Levenshtein distance) the math mode text originally in the generated summary.*\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nmain_content\nUnion\n\n\n\n\nlatex_in_original\nstr\n\n\n\n\nsummarizer\nSummarizationPipeline\n\n\n\n\nfix_formatting\nbool\nTrue\nIf True, run fix_autogen_formatting on summarizer’s summary before retuning it.\n\n\nlatex_in_original_comes_first\nbool\nTrue\nThis is a parameter to pass to calls to the single_input_for_notation_summarization function. If True, the latex_in_original piece appears before the main_note_content\n\n\ncorrect_syntax_error\nbool\nTrue\nIf True, attempt to correct latex syntax error\n\n\nReturns\nstr\n\n\n\n\n\n\n# TODO: example\n\n\nAdding the summary to the notation note\n\nsource\n\n\n\nappend_summary_to_notation_note\n\n append_summary_to_notation_note\n                                  (notation_note:trouver.markdown.obsidian\n                                  .vault.VaultNote, vault:os.PathLike, sum\n                                  marizer:transformers.pipelines.text2text\n                                  _generation.SummarizationPipeline, main_\n                                  note:Optional[trouver.markdown.obsidian.\n                                  vault.VaultNote]=None, overwrite_previou\n                                  s_autogenerated_summary:bool=False,\n                                  latex_in_original_comes_first:bool=True)\n\n*Summarize a notation introduced in a mathematical text using a huggingface pipeline and append said summarization to notation_note.\nIf notation_note does not have a YAML frontmatter meta or does not have a latex_in_original field in its YAML frontmatter meta, then the actual notation is used as the latex_in_original.\nThe following describes the circumstances under which the summarization does not happen:\n\nIf main_note is None and no main note of notation_note can be determined via the main_of_notation function.\nIf overwrite_previous_autogenerated_summary is False and notation_note has the _auto/notation_summary tag in its YAML frontmatter meta (if available).\nIf notation_note does not have a YAML frontmatter meta or the _auto/notation_summary tag is not present in the YAML frontmatter meta and notation_note has nontrivial content (i.e. its content is not merely of the form $&lt;notation&gt;$ [[&lt;link_to_main_note|denotes]]).\n\nIf an auto-generated summary is appended, then this function adds an _auto/notation_summary tag to the notation note’s YAML frontmatter, if not already present. This tag is intended to be used as follows:\n\nThe presence of this tag tells the reader that the summary has been autogenerated by this function.\nThe notation_summarization_data_from_note function (and by extension, the gather_notation_note_summaries and append_to_notation_note_summarization_database functions) avoids gathering notation summarization data from notation notes marked with this tag\nThe owner of the Obsidian.md vault can manually make modifications to the notation note if necessary and remove this tag to indicate that the summary is appropriate to be added to the note summarization database.*\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nnotation_note\nVaultNote\n\n\n\n\nvault\nPathLike\n\n\n\n\nsummarizer\nSummarizationPipeline\n\nContains an ML model which summarizes the notation, see summarize_notation function.\n\n\nmain_note\nOptional\nNone\nThe main note from which the notation comes from. If this is None, then the main_note is obtained via the main_of_notation function.\n\n\noverwrite_previous_autogenerated_summary\nbool\nFalse\nIf True, overwrite previously autogenerated summaries\n\n\nlatex_in_original_comes_first\nbool\nTrue\nThis is a parameter to pass to calls to the single_input_for_notation_summarization function. If True, the latex_in_original piece appears before the main_note_content. While the default value of True is recommended, passing False to this parameter may be necessary to use the older version of the summarization model in the repo notation_summarizations_model.\n\n\nReturns\nNone\n\n\n\n\n\nThe next several examples demonstrate when a summary is written and when it is not.\n\nWhen the main note of the notation note cannot be identified, don’t write a summary\n\n\nwith (tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir,\n      mock.patch('__main__._get_summary') as mock_get_summary,\n      mock.patch('__main__._write_summary_to_notation_note') as mock_write_summary_to_notation_note):\n    temp_vault = Path(temp_dir) / 'test_vault_7'\n    shutil.copytree(_test_directory() / 'test_vault_7', temp_vault)\n    notation_note_without_a_main_note = VaultNote(temp_vault, name='some_reference_name_notation_O_X_this_file_has_no_links')\n\n    print(\"The following in the text of the notation note:\\n\")\n    print(notation_note_without_a_main_note.text())\n\n    append_summary_to_notation_note(notation_note_without_a_main_note, temp_vault, summarizer)\n\n    mock_get_summary.assert_not_called()\n    mock_write_summary_to_notation_note.assert_not_called()\n\nThe following in the text of the notation note:\n\n---\ndetect_regex: []\nlatex_in_original: [\"\\\\mathscr{O}_X\"]\n---\n$\\mathscr{O}_X$ denotes the structure sheaf of the scheme $X$.\n\n\n\nWhen notation_note has the _auto/notation_summary tag in its YAML frontmatter meta then\n\n\ndon’t write a summary if overwrite_previous_autogenerated_summary is False.\nwrite a summary otherwise.\n\n\n# Note that `overwrite_previous_autogenerated_summary` here is `False`.\nwith (tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir,\n      mock.patch('__main__._get_summary') as mock_get_summary,\n      mock.patch('__main__._write_summary_to_notation_note') as mock_write_summary_to_notation_note):\n    temp_vault = Path(temp_dir) / 'test_vault_7'\n    shutil.copytree(_test_directory() / 'test_vault_7', temp_vault)\n    notation_note_with_auto_notation_summary_tag = VaultNote(temp_vault, name='notation_note_with_auto_notation_summary_tag')\n\n    print(\"The following in the text of the notation note:\\n\")\n    print(notation_note_with_auto_notation_summary_tag.text())\n\n    append_summary_to_notation_note(notation_note_with_auto_notation_summary_tag, temp_vault, summarizer, overwrite_previous_autogenerated_summary=False)\n\n    mock_get_summary.assert_not_called()\n    mock_write_summary_to_notation_note.assert_not_called()\n\nThe following in the text of the notation note:\n\n---\ndetect_regex: []\nlatex_in_original: [\"\\\\operatorname{MT}(A)\"]\ntags: [_auto/notation_summary]\n---\n$\\operatorname{MT}(A)$ [[main_note_of_notation_note_with_auto_notation_summary_tag|denotes]] the Mumford-Tate group of the abelian variety $A$.\n\n\n\n# Note that `overwrite_previous_autogenerated_summary` here is `True`.\nwith (tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir,\n      mock.patch('__main__._get_summary') as mock_get_summary,\n      # mock.patch('__main__._write_summary_to_notation_note') as mock_write_summary_to_notation_note\n      ):\n    temp_vault = Path(temp_dir) / 'test_vault_7'\n    shutil.copytree(_test_directory() / 'test_vault_7', temp_vault)\n    notation_note_with_auto_notation_summary_tag = VaultNote(temp_vault, name='notation_note_with_auto_notation_summary_tag')\n\n    print(\"The following is the original text of the notation note:\\n\")\n    print(notation_note_with_auto_notation_summary_tag.text())\n\n    mock_get_summary.return_value = \"(this is a mock summary) the Mumford Tate group of the abelian variety $A$ with CM. It is defined as the image of the reflex norm map of $A$.\"\n    append_summary_to_notation_note(notation_note_with_auto_notation_summary_tag, temp_vault, summarizer, overwrite_previous_autogenerated_summary=True)\n\n    mock_get_summary.assert_called_once()\n\n    print(\"\\n\\nIn this example, the previously autogenerated summary is overwritten with a new autogenerated summary:\\n\\n\")\n    print(notation_note_with_auto_notation_summary_tag.text())\n    assert mock_get_summary.return_value in notation_note_with_auto_notation_summary_tag.text()\n\nThe following is the original text of the notation note:\n\n---\ndetect_regex: []\nlatex_in_original: [\"\\\\operatorname{MT}(A)\"]\ntags: [_auto/notation_summary]\n---\n$\\operatorname{MT}(A)$ [[main_note_of_notation_note_with_auto_notation_summary_tag|denotes]] the Mumford-Tate group of the abelian variety $A$.\n\n\nIn this example, the previously autogenerated summary is overwritten with a new autogenerated summary:\n\n\n---\ndetect_regex: []\nlatex_in_original: [\"\\\\operatorname{MT}(A)\"]\ntags: [_auto/notation_summary]\n---\n$\\operatorname{MT}(A)$ [[main_note_of_notation_note_with_auto_notation_summary_tag|denotes]] (this is a mock summary) the Mumford Tate group of the abelian variety $A$ with CM. It is defined as the image of the reflex norm map of $A$.\n\n\n\nDon’t write a summary when\n\n\nnotation_note does not have a YAML frontmatter meta or\nthe _auto/notation_summary tag is not present in the YAML frontmatter meta and notation_note has nontrivial content.\n\n\n# In this example, the notation_note does not have a YAML frontmatter meta,\n# so no summary is written.\nwith (tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir,\n      mock.patch('__main__._get_summary') as mock_get_summary,\n      mock.patch('__main__._write_summary_to_notation_note') as mock_write_summary_to_notation_note):\n    temp_vault = Path(temp_dir) / 'test_vault_7'\n    shutil.copytree(_test_directory() / 'test_vault_7', temp_vault)\n    notation_note_without_yaml_frontmatter = VaultNote(temp_vault, name='some_reference_name_notation_k_t_formal_power_series_ring')\n\n    print(\"The following in the text of the notation note:\\n\")\n    print(notation_note_without_yaml_frontmatter.text())\n\n    append_summary_to_notation_note(notation_note_without_yaml_frontmatter, temp_vault, summarizer, overwrite_previous_autogenerated_summary=False)\n\n    mock_get_summary.assert_not_called()\n    mock_write_summary_to_notation_note.assert_not_called()\n\nThe following in the text of the notation note:\n\n$k[[t]]$ [[some_note|denotes]] the ring of formal power series where $k$ is a field.\n\n\n\n# In this example, there is \"nontrivial content\" in the notation note\n# and the `_auto/notation_summary` tag is not present in the notation\n# note, so the summary is assumed to be not autogenerated and hence\n# not replacable. As such, no summary is autogenerated.\n\nwith (tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir,\n      mock.patch('__main__._get_summary') as mock_get_summary,\n      mock.patch('__main__._write_summary_to_notation_note') as mock_write_summary_to_notation_note):\n    temp_vault = Path(temp_dir) / 'test_vault_7'\n    shutil.copytree(_test_directory() / 'test_vault_7', temp_vault)\n    notation_note_without_yaml_frontmatter = VaultNote(temp_vault, name='some_reference_name_notation_Pic_C')\n\n    print(\"The following in the text of the notation note:\\n\")\n    print(notation_note_without_yaml_frontmatter.text())\n\n    append_summary_to_notation_note(notation_note_without_yaml_frontmatter, temp_vault, summarizer, overwrite_previous_autogenerated_summary=False)\n\n    mock_get_summary.assert_not_called()\n    mock_write_summary_to_notation_note.assert_not_called()\n\nThe following in the text of the notation note:\n\n---\ndetect_regex: []\nlatex_in_original: [\"\\\\operatorname{Pic} C\"]\n---\n$\\operatorname{Pic} C$ [[divisor_class_group_of_a_curve|denotes]] the spectrum of the ring $A$.\n\n\n\nWhen the main note is identifiable, the _auto/notation_summary tag is not present, and notation_note has no content, write a summary, no matter what overwrite_previous_autogenerated_summary is.\n\n\n# In this example, the main note of the notation note is identifiable,\n# the `_auto/notation_summary` tag is not present, and the notation note has no,\n# so it is appropriate to auto generate a summary and write it to the\n# notation note. \n\nwith (tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir,\n      mock.patch('__main__._get_summary') as mock_get_summary,\n      # mock.patch('__main__._write_summary_to_notation_note') as mock_write_summary_to_notation_note\n      ):\n    temp_vault = Path(temp_dir) / 'test_vault_7'\n    shutil.copytree(_test_directory() / 'test_vault_7', temp_vault)\n    notation_note_with_auto_notation_summary_tag = VaultNote(temp_vault, name='foag_notation_M_n_bullet')\n\n    print(\"The following is the original text of the notation note:\\n\")\n    print(notation_note_with_auto_notation_summary_tag.text())\n\n    mock_get_summary.return_value = r\"(this is a mock summary) the twist of the quasicoherent sheaf $M_\\bullet$ on a scheme by the integer $n$.\"\n    append_summary_to_notation_note(notation_note_with_auto_notation_summary_tag, temp_vault, summarizer)\n\n    mock_get_summary.assert_called_once()\n\n    print(\"\\n\\nIn this example, the original note is deemed to not have a summary, auto-generated or not, written and hence a summary is generated and written. Note that an `_auto/notation_summary` tag is added :\\n\\n\")\n    print(notation_note_with_auto_notation_summary_tag.text())\n    assert mock_get_summary.return_value in notation_note_with_auto_notation_summary_tag.text()\n\nThe following is the original text of the notation note:\n\n---\ndetect_regex: []\nlatex_in_original: [\"$M(n)_\\\\bullet$\"]\n---\n$M(n)_\\bullet$ [[twist_of_a_graded_module|denotes]] \n\n\nIn this example, the original note is deemed to not have a summary, auto-generated or not, written and hence a summary is generated and written. Note that an `_auto/notation_summary` tag is added :\n\n\n---\ndetect_regex: []\nlatex_in_original: [\"$M(n)_\\\\bullet$\"]\ntags: [_auto/notation_summary]\n---\n$M(n)_\\bullet$ [[twist_of_a_graded_module|denotes]] (this is a mock summary) the twist of the quasicoherent sheaf $M_\\bullet$ on a scheme by the integer $n$.\n\n\n\n# This example is almost identical to the previous one, except `overwrite_previous_autogenerated_summary` is set to `True`\nwith (tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir,\n      mock.patch('__main__._get_summary') as mock_get_summary,\n      # mock.patch('__main__._write_summary_to_notation_note') as mock_write_summary_to_notation_note\n      ):\n    temp_vault = Path(temp_dir) / 'test_vault_7'\n    shutil.copytree(_test_directory() / 'test_vault_7', temp_vault)\n    notation_note_with_auto_notation_summary_tag = VaultNote(temp_vault, name='foag_notation_M_n_bullet')\n\n    print(\"The following is the original text of the notation note:\\n\")\n    print(notation_note_with_auto_notation_summary_tag.text())\n\n    mock_get_summary.return_value = r\"(this is a mock summary) the twist of the quasicoherent sheaf $M_\\bullet$ on a scheme by the integer $n$.\"\n    append_summary_to_notation_note(notation_note_with_auto_notation_summary_tag, temp_vault, summarizer, overwrite_previous_autogenerated_summary=True)\n\n    mock_get_summary.assert_called_once()\n\n    print(\"\\n\\nIn this example, the original note is deemed to not have a summary, auto-generated or not, written and hence a summary is generated and written. Note that an `_auto/notation_summary` tag is added :\\n\\n\")\n    print(notation_note_with_auto_notation_summary_tag.text())\n    assert mock_get_summary.return_value in notation_note_with_auto_notation_summary_tag.text()\n\nThe following is the original text of the notation note:\n\n---\ndetect_regex: []\nlatex_in_original: [\"$M(n)_\\\\bullet$\"]\n---\n$M(n)_\\bullet$ [[twist_of_a_graded_module|denotes]] \n\n\nIn this example, the original note is deemed to not have a summary, auto-generated or not, written and hence a summary is generated and written. Note that an `_auto/notation_summary` tag is added :\n\n\n---\ndetect_regex: []\nlatex_in_original: [\"$M(n)_\\\\bullet$\"]\ntags: [_auto/notation_summary]\n---\n$M(n)_\\bullet$ [[twist_of_a_graded_module|denotes]] (this is a mock summary) the twist of the quasicoherent sheaf $M_\\bullet$ on a scheme by the integer $n$.\n\n\n\nfrom transformers import AutoModelForSeq2SeqLM, AutoTokenizer, pipeline\n\n\nmodel = AutoModelForSeq2SeqLM.from_pretrained('hyunjongkimmath/notation_summarizations_model')\ntokenizer = AutoTokenizer.from_pretrained('hyunjongkimmath/notation_summarizations_model')\nsummarizer = pipeline('summarization', model=model, tokenizer=tokenizer)\n\nwith (tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir):\n    temp_vault = Path(temp_dir) / 'test_vault_7'\n    shutil.copytree(_test_directory() / 'test_vault_7', temp_vault)\n\n    notation_note_to_be_summarized = VaultNote(temp_vault, name='foag_notation_O_text_Proj__S__n')\n    append_summary_to_notation_note(notation_note_to_be_summarized, temp_vault, summarizer)\n\n    print(notation_note_to_be_summarized.text())\n\nYour max_length is set to 200, but your input_length is only 126. Since this is a summarization task, where outputs shorter than the input are typically wanted, you might consider decreasing max_length manually, e.g. summarizer('...', max_length=63)\n\n\n---\ndetect_regex: []\nlatex_in_original: [\"\\\\mathscr{O}_{\\\\text {Proj } S_{*}}(n)\"]\ntags: [_auto/notation_summary]\n---\n$\\mathscr{O}_{\\text {Proj } S_{*}}(n)$ [[foag_15.2.1|denotes]] $\\mathscr{O}_{\\text {Proj} S_{*}}(n)$ where $S_{*}$ is a graded ring generated in degree $1$.\n\n\n\n\n\nNaming notation notes\nAnother convenient functionality is to name notation notes automatically, see markdown.obsidian.personal.machine_learning.definition_and_notation_naming.ipynb.",
    "crumbs": [
      "markdown.obsidian.personal.machine_learning.notation_summarization"
    ]
  },
  {
    "objectID": "helper.regex.html",
    "href": "helper.regex.html",
    "title": "helper.regex",
    "section": "",
    "text": "from fastcore.test import *\nfrom trouver.helper.tests import _test_directory\n\n\nsource\n\nfind_regex_in_text\n\n find_regex_in_text (text:str, pattern:Union[str,Pattern[str]])\n\nReturn ranges in text where pattern occurs.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ntext\nstr\nText in which to find regex patter\n\n\npattern\nUnion\nThe regex pattern\n\n\nReturns\nlist\nEach tuple is of the form (a,b) where text[a:b] is the regex match.\n\n\n\nThe following example finds the occurrence of the Markdown footnote:\n\nregex_pattern = r'\\[\\^\\d\\]'\ntext = '[^1]: asdf'\n\noutput = find_regex_in_text(text, regex_pattern)\ntest_eq(output, [(0,4)])\n\nstart, end = output[0]\ntest_eq(text[start:end], '[^1]')\n\nIf there are multiple matches for the regex pattern, then they are all included in the outputted list.\n\nregex_pattern = r'\\d+'  # Searches for one or more consecutive digits\ntext = '9000 is a big number. But you know what is bigger? 9001.'\n\noutput = find_regex_in_text(text, regex_pattern)\ntest_eq(len(output), 2)\n\nstart, end = output[0]\ntest_eq(text[start:end], '9000')\n\nstart, end = output[1]\ntest_eq(text[start:end], '9001')\n\nThe following example detects YAML frontmatter text as used in Obsidian. This regex pattern is also used in markdown.markdown.file.find_front_matter_meta_in_markdown_text.\nThe regex pattern used is able to detect the frontmatter even when it is empty.\n\nsample_regex = r'---\\n([\\S\\s]*?)?(?(1)\\n|)---'\nsample_str = '---\\n---'\nsample_output = find_regex_in_text(sample_str, sample_regex)\nassert sample_output == [(0,7)]\n\nsample_str = '---\\naliases: [this_is_an_aliases_for_the_Obsidian_note]\\n---'\nsample_output = find_regex_in_text(sample_str, sample_regex)\nassert sample_output == [(0, len(sample_str))]  # The entire sample_str is detected.\n\nContrast the regex pattern above with the pattern ---\\n[\\S\\s]*?\\n---, which does not detect empty YAML frontmatter text.\n\nsample_regex = r'---\\n[\\S\\s]*?\\n---'\nsample_str = '---\\n---'\nsample_output = find_regex_in_text(sample_str, sample_regex)\nassert not sample_output\n\n\nsource\n\n\nseparate_indices_from_str\n\n separate_indices_from_str (text:str, indices:list[tuple[int,int]])\n\n*Divide text into parts along the substrings specified by indices.\nAssumes that the pairs of indices specified by indices are in order from first to last and the ranges specified by these pairs are all disjoint.\n''.join(output) should recover text.*\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ntext\nstr\n\n\n\nindices\nlist\nThe indices for substrings in text to separate.\n\n\nReturns\nlist\nEach str is a substring of text, either a substring of text specified by indices, or substrings in between the substrings specified by indices.\n\n\n\nHere is a basic example of separate_indices_from_str:\n\ntext = 'hello asdf asdf'\nsample_output = separate_indices_from_str(text, [(0,5), (10,11)])\nprint(sample_output)\ntest_eq(''.join(sample_output), text)\n\n['', 'hello', ' asdf', ' ', 'asdf']\n\n\n\nsource\n\n\nreplace_string_by_indices\n\n replace_string_by_indices (string:str,\n                            replace_ranges:Sequence[Union[Sequence[int],in\n                            t]], replace_with:Union[Sequence[str],str])\n\n*Replace parts of string at the specified locations”\nUse this with find_regex_in_text.\nParameters\n\nstring - str\nreplace_ranges - Sequence[Sequence[int] | int]\n\nEither a list of lists/tuples of one or two int’s. A list/tuple [a,b] or (a,b) means that string[a:b] is to be replaced. [a] or (a) means that string[a:] is to be replaced. The ranges should not overlap and should be arranged in chronological order.\n\nreplace_with - Sequence[str] | str\n\nThe str’s which will replace the parts represented by replace_ranges. replace_ranges and replace_with must be both lists or both not lists. If they are lists, they must be of the same length.\n\n\nReturns\n\nstr*\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nstring\nstr\nString in which to make replacemenets\n\n\nreplace_ranges\nSequence\nA list of lists/tuples of int’s or a single list/tuple of int’s. Each\n\n\nreplace_with\nUnion\nThe str(s) which will replace the substrings at replace_ranges in string. replace_with must be a str exactly when replace_ranges is a Sequence of a single Sequence of int.\n\n\nReturns\nstr\nThe str obtained by replacing the substrings at replace_range in string by the strs specified by replace_with.\n\n\n\nThe following are basic examples of replace_strings_by_indices:\n\ntest_eq(replace_string_by_indices('hello world', replace_ranges=(0,5), replace_with='hi'), 'hi world')\ntest_eq(replace_string_by_indices('hello somebody', replace_ranges=[(0,1), (6,10)], replace_with=['', '']), 'ello body')\n\nIf replace_ranges and replace_with are of different length, then a ValueError is raised:\n\nwith ExceptionExpected(ex=ValueError, regex=\"are different\"):\n    replace_string_by_indices('hello world', replace_ranges = [(0,5), (6,10)], replace_with = [''])\n\n\nFinding LaTeX string\n\nsource\n\n\n\ninline_latex_indices\n\n inline_latex_indices (text:str)\n\n*Returns the indices in the text containing inline LaTeX str surrounded by $$.\nThis may not work correctly if the text has a LaTeX formatting issue or if any LaTeX string has a dollar sign \\$.\nParameters\n\ntext - str\n\nReturns\n\ntuple[int]\n\nEach tuple is of the form (start, end) where text[start:end] is a LaTeX string, including any leading trailing dollar signs ($$).*\n\n\n\nsource\n\n\nlatex_indices\n\n latex_indices (text:str)\n\n*Returns the indices in the text containing LaTeX str.\nThis may not work correctly if the text has a LaTeX formatting issue.\nParameters\n\ntext - str\n\nReturns\n\ntuple[int]\n\nEach tuple is of the form (start, end) where text[start:end] is a LaTeX string, including any leading trailing dollar signs ($ or $$).*\n\n\nHere are some basic uses of the latex_indices function:\n\ntext = r'$$5 \\neq 7$$ is a LaTeX equation.'\nlisty = latex_indices(text)\nassert len(listy) == 1\nstart, end = listy[0]\ntest_eq(text[start:end], r'$$5 \\neq 7$$')\n\ntext = r'$\\mathcal{O}_X$ denotes the structure sheaf.'\nlisty = latex_indices(text)\nassert len(listy) == 1\nstart, end = listy[0]\ntest_eq(text[start:end], r'$\\mathcal{O}_X$')\n\ntext = r'$$\\n5 \\neq 7\\n$$'\nlisty = latex_indices(text)\nassert len(listy) == 1\n\nIf there is a dollar sign symbol \\$ outside of a LaTeX string, then the latex_indices function works as expected; the dollar signs are not considered to be part of any LaTeX string:\n\ntext = r'\\$6.2.4 helo blah $15+6+21$'  # Avoid detecting \\$ as latex start/end\nlisty = latex_indices(text)\nstart, end = listy[0]\ntest_eq(text[start:end], r'$15+6+21$')\n\nIn the following example, the text has dollar sign symbols \\$ which do not surround math mode text\n\ntext = r'\\$6.2.4 helo blah $\\$37$ are needed for stuff.' \nlisty = latex_indices(text)\nstart, end = listy[0]\ntest_eq(len(listy), 1)\nprint(text[listy[0][0]:listy[0][1]])  # This should print `$\\$`, which is at the start of `$\\$37$`.\ntest_eq(text[start:end], r'$\\$37$')\n\n$\\$37$\n\n\nIn the following example, note that \\$S.10 is (correctly) not recognized as a LaTeX math mode string. Moreover, multi-line math mode strings are also recognized.\n\ntext = r\"\"\"\n\\$S.10 We have some latex string $a$ $hi$\n\n$$\nasdf\n$$\n\"\"\"\nlatex_indices(text)\n\n[(34, 37), (38, 42), (44, 54)]\n\n\n\nprint(text[34:37])\nprint(text[38:42])\nprint(text[44:54])\n\n$a$\n$hi$\n$$\nasdf\n$$\n\n\nThe inline_latex_indices function finds the indices only for in-line LaTeX math mode strings (which are surrounded by $$)\n\ntext = r\"\"\"\n\\$S.10 We have some latex string $a$ $hi$\n\n$$\nasdf\n$$\n\"\"\"\ninline_latex_indices(text)\n\n[(44, 54)]\n\n\n\nprint(text[44:54])\n\n$$\nasdf\n$$",
    "crumbs": [
      "helper.regex"
    ]
  },
  {
    "objectID": "app.__init__.html",
    "href": "app.__init__.html",
    "title": "app.__init__",
    "section": "",
    "text": "The design for the GUI is developed in the file nbs\\pyqt6_UI\\app.ui (relative to the trouver root directory). - The command line command pyqt6-tools designer can be used to open the PyQt6 Designer (assuming that pyqt6 and pyqt6-tools are installed into the Python environment). - Go to the nbs\\pyqt6_UI folder in a command line and use the command line command pyuic6 -o app.py app.ui to generate the code from the designed UI into the file app.py.\nDuring development, one can simply use the import statement from_pyqt6_UI.app import Ui_MainWindow (see below) in this Jupyter notebook. However, before using nbdev_export to compile the code for trouver, the code within app.py should be copied into an #| export cell.\nTo build the GUI as a standalone executable/application, one can use PyInstaller (which needs to be installed in the Python environment). To do so, do the following:\n\nCopy the file generated by nbdev_export for this module (which should be outputted as the file trouver\\app\\__init__.py relative to the trouver root directory) into some (preferably empty) folder.\nOptionally, rename the copied file as trouver_gui.py.\nOpen a command line in the folder containing the file.\nUse the command pyinstaller --onefile [--windowed] &lt;name_of_copied_file&gt;.py.\n\nThe application should build, which shoud take several minutes, and should end up in a folder named dist as an .exe file.",
    "crumbs": [
      "`app.__init__`"
    ]
  },
  {
    "objectID": "app.__init__.html#for-developers",
    "href": "app.__init__.html#for-developers",
    "title": "app.__init__",
    "section": "",
    "text": "The design for the GUI is developed in the file nbs\\pyqt6_UI\\app.ui (relative to the trouver root directory). - The command line command pyqt6-tools designer can be used to open the PyQt6 Designer (assuming that pyqt6 and pyqt6-tools are installed into the Python environment). - Go to the nbs\\pyqt6_UI folder in a command line and use the command line command pyuic6 -o app.py app.ui to generate the code from the designed UI into the file app.py.\nDuring development, one can simply use the import statement from_pyqt6_UI.app import Ui_MainWindow (see below) in this Jupyter notebook. However, before using nbdev_export to compile the code for trouver, the code within app.py should be copied into an #| export cell.\nTo build the GUI as a standalone executable/application, one can use PyInstaller (which needs to be installed in the Python environment). To do so, do the following:\n\nCopy the file generated by nbdev_export for this module (which should be outputted as the file trouver\\app\\__init__.py relative to the trouver root directory) into some (preferably empty) folder.\nOptionally, rename the copied file as trouver_gui.py.\nOpen a command line in the folder containing the file.\nUse the command pyinstaller --onefile [--windowed] &lt;name_of_copied_file&gt;.py.\n\nThe application should build, which shoud take several minutes, and should end up in a folder named dist as an .exe file.",
    "crumbs": [
      "`app.__init__`"
    ]
  },
  {
    "objectID": "app.__init__.html#ui-code",
    "href": "app.__init__.html#ui-code",
    "title": "app.__init__",
    "section": "UI code",
    "text": "UI code\n\n\nUi_MainWindow\n\n Ui_MainWindow ()\n\nInitialize self. See help(type(self)) for accurate signature.\n\n\n\nScrollableMessageBox\n\n ScrollableMessageBox (*args, **kwargs)",
    "crumbs": [
      "`app.__init__`"
    ]
  },
  {
    "objectID": "app.__init__.html#the-trouvergui-class",
    "href": "app.__init__.html#the-trouvergui-class",
    "title": "app.__init__",
    "section": "The TrouverGUI class",
    "text": "The TrouverGUI class\nThe TrouverGUI class serves as the GUI for trouver functonalities.\n\n\nTrouverGUI\n\n TrouverGUI ()\n\n*Attributes\n\ndownload_thread: DownloadThread\n\nA QThread that manages the source-file-download.\n\ndownloaded_folder: Path\n\nThe folder in which the source file is downloaded.\n\nauthors - str\n\nRoughly, the family names of the authors. This is determined during the invocation of self.download_thread.run.\n\ncreate_obsidian_thread: CreateObsidianVaultThread\n\nA QThread that manages the Obsidian.md (sub)vault creation.\n\ncreated_obsidian_vault: Path\n\nThe folder in which the Obsidian.md (sub)vault is created.\n\nprediction_thread: PredictionThread\n\nA QThread that manages ML predictions\n\ncurrent_predicted_note: VaultNote\n\nThe VaultNote that is currently being predicted.\n\ncompile_to_tex_thread: CompileObsidianSubvaultAsTexThread\n\nA QThead that manages compiling an Obisidian.md (sub)vault into a single .tex file.*",
    "crumbs": [
      "`app.__init__`"
    ]
  },
  {
    "objectID": "app.__init__.html#ui-initialization",
    "href": "app.__init__.html#ui-initialization",
    "title": "app.__init__",
    "section": "UI initialization",
    "text": "UI initialization\n\n\ninitUI\n\n initUI ()",
    "crumbs": [
      "`app.__init__`"
    ]
  },
  {
    "objectID": "app.__init__.html#error-message",
    "href": "app.__init__.html#error-message",
    "title": "app.__init__",
    "section": "Error message",
    "text": "Error message\n\n\nsimple_instructional_message\n\n simple_instructional_message (window_title:str, window_text:str)\n\nDisplay a simple error message for when specifications by the user do not fulfill requirements.",
    "crumbs": [
      "`app.__init__`"
    ]
  },
  {
    "objectID": "app.__init__.html#download-arxiv-source-file",
    "href": "app.__init__.html#download-arxiv-source-file",
    "title": "app.__init__",
    "section": "Download arxiv source file",
    "text": "Download arxiv source file\n\n\nDownloadThread\n\n DownloadThread (url:str, folder:os.PathLike, trouver_gui)\n\n\n\n\nchoose_source_download_folder\n\n choose_source_download_folder ()\n\n\n\n\nchoose_file_or_folder\n\n choose_file_or_folder (set_text_method:Callable[[os.PathLike],NoneType],\n                        default_folder:os.PathLike|None, for_folder:bool)\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nset_text_method\nCallable\nThe method of self that is supposed to be used after the folder is chosen to change the text of a label.\n\n\ndefault_folder\nos.PathLike | None\nThe default folder to open in the QFileDialog, if available. This should be an absolute path.\n\n\nfor_folder\nbool\nIf True, then the dialog is for choosing a folder. Otherwise, the dialog is for choosing a file.\n\n\nReturns\nNone\n\n\n\n\n\n\n\nget_download_folder\n\n get_download_folder ()\n\nGet the indicated folder in which to download the source code.\n\n\n\nget_folder\n\n get_folder (text)\n\n*Get a folder path from some text.\nFor example, “Selected Folder: ”*\n\n\n\ndownload_arxiv_source\n\n download_arxiv_source ()\n\n\n\n\nopen_downloaded_folder\n\n open_downloaded_folder ()",
    "crumbs": [
      "`app.__init__`"
    ]
  },
  {
    "objectID": "app.__init__.html#setup-obsidian.md-vault-from-tex-file.",
    "href": "app.__init__.html#setup-obsidian.md-vault-from-tex-file.",
    "title": "app.__init__",
    "section": "Setup Obsidian.md vault from tex file.",
    "text": "Setup Obsidian.md vault from tex file.\n\n\nchoose_obsidian_subvault_location\n\n choose_obsidian_subvault_location ()\n\n\n\n\nchoose_source_code_file\n\n choose_source_code_file ()\n\n\n\n\nCreateObsidianVaultThread\n\n CreateObsidianVaultThread (source_file:os.PathLike,\n                            subvault_folder:os.PathLike,\n                            subvault_name:str, authors:list[str])\n\n\n\n\ncreate_obsidian_subvault\n\n create_obsidian_subvault ()\n\n\n\n\nopen_created_obsidian_subvault\n\n open_created_obsidian_subvault ()",
    "crumbs": [
      "`app.__init__`"
    ]
  },
  {
    "objectID": "app.__init__.html#predict-on-notes",
    "href": "app.__init__.html#predict-on-notes",
    "title": "app.__init__",
    "section": "Predict on notes",
    "text": "Predict on notes\n\n\nshow_confirmation_dialog\n\n show_confirmation_dialog (models_exist:bool, packages_installed:bool)\n\nConfirm whether packages should be installed and/or models should be downloaded before making predictions.\n\n\n\npredict_on_notes\n\n predict_on_notes ()\n\n\n\n\nchoose_prediction_folder\n\n choose_prediction_folder ()\n\n\n\n\nget_prediction_folder\n\n get_prediction_folder ()\n\n\n\n\nPredictionThread\n\n PredictionThread (trouver_gui, vault:os.PathLike)\n\n\n\n\nfrom_pretrained_fastai_without_checking_fastai_fastcore_version\n\n from_pretrained_fastai_without_checking_fastai_fastcore_version\n                                                                  (repo_id\n                                                                  :str, re\n                                                                  vision:O\n                                                                  ptional[\n                                                                  str]=Non\n                                                                  e)\n\n*This is a copy of the from_pretrained_fastai funtion from the huggingface_hub.fastai_utils module, except that it does not check the fastai and fastcore versions as that function does.\nIt may be the case that the fastai/fastcore version checking functions do not work as intended when the app is built.\nArgs: repo_id (str): The location where the pickled fastai.Learner is. It can be either of the two: - Hosted on the Hugging Face Hub. E.g.: ‘espejelomar/fatai-pet-breeds-classification’ or ‘distilgpt2’. You can add a revision by appending @ at the end of repo_id. E.g.: dbmdz/bert-base-german-cased@main. Revision is the specific model version to use. Since we use a git-based system for storing models and other artifacts on the Hugging Face Hub, it can be a branch name, a tag name, or a commit id. - Hosted locally. repo_id would be a directory containing the pickle and a pyproject.toml indicating the fastai and fastcore versions used to build the fastai.Learner. E.g.: ./my_model_directory/. revision (str, optional): Revision at which the repo’s files are downloaded. See documentation of snapshot_download.\nReturns: The fastai.Learner model in the repo_id repo.*\n\n\n\nopen_prediction_folder\n\n open_prediction_folder ()",
    "crumbs": [
      "`app.__init__`"
    ]
  },
  {
    "objectID": "app.__init__.html#compile-predicted-notes-into-single-.tex-file",
    "href": "app.__init__.html#compile-predicted-notes-into-single-.tex-file",
    "title": "app.__init__",
    "section": "Compile predicted notes into single .tex file",
    "text": "Compile predicted notes into single .tex file\n\n\nchoose_compiled_tex_output_folder\n\n choose_compiled_tex_output_folder ()\n\n\n\n\nget_compiled_tex_output_folder\n\n get_compiled_tex_output_folder ()\n\n\n\n\nchoose_original_tex_file\n\n choose_original_tex_file ()\n\n\n\n\nget_original_tex_file\n\n get_original_tex_file ()\n\n\n\n\nchoose_obsidian_subvault_to_compile_notes\n\n choose_obsidian_subvault_to_compile_notes ()\n\n\n\n\nget_obsidian_subvault_to_compile\n\n get_obsidian_subvault_to_compile ()\n\n\n\n\ncompile_obsidian_subvault_as_tex_file\n\n compile_obsidian_subvault_as_tex_file ()\n\n\n\n\nCompileObsidianSubvaultAsTexThread\n\n CompileObsidianSubvaultAsTexThread (subvault:os.PathLike,\n                                     index_file:os.PathLike,\n                                     original_tex_file:os.PathLike,\n                                     output_folder:os.PathLike)",
    "crumbs": [
      "`app.__init__`"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.reference.html",
    "href": "markdown.obsidian.personal.reference.html",
    "title": "markdown.obisidian.personal.reference",
    "section": "",
    "text": "import shutil\nimport tempfile\nfrom unittest import mock\n\nfrom fastcore.test import *\n\nfrom trouver.helper.tests import _test_directory",
    "crumbs": [
      "markdown.obisidian.personal.reference"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.reference.html#deleting-a-reference-folder",
    "href": "markdown.obsidian.personal.reference.html#deleting-a-reference-folder",
    "title": "markdown.obisidian.personal.reference",
    "section": "Deleting a reference folder",
    "text": "Deleting a reference folder\n\nsource\n\ndelete_reference_folder\n\n delete_reference_folder (vault:os.PathLike,\n                          reference:Union[str,os.PathLike],\n                          verbose:bool=True, confirm:bool=True)\n\n*Deletes a reference folder along with the associated template note and the reference note, both of which are outside the reference folder.\nAssumes that - the reference folder, if it exists, has an index note named _index_{reference_name}.md and this note is the unique note in the vault with this filename. - the template note, if it exists, is named _template_{reference_name}.md and is the unique note in the vault with this filename. - the reference note, if it exists, is named _reference_{reference_name}.md and is the unique note in the vault with this filename.\nIf the template/reference note for the reference is not unique, then the deletion does not proceed. On the other hand, even if a template/reference note does not exist, then the deletion proceeds.\nNote that links to notes in the reference folder are preserved.\nRaises\n\nFileNotFoundError\n\nIf the specified reference folder does not exist.\n\nNoteDoesNotExistError\n\nIf the index note for the reference folder does not exist in the vault.\n\nNoteNotUniqueError\n\nIf the index note, template note, or reference note for the reference folder is not unique in the vault.*\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nvault\nPathLike\n\nThe vault in which the reference folder resides.\n\n\nreference\nUnion\n\nThe reference to delete. Is either a str, in which case the folder to delete will be the folder containing the (unique) note of the name _index_{reference}.md, or a path relative to vault.\n\n\nverbose\nbool\nTrue\n\n\n\nconfirm\nbool\nTrue\nIf True, prompts the user to confirm the deletion of the folder.\n\n\nReturns\nNone\n\n\n\n\n\nThe delete_reference_folder method deletes the reference folder itself as well as the peripheral files for the reference (the template file and reference file) which are outside of the reference folder itself.\n\nwith (tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir,\n      mock.patch('__main__.input', return_value='Y') as mock_input):\n    temp_vault = Path(temp_dir) / 'test_vault_5'\n    shutil.copytree(_test_directory() / 'test_vault_5', temp_vault)\n    \n    delete_reference_folder(temp_vault, reference='number_theory_reference_1')\n    assert 'number_theory_reference_1' not in os.listdir(temp_vault / 'number_theory')\n    assert not VaultNote(temp_vault, name='_template_number_theory_reference_1').exists()\n    assert not VaultNote(temp_vault, name='_reference_number_theory_reference_1').exists()\n\n\nIdentified reference 'number_theory_reference_1' in the vault 'c:\\Users\\hyunj\\Documents\\Development\\Python\\trouver\\nbs\\temp_dirwpe9ozwq\\test_vault_5' as the folder 'c:\\Users\\hyunj\\Documents\\Development\\Python\\trouver\\nbs\\temp_dirwpe9ozwq\\test_vault_5\\number_theory\\number_theory_reference_1'...\nDeleting...\nDeleted reference.\n\n\n\nIn the following example, we test the deletion of a non-existent reference folder for which the template and reference files are deleted.\n\nwith (tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir,\n      mock.patch('__main__.input', return_value='Y') as mock_input):\n    temp_vault = Path(temp_dir) / 'test_vault_5'\n    shutil.copytree(_test_directory() / 'test_vault_5', temp_vault)\n\n    \n    nonexistent_reference_name = 'nonexistent_reference'\n    assert not VaultNote(temp_vault, name=f'_index_{nonexistent_reference_name}').exists()\n    assert VaultNote(temp_vault, name=f'_template_{nonexistent_reference_name}').exists()\n    assert VaultNote(temp_vault, name=f'_reference_{nonexistent_reference_name}').exists()\n\n    delete_reference_folder(temp_vault, reference='nonexistent_reference')\n    assert not VaultNote(temp_vault, name=f'_template_{nonexistent_reference_name}').exists()\n    assert not VaultNote(temp_vault, name=f'_reference{nonexistent_reference_name}').exists()\n\nDeleting...\nDeleted reference.",
    "crumbs": [
      "markdown.obisidian.personal.reference"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.reference.html#helper-methods-for-setting-up-new-reference-folders",
    "href": "markdown.obsidian.personal.reference.html#helper-methods-for-setting-up-new-reference-folders",
    "title": "markdown.obisidian.personal.reference",
    "section": "Helper methods for setting up new reference folders",
    "text": "Helper methods for setting up new reference folders\nMaking a new reference folder takes some annoying amount of work.\n\ntest_vault = _test_directory() / 'test_vault_5'\ntemplate_vault_note = VaultNote(test_vault, name='_template_glossary')\nassert template_vault_note.exists()\nwith (mock.patch('__main__.VaultNote') as mock_VaultNote,\n      mock.patch('__main__.MarkdownFile.from_vault_note') as mock_markdownfile_from_vault_note):\n    _make_glossary_file(\n        Path('mock_path_1') / 'test_reference_1', 'test_reference_1', test_vault, '_glossary_notation_index')\n    \n    test_eq(mock_VaultNote.call_count, 2)\n    mock_VaultNote.assert_called_with(test_vault, rel_path=Path('mock_path_1') / 'test_reference_1' / '_glossary_test_reference_1.md')\n    mock_VaultNote.return_value.create.assert_called_once()\n    mock_markdownfile_from_vault_note.return_value.write.assert_called_once()\n\n\ntest_vault = _test_directory() / 'test_vault_5'\nwith (mock.patch('__main__.VaultNote') as mock_VaultNote,\n      mock.patch('__main__.os.mkdir') as mock_os_mkdir):\n    _make_temp_folder(\n        Path('mock_path_1') / 'test_reference_1', 'test_reference_1', test_vault)\n    \n    mock_os_mkdir.assert_called_once_with(test_vault / 'mock_path_1' / 'test_reference_1' / '_temp')\n    mock_VaultNote.assert_called_once_with(test_vault, rel_path=Path('mock_path_1') / 'test_reference_1' / '_temp' / '_index_temp_test_reference_1.md')\n    mock_VaultNote.return_value.create.assert_called_once()",
    "crumbs": [
      "markdown.obisidian.personal.reference"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.reference.html#copy-obsidian-vault-plugin-configs",
    "href": "markdown.obsidian.personal.reference.html#copy-obsidian-vault-plugin-configs",
    "title": "markdown.obisidian.personal.reference",
    "section": "Copy obsidian vault plugin configs",
    "text": "Copy obsidian vault plugin configs\nWhen an Obsidian vault has a lot of notes (on the order of 10000+ notes), Obsidian tends to experience significant lag. As such, it can be useful to open a reference folder as a “subvault”, i.e. a vault in itself, and in turn it is convenient to automatically copy settings from the “main” vault.\n\nsource\n\ncopy_obsidian_vault_configs\n\n copy_obsidian_vault_configs (vault:os.PathLike,\n                              reference_directory:os.PathLike,\n                              configs_folder:os.PathLike,\n                              dirs_exist_ok:bool=False, ignore=None)\n\n*Copy the vault’s Obsidian config files into the reference directory.\nconfigs_folder is copied into the destination vault / reference_directory / '.obsidian'.\nshutil.copytree is used to copy the Obsidian configurations.\nRaises - FileExistsError - If dirs_exist_ok is False and the destination vault / reference_directory / '.obsidian' already exists.\n**See Also - copy_obsidian_vault_configs_with_nice_modifications*\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nvault\nPathLike\n\n\n\n\nreference_directory\nPathLike\n\nThe folder into which to copy the Obsidian configs. Relative to vault.\n\n\nconfigs_folder\nPathLike\n\nThe folder containing the Obsidian configs. This is either an absolute path or relative to the current working directory.\n\n\ndirs_exist_ok\nbool\nFalse\nIf dirs_exist_ok is False and the destination folder already exists, then a FileExistsError is raised. If dirs_exist_ok is true, the copying operation will continue if it encounters existing directories, and files within the destination tree will be overwritten by corresponding files from the source tree. See also the shutil.copytree function.\n\n\nignore\nNoneType\nNone\nSee documentation of the shutil.copytree function.\n\n\nReturns\nNone\n\n\n\n\n\n\ntest_vault = _test_directory() / 'test_vault_5'\nwith (mock.patch('__main__.VaultNote') as mock_VaultNote,\n      mock.patch('__main__.shutil.copytree') as mock_shutil_copytree):\n    copy_obsidian_vault_configs(\n        test_vault, Path('mock_path_1') / 'test_reference_1', test_vault / '.obsidian')\n    \n    mock_shutil_copytree.assert_called_once_with(\n        test_vault / '.obsidian',\n        test_vault / 'mock_path_1' / 'test_reference_1' / '.obsidian',\n        dirs_exist_ok=False, ignore=None)\n\nIf dirs_exist_okay = False but then the .obsidian folder of reference_directory already exists, then a FileExistsError is raised, cf. the description of the dirs_exist_ok parameter of the shutil.copytree function.\n\nwith (tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir):\n    # First copy over a testing vault\n    temp_vault = Path(temp_dir) / 'test_vault_5'\n    shutil.copytree(_test_directory() / 'test_vault_5', temp_vault)\n\n    # Copy the obsidian vault configs once\n    copy_obsidian_vault_configs(\n        temp_vault,\n        Path('number_theory') / 'number_theory_reference_1',\n        temp_vault / '.obsidian',\n        dirs_exist_ok = False)\n    \n    # Then, try copying the configs again in the same way\n    # into the same destination.\n    with ExceptionExpected(ex=FileExistsError):\n        copy_obsidian_vault_configs(\n            temp_vault,\n            Path('number_theory') / 'number_theory_reference_1',\n            temp_vault / '.obsidian',\n            dirs_exist_ok = False)\n\nIf dirs_exist_okay = True, and if the destination vault / reference_directory / '.obsidian' already exists, then the copying operation will continue if it encounters existing directories, and existing files will be overwritten\n\nwith (tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir):\n    # First copy over a testing vault\n    temp_vault = Path(temp_dir) / 'test_vault_5'\n    shutil.copytree(_test_directory() / 'test_vault_5', temp_vault)\n\n    # Copy the obsidian vault configs once\n    reference_directory = Path('number_theory') / 'number_theory_reference_1'\n    copy_obsidian_vault_configs(\n        temp_vault,\n        reference_directory,\n        temp_vault / '.obsidian',\n        dirs_exist_ok = True)\n\n    # Try modifying one of the files in the newly copied configs folder:\n    with open(temp_vault / reference_directory / '.obsidian' / 'templates.json', 'w') as file:\n        file.write('')\n    \n    # os.startfile(temp_vault / reference_directory)\n    # input()\n\n    # Then, try copying the configs again in the same way\n    # into the same destination.\n    copy_obsidian_vault_configs(\n        temp_vault,\n        reference_directory,\n        temp_vault / '.obsidian',\n        dirs_exist_ok = True)\n    # The configs folder is copied over once again.\n    with open(temp_vault / reference_directory / '.obsidian' / 'templates.json', 'r') as file:\n        test_ne(file.read(), '')\n\nWe can use the ignore parameter to ignore copying over certain files (say satisfying specified patterns). See the ignore parameter of the `shutil.copytree function.\n\nwith (tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir):\n    # First copy over a testing vault\n    temp_vault = Path(temp_dir) / 'test_vault_5'\n    shutil.copytree(_test_directory() / 'test_vault_5', temp_vault)\n\n    # Copy the obsidian vault configs once\n    reference_directory = Path('number_theory') / 'number_theory_reference_1'\n    copy_obsidian_vault_configs(\n        temp_vault,\n        reference_directory,\n        temp_vault / '.obsidian',\n        dirs_exist_ok = True)\n\n    # Try modifying two of the files in the newly copied configs folder:\n    with open(temp_vault / reference_directory / '.obsidian' / 'templates.json', 'w') as file:\n        file.write('')\n    with open(temp_vault / reference_directory / '.obsidian' / 'app.json', 'w') as file:\n        file.write('')\n    \n    # os.startfile(temp_vault / reference_directory)\n    # input()\n\n    # Then, try copying the configs again in the same way\n    # into the same destination, except for files named 'templates.json'.\n    copy_obsidian_vault_configs(\n        temp_vault,\n        reference_directory,\n        temp_vault / '.obsidian',\n        dirs_exist_ok = True,\n        ignore = shutil.ignore_patterns('templates.json'))\n    # The configs folder is copied over once again, except for the 'templates.json' file.\n    with open(temp_vault / reference_directory / '.obsidian' / 'templates.json', 'r') as file:\n        test_eq(file.read(), '')\n    with open(temp_vault / reference_directory / '.obsidian' / 'app.json', 'r') as file:\n        test_ne(file.read(), '')\n\nThe author of trouver makes two configuration modifications for each reference/subvault\n\nIn the author’s own fast-link-edit plugin, the author sets the referenceName field to whatever the name of the reference is in the vault\nIn the template core plugin, the author sets the folder field to ..\n\nMoreover, sometimes one might want to make modifications to the configurations in one’s obsidian vaults; applying these modifications to all the configurations in the various subvaults would be tedious to do manually.\nThe below functions give ways to modify Obsidian plugin configurations and to copy and modify certain plugin configurations.\n\nsource\n\n\nget_obsidian_vault_plugin_configs\n\n get_obsidian_vault_plugin_configs (vault:os.PathLike, plugin_name:str,\n                                    plugin_is_core:bool)\n\n*Obtain the JSON object representing the data.json file of an Obsidian plugin.\nThis function assumes that the the Obsidian plugin exists in vault in that the plugin has a data.json file.*\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nvault\nPathLike\n\n\n\nplugin_name\nstr\nThe folder name of the Obsidian plugin. This can be found in the .obsidian directory in the vault.\n\n\nplugin_is_core\nbool\nTrue if the plugin is a core Obsidian.md plugin. False if the plugin is a community plugin.\n\n\nReturns\ndict\nA json dict.\n\n\n\n\ntest_vault = _test_directory() / 'test_vault_5' \nsample_output_1 = get_obsidian_vault_plugin_configs(test_vault, 'fast-link-edit', False)\ntest_eq(sample_output_1, {'referenceName': 'some_reference'})\n\nsample_output_2 = get_obsidian_vault_plugin_configs(test_vault, 'templates', True)\ntest_eq(sample_output_2, {'folder': '_templates'})\n\n\nsource\n\n\nmodify_obsidian_vault_plugin_configs\n\n modify_obsidian_vault_plugin_configs (vault:os.PathLike, plugin_name:str,\n                                       plugin_is_core:bool, field:str, val\n                                       ue:Union[str,int,float,bool,NoneTyp\n                                       e,list,dict])\n\n*Modify/set a top level field in an Obsidian vault plugin configs file.\nAssumes that the Obsidian vault plugins configs are indented by 2 spaces.\nNote that only top level values can be directly set by this function.*\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nvault\nPathLike\n\n\n\nplugin_name\nstr\nThe folder name of the Obsidian plugin. This can be found in the .obsidian directory in the vault.\n\n\nplugin_is_core\nbool\nTrue if the plugin is a core Obsidian.md plugin. False if the plugin is a community plugin.\n\n\nfield\nstr\nThe field to modify\n\n\nvalue\nUnion\nThe JSON value to set the field as\n\n\nReturns\nNone\n\n\n\n\n\nwith (tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir):\n    temp_vault = Path(temp_dir) / 'test_vault_5'\n    shutil.copytree(_test_directory() / 'test_vault_5', temp_vault)\n\n    modify_obsidian_vault_plugin_configs(temp_vault, 'fast-link-edit', False, 'referenceName', 'some_other_reference')\n    sample_output_1 = get_obsidian_vault_plugin_configs(temp_vault, 'fast-link-edit', False)\n    test_eq(sample_output_1, {'referenceName': 'some_other_reference'})\n\n    modify_obsidian_vault_plugin_configs(temp_vault, 'templates', True, 'folder', '/')\n    sample_output_2 = get_obsidian_vault_plugin_configs(temp_vault, 'templates', True)\n    test_eq(sample_output_2, {'folder': '/'})\n\n\nsource\n\n\ncopy_obsidian_vault_configs_with_nice_modifications\n\n copy_obsidian_vault_configs_with_nice_modifications (vault:os.PathLike,\n                                                      reference_directory:\n                                                      os.PathLike, configs\n                                                      _folder:os.PathLike,\n                                                      reference_name:str=N\n                                                      one, template_locati\n                                                      on:str='/', dirs_exi\n                                                      st_ok:bool=False,\n                                                      ignore=None)\n\n*Copy the vault’s Obsidian config files into the reference directory and make some nice moodifications\nAs with copy_obsidian_vault_configs, configs_folder is copied into the destination vault / reference_directory / '.obsidian'.\nRaises - FileExistsError - If dirs_exist_ok is False and the destination vault / reference_directory / '.obsidian' already exists.*\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nvault\nPathLike\n\n\n\n\nreference_directory\nPathLike\n\nThe folder into which to copy the Obsidian configs. Relative to vault.\n\n\nconfigs_folder\nPathLike\n\nThe folder containing the Obsidian configs to copy. This is either an absolute path or relative to the current working directory.\n\n\nreference_name\nstr\nNone\nThe name of the reference and the value to change the referenceName field in the fast-link-edit plugin into. If None, then the reference name should be obtained as the name of reference_directory\n\n\ntemplate_location\nstr\n/\nThe location of the template file(s) and the value to change the folder field in the templates plugin into.\n\n\ndirs_exist_ok\nbool\nFalse\nIf dirs_exist_ok is False and the destination folder already exists, then a FileExistsError is raised. If dirs_exist_ok is true, the copying operation will continue if it encounters existing directories, and files within the destination tree will be overwritten by corresponding files from the source tree. See also the shutil.copytree function.\n\n\nignore\nNoneType\nNone\nSee documentation of the shutil.copytree function.\n\n\nReturns\nNone\n\n\n\n\n\n\n# TODO: test\nwith (tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir):\n    temp_vault = Path(temp_dir) / 'test_vault_5'\n    shutil.copytree(_test_directory() / 'test_vault_5', temp_vault)\n\n    # Copy the configs in the folder `.obsidian` at the root of temp_vault into the `number_theory_reference_1` folder\n    copy_obsidian_vault_configs_with_nice_modifications(\n        temp_vault, Path('number_theory') / 'number_theory_reference_1', temp_vault / '.obsidian')\n\n    configs_1 = get_obsidian_vault_plugin_configs(temp_vault / 'number_theory' / 'number_theory_reference_1', 'fast-link-edit', False)\n    configs_2 = get_obsidian_vault_plugin_configs(temp_vault / 'number_theory' / 'number_theory_reference_1', 'templates', True)\n    test_eq(configs_1['referenceName'], 'number_theory_reference_1')\n    test_eq(configs_2['folder'], '/')\n\n    # TODO: test `dirs_exist_ok` being tested.",
    "crumbs": [
      "markdown.obisidian.personal.reference"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.reference.html#setting-up-a-folder-for-a-new-reference",
    "href": "markdown.obsidian.personal.reference.html#setting-up-a-folder-for-a-new-reference",
    "title": "markdown.obisidian.personal.reference",
    "section": "Setting up a folder for a new reference",
    "text": "Setting up a folder for a new reference\nIt takes a lot of time to setup a new reference in my Obsidian Math vault. I need to\n\nMake index notes\nMake notation notes\nMake mathematician notes for authors\nMake template notes\nMake subfolders\nType in titles/subsections in index notes\nMake reference notes\n\n\nsource\n\nsetup_folder_for_new_reference\n\n setup_folder_for_new_reference (reference_name:str, location:os.PathLike,\n                                 authors:Union[str,list[str]],\n                                 vault:os.PathLike, author_folder:os.PathL\n                                 ike='_mathematicians', create_reference_f\n                                 ile_in_references_folder:bool=True, refer\n                                 ences_folder:os.PathLike='_references', c\n                                 reate_template_file_in_templates_folder:b\n                                 ool=True, templates_folder:os.PathLike='_\n                                 templates', template_file_name:str='_temp\n                                 late_common', notation_index_template_fil\n                                 e_name:str='_template_notation_index', gl\n                                 ossary_template_file_name:str='_template_\n                                 glossary', chapters:Optional[list[Union[s\n                                 tr,list[str]]]]=None,\n                                 setup_temp_folder:bool=True, make_second_\n                                 template_file_in_reference_directory:bool\n                                 =True, copy_obsidian_configs:Optional[os.\n                                 PathLike]='.obsidian',\n                                 overwrite:Optional[str]=None,\n                                 confirm_overwrite:bool=True,\n                                 verbose:bool=False)\n\n*Creates and sets up a new folder for a new reference.\nMore specifically, the following are set up:\n\nThe folder\nAn index file\nChapter folders and indices; the folder names are given by convert_title_to_folder_name(&lt;title_with_numbering&gt;) where title_with_numbering is the title of the chapter with its numbering if available, e.g. 1. Introduction.\nFiles in the Mathematicians folder, if applicable.\nA reference file\n\nFor embedding in the standard information notes for the reference\n\nA template file\nA glossary file\nA #_meta/reference tag for the new reference\nA notation index file\nOptionally, a _temp directory\nOptionally, the ./obsidian config folder from the vault is copied.\n\nAfter they are setup, the user should 1. Add content in the reference file. 2. Modify the last line of the template file.\nRaises - FileExistsError - If overwrite is None and a folder of the name reference_name exists at Path(vault) / location.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nreference_name\nstr\n\nThe name of the reference to be created; the folder’s name will be this string.\n\n\nlocation\nPathLike\n\nThe directory of the parent of the new folder to be made, relative to vault.\n\n\nauthors\nUnion\n\nEach str is the family name of each author.\n\n\nvault\nPathLike\n\nThe path to the Obsidian vault in which to make the reference folder.\n\n\nauthor_folder\nPathLike\n_mathematicians\nThe directory where the author files are stored in. Relative to vault.\n\n\ncreate_reference_file_in_references_folder\nbool\nTrue\nIf True, then the reference file creation is attempted within references_folder. Otherwise, the reference file creation is attempted at the base of the newly setup folder for the reference..\n\n\nreferences_folder\nPathLike\n_references\nThe directory where the references files are stored in. Relative to vault.\n\n\ncreate_template_file_in_templates_folder\nbool\nTrue\nIf True, then the template file creation is attempted within templates_folder. Otherwise, the template file creation is attempted at the base of the newly setup folder for the reference.\n\n\ntemplates_folder\nPathLike\n_templates\nThe directory where the template files are stored in. Relative to vault.\n\n\ntemplate_file_name\nstr\n_template_common\nThe template file from which to base the template file of the new reference.\n\n\nnotation_index_template_file_name\nstr\n_template_notation_index\nThe template file from which to base the notation index file of the new reference.\n\n\nglossary_template_file_name\nstr\n_template_glossary\nThe template file from which to base the glossary file of the new reference. Defaults to '_template_glossary'.\n\n\nchapters\nOptional\nNone\nA list where each item is either a str or a list of str. If the item is a str, then it should be the title of a chapter named in the format \"1. {title}\", \"2. {title}\", or \"I. {title}\", \"II. {title}\" etc. If the item is a list of str, then the 0th item should be the title of the chapter, formatted as in the previous sentence, and the other items should be titles of subchapters/subsections, also formatted in the same manner (e.g. if the subchapter is 7.2 of a book, then it should be \"2. {title}\"). Defaults to None, in which case no chapters are specified and hence no chapter folders and indices are created.\n\n\nsetup_temp_folder\nbool\nTrue\nIf True, creates a _temp folder with an index file. This folder serves to house notes auto-created from LaTeX text files before moving them to their correct directories. Defaults to True.\n\n\nmake_second_template_file_in_reference_directory\nbool\nTrue\nIf True, creates a copy of the template note within the directory for the reference.\n\n\ncopy_obsidian_configs\nOptional\n.obsidian\nThe folder relative to vault from which to copy obsidian configs. If None, then no obsidian configs are copied to the reference folder. Defaults to .obsidian.\n\n\noverwrite\nOptional\nNone\nSpecifies if and how to overwrite the reference folder if it already exists. - If 'w', then deletes the contents of the existing reference folder, as well as the template and reference file before setting up the reference folder before creating the new reference folder. - If 'a', then overwrites the contents of the reference folder, but does not remove existing files/folders. - If None, then does not modify the existing reference folder and raises a FileExistsError.\n\n\nconfirm_overwrite\nbool\nTrue\nSpecifies whether or not to confirm the deletion of the reference folder if it already exists and if overwrite is 'w'. Defaults to True.\n\n\nverbose\nbool\nFalse\n\n\n\nReturns\nNone\n\n\n\n\n\nWe can set up a nicely formatted reference folder (without content) with the setup_folder_for_new_reference method. Try uncommenting the os.startfile and os.input lines to see what the vault looks like once the reference is setup.\n\nwith (tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir):\n    temp_vault = Path(temp_dir) / 'test_vault_5'\n    shutil.copytree(_test_directory() / 'test_vault_5', temp_vault)\n\n    chapters= [  # Chapters/sections and sections/subsections of the reference can be set up\n        '0. Having a chapter 0 is fine',\n        ['1. Introduction', '1.1. A subsection'],\n        ['2. Basic ring theory', '2.1. Rings', '2.2. Integral domains', '2.3. Fields', '2.4 Fermat\\'s Little Theorem'],\n        '3. Chapter without subsection',\n        ['A. Appendix: Set theory', 'A.1 Set Axioms', 'A.2 Constructions']\n    ]\n    setup_folder_for_new_reference(\n        reference_name='kim_intro_num_theory', location='number_theory',\n        authors='Kim', vault=temp_vault, chapters=chapters\n        )\n\n    # os.startfile(temp_vault)\n    # input()\n    # TODO: test that files that need to be created have been created.\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In [48], line 12\n      3 shutil.copytree(_test_directory() / 'test_vault_5', temp_vault)\n      5 chapters= [  # Chapters/sections and sections/subsections of the reference can be set up\n      6     '0. Having a chapter 0 is fine',\n      7     ['1. Introduction', '1.1. A subsection'],\n   (...)\n     10     ['A. Appendix: Set theory', 'A.1 Set Axioms', 'A.2 Constructions']\n     11 ]\n---&gt; 12 setup_folder_for_new_reference(\n     13     reference_name='kim_intro_num_theory', location='number_theory',\n     14     authors='Kim', vault=temp_vault, chapters=chapters\n     15     )\n     17 # os.startfile(temp_vault)\n     18 # input()\n     19 # TODO: test that files that need to be created have been created.\n\nCell In [47], line 103, in setup_folder_for_new_reference(reference_name, location, authors, vault, author_folder, create_reference_file_in_references_folder, references_folder, create_template_file_in_references_folder, templates_folder, template_file_name, notation_index_template_file_name, glossary_template_file_name, chapters, setup_temp_folder, make_second_template_file_in_reference_directory, copy_obsidian_configs, overwrite, confirm_overwrite, verbose)\n     93 # for author in authors:\n     94 #     author_file = find_author_file(vault, author, author_folder)\n     95 #     if author_file is None:\n     96 #         print('')  # TODO\n     97 #     author_files.append(author_file)\n     99 _make_reference_file(\n    100     reference_name, references_folder, vault,\n    101     reference_directory, create_reference_file_in_references_folder,\n    102     authors, author_files)\n--&gt; 103 _make_template_file(\n    104     template_file_name, reference_name, vault,\n    105     reference_directory, create_template_file_in_references_folder,\n    106     templates_folder, authors, make_second_template_file_in_reference_directory,\n    107     reference_directory)\n    108 _make_notation_index_file(\n    109     reference_directory, reference_name, vault,\n    110     notation_index_template_file_name, authors)\n    111 _make_glossary_file(\n    112     reference_directory, reference_name, vault,\n    113     glossary_template_file_name)\n\nTypeError: _make_template_file() takes 7 positional arguments but 9 were given\n\n\n\n\n# TODO: test overwrite and confirm_overwrite parameters\n# TODO: give an example of verbose",
    "crumbs": [
      "markdown.obisidian.personal.reference"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.reference.html#getting-the-chapterssections-from-a-file",
    "href": "markdown.obsidian.personal.reference.html#getting-the-chapterssections-from-a-file",
    "title": "markdown.obisidian.personal.reference",
    "section": "Getting the chapters/sections from a file",
    "text": "Getting the chapters/sections from a file",
    "crumbs": [
      "markdown.obisidian.personal.reference"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.reference.html#getting-subfolders-and-index-files-of-a-reference",
    "href": "markdown.obsidian.personal.reference.html#getting-subfolders-and-index-files-of-a-reference",
    "title": "markdown.obisidian.personal.reference",
    "section": "Getting subfolders and index files of a reference",
    "text": "Getting subfolders and index files of a reference\n\nsource\n\nget_index_notes_from_subdirectory\n\n get_index_notes_from_subdirectory (vault:os.PathLike,\n                                    subdirectory:os.PathLike,\n                                    main_index_note:bool=False,\n                                    as_vault_notes:bool=True)\n\nReturns list of index note files for reference\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nvault\nPathLike\n\nThe path to the Obsidian vault directory.\n\n\nsubdirectory\nPathLike\n\nThe path, relative to vault of the subdirectory of of the vault for the reference.\n\n\nmain_index_note\nbool\nFalse\nIf True, include the main index note for the reference. This index note should be in the directory specified by subdirectory.\n\n\nas_vault_notes\nbool\nTrue\nIf True, returns the [VaultNote](https://hyunjongkimmath.github.io/trouver/markdown.obsidian.vault.html#vaultnote) objects for the index notes. Otherwise, returns the paths to the index notes as paths, represented by str.\n\n\nReturns\nlist\n\nEither of the names of the index notes in the vault or of the index notes as VaultNote objects, depending on as_vault_notes.\n\n\n\n\n# TODO: test\n\n\nsource\n\n\nget_index_notes_from_index_note\n\n get_index_notes_from_index_note (vault:os.PathLike, reference_name:str,\n                                  as_vault_notes:bool=True)\n\n*Returns the list of index notes for the reference in the order that they are listed in the reference’s main index note.\nDoes so by searching the “main” index note in the reference folder. Returns the index notes in order that they are listed in the main index note.\nAssumes that the reference folder is “formatted correctly”. This includes the assumption that the main index note for the reference is the unique note named '_index_{reference_name}' in the vault.\nParameters\n\nvault - PathLike\n\nThe path to the Obsidian vault directory\n\nreference_name - str\n\nThe name of the reference folder in the vault.\n\nas_vault_notes - bool\n\nIf True, returns the [VaultNote](https://hyunjongkimmath.github.io/trouver/markdown.obsidian.vault.html#vaultnote) objects for the index notes. Otherwise, returns the paths to the index notes as paths, represented by str. Defaults to True.\n\n\nReturns - list[Union[str, VaultNote]] - Either of the names of the index notes in the vault or of the index notes as VaultNote objects, depending on as_vault_notes.\nSee Also - [get_notes_from_index_note](https://hyunjongkimmath.github.io/trouver/markdown.obsidian.personal.index_notes.html#get_notes_from_index_note) in markdown.obsidian.personal.index_notes.*\n\n# TODO: test",
    "crumbs": [
      "markdown.obisidian.personal.reference"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.reference.html#finding-all-reference-folders-in-a-vault",
    "href": "markdown.obsidian.personal.reference.html#finding-all-reference-folders-in-a-vault",
    "title": "markdown.obisidian.personal.reference",
    "section": "Finding all reference folders in a vault",
    "text": "Finding all reference folders in a vault\n\nsource\n\nreference_folders_in_vault\n\n reference_folders_in_vault (vault:os.PathLike)\n\n*Returns a dict of reference folders in vault.\nParameters - vault - PathLike - The path to the Obsidian vault directory.\nReturns - dict - The keys are str, each of which is the name of a reference. The values are path strings to the reference folder, relative to vault.*\n\n# TODO: example",
    "crumbs": [
      "markdown.obisidian.personal.reference"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.reference.html#getting-files-in-a-reference-folder",
    "href": "markdown.obsidian.personal.reference.html#getting-files-in-a-reference-folder",
    "title": "markdown.obisidian.personal.reference",
    "section": "Getting files in a reference folder",
    "text": "Getting files in a reference folder\n\nsource\n\nfiles_in_reference_folder\n\n files_in_reference_folder (vault:os.PathLike, reference:str,\n                            as_list:bool=False,\n                            search_index_notes:bool=False, exclude_notes_o\n                            f_type:list[trouver.markdown.obsidian.personal\n                            .note_type.PersonalNoteTypeEnum]=None)\n\n*Returns a dict or list of files in a reference folder of a vault.\nTODO: also implement a method to get the files as listed in index notes.\nParameters - vault - PathLike - reference - str - Name of the reference folder in the vault. The folder must have the index note file '_index_{reference}.md', and there must not be two index note files of the same name in the vault. - as_list - bool - If True, then returns a list. Returns a dict otherwise. Defaults to False. - search_index_notes - bool - If True, then gets the notes by looking at the reference’s index notes and returns the notes as ordered by the index notes. - exclude_notes_of_type - list of markdown.obsidian.personal.note_type.PersonalNoteTypeEnum. - The notes of the types specified here will be excluded in the dict or list returned. Defaults to None, in which case\nReturns - list[str] or dict[str, str] - Either a list of path strings or a dict whose keys are str and values are path strings. The keys are the names of the files. The Paths are relative to vault.*\n\n# TODO: examples",
    "crumbs": [
      "markdown.obisidian.personal.reference"
    ]
  },
  {
    "objectID": "helper.packages.html",
    "href": "helper.packages.html",
    "title": "helper.packages",
    "section": "",
    "text": "source\n\n\n\n check_package_installed (package_name:str)\n\n\n# Check for fastai and fastcore\ncheck_package_installed('fastai')\ncheck_package_installed('fastcore')\n\nTrue\n\n\n\nsource\n\n\n\n\n check_package_version_with_version_attribute (package_name:str)\n\n*Checks and returns the version of the specified package if available.\nArgs: package_name (str): The name of the package to check.\nReturns: str or None: The version of the package or None if the package is not available.*\n\n# Example usage\npackage_name = 'fastai'  # Replace with any package name you want to check\nversion = check_package_version_with_version_attribute(package_name)\nif version:\n    print(f\"{package_name} version: {version}\")\nelse:\n    print(f\"{package_name} is not installed or does not have a version attribute.\")\n\nfastai version: 2.7.18",
    "crumbs": [
      "helper.packages"
    ]
  },
  {
    "objectID": "helper.packages.html#detect-packages",
    "href": "helper.packages.html#detect-packages",
    "title": "helper.packages",
    "section": "",
    "text": "source\n\n\n\n check_package_installed (package_name:str)\n\n\n# Check for fastai and fastcore\ncheck_package_installed('fastai')\ncheck_package_installed('fastcore')\n\nTrue\n\n\n\nsource\n\n\n\n\n check_package_version_with_version_attribute (package_name:str)\n\n*Checks and returns the version of the specified package if available.\nArgs: package_name (str): The name of the package to check.\nReturns: str or None: The version of the package or None if the package is not available.*\n\n# Example usage\npackage_name = 'fastai'  # Replace with any package name you want to check\nversion = check_package_version_with_version_attribute(package_name)\nif version:\n    print(f\"{package_name} version: {version}\")\nelse:\n    print(f\"{package_name} is not installed or does not have a version attribute.\")\n\nfastai version: 2.7.18",
    "crumbs": [
      "helper.packages"
    ]
  },
  {
    "objectID": "helper.packages.html#install-package-during-runtime",
    "href": "helper.packages.html#install-package-during-runtime",
    "title": "helper.packages",
    "section": "Install package during runtime",
    "text": "Install package during runtime\n\nsource\n\nensure_package_installed\n\n ensure_package_installed (package_name:str)\n\nCheck if a package is installed and install it if not.\n\nsource\n\n\ninstall_package\n\n install_package (package_name:str)\n\nInstall a package using pip.",
    "crumbs": [
      "helper.packages"
    ]
  },
  {
    "objectID": "markdown.obisidian.personal.authors.html",
    "href": "markdown.obisidian.personal.authors.html",
    "title": "markdown.obsidian.personal.authors",
    "section": "",
    "text": "The convention we use for author names is either &lt;family_name&gt; or &lt;family_name&gt;_&lt;given_name&gt;_&lt;middle_or_other_initial&gt;. The letters are all in lower case and spaces  are replaced with underscores _, but hyphens - are preserved. All accents from names are removed. For example, gauss (for Carl Friedrich Gauss), kim_hyun_jong (for Hyun Jong Kim, the author of trouver; note that his given name is Hyun Jong and his family name is Kim), ellenberg_jordan_s (for Jordan Stuart Ellenberg), doleans-dade_catherine (for Catherine Doléans-Dade), and verdier_jean-louis (for Jean-Louis Verdier) are examples of names formatted under this convention.\n\nsource\n\njust_last_name\n\n just_last_name (author_name)\n\nReturn True if the author’s name is formatted to only have the last name.\n\nsource\n\n\nfind_author_file\n\n find_author_file (vault:os.PathLike, author_name:str,\n                   author_folder:str='mathematicians')\n\n*Return path to the file for the specified author.\nRaises - AssertionError - If author_folder does not exist in vault or if the requirements of author_name are not met.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nvault\nPathLike\n\n\n\n\nauthor_name\nstr\n\nEither just the last name, e.g. \"serre\" or formatted as \"{family_name}_{given_name}_{middle or other initial}\", e.g. \"little_john_b\", \"lockhart_paul\". In the former case, the mathematician’s last name must be unique in the vault. In the latter case, the str must identically match the mathematician’s file name in the vault.\n\n\nauthor_folder\nstr\nmathematicians\nThe directory where the author files are found in, relative to vault.\n\n\nReturns\nOptional\n\nRelative to vault / author_folder. None if no such author file exists.",
    "crumbs": [
      "markdown.obsidian.personal.authors"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.__init__.html",
    "href": "markdown.obsidian.personal.__init__.html",
    "title": "markdown.obisidian.personal",
    "section": "",
    "text": "#default_exp markdown.obsidian.personal.__init__",
    "crumbs": [
      "markdown.obisidian.personal"
    ]
  },
  {
    "objectID": "helper.latex.comments.html",
    "href": "helper.latex.comments.html",
    "title": "helper.latex.comments",
    "section": "",
    "text": "from fastcore.test import test_eq",
    "crumbs": [
      "helper.latex.comments"
    ]
  },
  {
    "objectID": "helper.latex.comments.html#latex-comments",
    "href": "helper.latex.comments.html#latex-comments",
    "title": "helper.latex.comments",
    "section": "LaTeX comments",
    "text": "LaTeX comments\n\nsource\n\nremove_comments\n\n remove_comments (text:str)\n\n\ntext = r\"\"\"% Commands with parameters\n\\newcommand{\\field}[1]{\\mathbb{#1}}\n\\newcommand{\\mat}[4]{\\left[\\begin{array}{cc}#1 & #2 \\\\\n                                         #3 & #4\\end{array}\\right]}\n\\newcommand{\\dual}[1]{#1^{\\vee}}\n\\newcommand{\\compl}[1]{\\hat{#1}}\n\"\"\"\nassert '%' not in remove_comments(text)\nprint(remove_comments(text))\n\ntext = r\"\"\"Hi. I'm not commented. %But I am!\"\"\"\ntest_eq(remove_comments(text), \"Hi. I'm not commented. \")\n\n\n\\newcommand{\\field}[1]{\\mathbb{#1}}\n\\newcommand{\\mat}[4]{\\left[\\begin{array}{cc}#1 & #2 \\\\\n                                         #3 & #4\\end{array}\\right]}\n\\newcommand{\\dual}[1]{#1^{\\vee}}\n\\newcommand{\\compl}[1]{\\hat{#1}}",
    "crumbs": [
      "helper.latex.comments"
    ]
  },
  {
    "objectID": "markdown.obsidian.vault.html",
    "href": "markdown.obsidian.vault.html",
    "title": "markdown.obsidian.vault",
    "section": "",
    "text": "This module generally manages Obsidian.md vaults and their files and folders.\nThe VaultNote class in this module is one of the most essentially classes used in trouver. Generally, one uses Obsidian.md to read and write “notes”, which are .md files. The VaultNote class manages such notes in an Obsidian.md vault.\nSee Also markdown.obsidian.personal.vault.\nimport shutil\nimport tempfile\nfrom unittest import mock\n\nfrom fastcore.test import *\nfrom nbdev.showdoc import show_doc\n\nfrom trouver.helper.tests import _test_directory\nSome examples for this module come from nbs/_tests/vault_1.",
    "crumbs": [
      "markdown.obsidian.vault"
    ]
  },
  {
    "objectID": "markdown.obsidian.vault.html#errors",
    "href": "markdown.obsidian.vault.html#errors",
    "title": "markdown.obsidian.vault",
    "section": "Errors",
    "text": "Errors\n\nsource\n\nNoteNotUniqueError\n\n NoteNotUniqueError (*args, **kwargs)\n\n*A NoteNotUniqueError is raised when a VaultNote is specified by name and not by relative path in the vault, but the vault is found to have multiple notes of the name.\nAttributes\n\nnote_name - str\n\nThe name of the note which is not unique in the vault.\n\nnotes - list[str]\n\nThe paths of the notes whose names are note_name.*\n\n\n\nsource\n\n\nNoteNotUniqueError.from_note_names\n\n NoteNotUniqueError.from_note_names (note_name:str, notes:list[str])\n\nConstruct a NoteNotUniqueError object from note names\n\nsource\n\n\nNoteDoesNotExistError\n\n NoteDoesNotExistError (*args, **kwargs)\n\nA NoteDoesNotExistError is raised when a VaultNote is specified by either name and or by relative path in the vault, but the vault is found to have no notes of the name or path.\n\nsource\n\n\nNoteDoesNotExistError.from_note_name\n\n NoteDoesNotExistError.from_note_name (note_name:str)\n\nConstruct a NoteDoesNotExistError object from note name\n\nsource\n\n\nNoteNotFoundInCacheError\n\n NoteNotFoundInCacheError (*args, **kwargs)\n\nA NoteNotFoundInCacheError is raised when a path corresponding to a VaultNote object is expected to be in the cache, but it is not.\n\nsource\n\n\nNoteNotFoundInCacheError.from_note_name\n\n NoteNotFoundInCacheError.from_note_name (note_name:str)\n\nConstruct a NoteNotFoundInCacheError object from note name\n\nsource\n\n\nNotePathIsNotIdentifiedError\n\n NotePathIsNotIdentifiedError (*args, **kwargs)\n\nA NotePathIsNotIdentifiedError is raised when the rel_path attribute of a VaultNote object is expected to be identified (i.e. a path and not None) but this expectation is not fulfilled.\n\nsource\n\n\nNotePathIsNotIdentifiedError.from_note\n\n NotePathIsNotIdentifiedError.from_note (note)\n\nConstruct a NotePatahIsNotIdentifiedErrro object from a VaultNote.",
    "crumbs": [
      "markdown.obsidian.vault"
    ]
  },
  {
    "objectID": "markdown.obsidian.vault.html#convert-path-to-obsidian-id",
    "href": "markdown.obsidian.vault.html#convert-path-to-obsidian-id",
    "title": "markdown.obsidian.vault",
    "section": "Convert path to Obsidian ID",
    "text": "Convert path to Obsidian ID\n\nsource\n\npath_to_obs_id\n\n path_to_obs_id (rel_path:os.PathLike)\n\n*Convert a relative path of an Obsidian note to the Obsidian identifying str.\nThis identification is for a vault-internal Wikilink.\nNote that this function does not have a vault as a parameter.*\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nrel_path\nPathLike\nA path representation the path of an Obsidian note relative to its vault. This does not have to be an existing path.\n\n\nReturns\nstr\nThe obsidian url of the hypothetical note within its vault. Note that this does not end with the file extension .md.\n\n\n\nObsidian formats its file paths with ‘/’; the path_to_obs_id function converts a relative path of an Obsidian note to the Obsidian-recognized path.\n\ntest_eq(path_to_obs_id(\n    r'some_folder\\some_subfolder\\some_subsubfolder\\some_file.md'),\n    'some_folder/some_subfolder/some_subsubfolder/some_file')\n\nObsidian notes might contain spaces in their paths.\n\ntest_eq(path_to_obs_id(\n    Path(r'some folder\\some subfolder\\some file.md')),\n    r'some folder/some subfolder/some file')",
    "crumbs": [
      "markdown.obsidian.vault"
    ]
  },
  {
    "objectID": "markdown.obsidian.vault.html#example-vault",
    "href": "markdown.obsidian.vault.html#example-vault",
    "title": "markdown.obsidian.vault",
    "section": "Example vault",
    "text": "Example vault",
    "crumbs": [
      "markdown.obsidian.vault"
    ]
  },
  {
    "objectID": "markdown.obsidian.vault.html#get-all-notes",
    "href": "markdown.obsidian.vault.html#get-all-notes",
    "title": "markdown.obsidian.vault",
    "section": "Get all notes",
    "text": "Get all notes\n\nsource\n\nall_paths_to_notes_in_vault\n\n all_paths_to_notes_in_vault (vault:os.PathLike, as_dict:bool=False)\n\n*Return the paths, relative to the Obsidian vault, of notes in the Obsidian vault.\nThis may not actually return all of the paths to the notes, see the parameter as_dict.\nParameters\n\nvault - PathLike\n\nThe path to the Obsidian vault directory\n\nas_dict - bool\n\nIf True, then returns a dict. If False, then returns a list. Defaults to False. If there are multiple notes with the same name in the vault, and as_dict is set to True, then the dictionary will contain only one of the (relative) paths to those notes among its values. If as_dict is set to False, then the list will contain all the paths to the notes even when notes with non-unique names exist.\n\n\nReturns\n\nUnion[list[str], dict[str, str]]\n\nEach str represents the path relative to vault. If as_dict is True, then returns a dict whose keys are str, which are (unique) names of the notes in the vault, and the values are the paths.*\n\n\nThe all_paths_to_notes_in_vault function returns all of the paths to notes in the Obsidian vault; only .md files are recognized as notes.\nBy default, the function returns a list whose items are strings of paths to notes relative to the vault path.\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'test_vault_1'\n    shutil.copytree(_test_directory() / 'test_vault_1', temp_vault)\n\n    # os.startfile(os.getcwd())\n\n    notes = all_paths_to_notes_in_vault(temp_vault)\n    test_eq(len(notes), 9)\n    print(notes)\n    # test_shuffled(, list)\n\n['note_2_with_links_to_note_1.md', 'README.md', '_index.md', 'algebra\\\\ring.md', 'analysis\\\\exponential_function.md', 'category_theory\\\\category.md', 'topology\\\\category.md', 'topology\\\\note_1.md', 'algebra\\\\reference_1\\\\ring.md']\n\n\nPassing as_dict=True returns a dictionary whose keys are note names and whose values are lists of paths to notes of the name relative to the vault.\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'test_vault_1'\n    shutil.copytree(_test_directory() / 'test_vault_1', temp_vault)\n    # os.startfile(os.getcwd())\n\n    notes = all_paths_to_notes_in_vault(temp_vault, as_dict=True)\n    test_eq(len(notes), 7)\n    test_eq(len(notes['ring']), 2)\n    print(notes)\n\n{'note_2_with_links_to_note_1': ['note_2_with_links_to_note_1.md'], 'README': ['README.md'], '_index': ['_index.md'], 'ring': ['algebra\\\\ring.md', 'algebra\\\\reference_1\\\\ring.md'], 'exponential_function': ['analysis\\\\exponential_function.md'], 'category': ['category_theory\\\\category.md', 'topology\\\\category.md'], 'note_1': ['topology\\\\note_1.md']}",
    "crumbs": [
      "markdown.obsidian.vault"
    ]
  },
  {
    "objectID": "markdown.obsidian.vault.html#searching-notes-by-name",
    "href": "markdown.obsidian.vault.html#searching-notes-by-name",
    "title": "markdown.obsidian.vault",
    "section": "Searching notes by name",
    "text": "Searching notes by name\n\nsource\n\nall_note_paths_by_name\n\n all_note_paths_by_name (name:str, vault:os.PathLike,\n                         subdirectory:Optional[os.PathLike]=None)\n\n*Return the relative paths to all notes in the Obsidian vault with the specified name in the specified subdirectory.\nThis function does not assume that the specified subdirectory in the vault has at most one note of the specified name.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nname\nstr\n\nName of the note(s) to find\n\n\nvault\nPathLike\n\nThe path to the Obsidian vault directory\n\n\nsubdirectory\nOptional\nNone\nThe path to a subdirectory in the Obsidian vault, relative to vault. If None, then denotes the root of the vault.\n\n\nReturns\nlist\n\nEach item is a path to a note of the given name, relative to vault.\n\n\n\nBasic usage:\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'test_vault_1'\n    shutil.copytree(_test_directory() / 'test_vault_1', temp_vault)\n\n    notes = all_note_paths_by_name('ring', temp_vault)\n    print('Searched for notes of name `ring`:')\n    print(notes, '\\n')\n    assert len(notes) == 2\n\n    notes = all_note_paths_by_name('exponential_function', temp_vault)\n    print('Searched for notes of name `exponential_function`:')\n    print(notes, '\\n')\n    assert len(notes) == 1\n\n    empty_list = all_note_paths_by_name('non-existent-note-name', temp_vault)\n    print('Searching for a non-existent note name yields an empty list:')\n    print(empty_list)\n    assert len(empty_list) == 0\n\nSearched for notes of name `ring`:\n[Path('algebra/ring.md'), Path('algebra/reference_1/ring.md')] \n\nSearched for notes of name `exponential_function`:\n[Path('analysis/exponential_function.md')] \n\nSearching for a non-existent note name yields an empty list:\n[]\n\n\nWe can specify a subdirectory inside the vault to restrict the search to.\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'test_vault_1'\n    shutil.copytree(_test_directory() / 'test_vault_1', temp_vault)\n\n    all_notes_named_curve_in_vault = all_note_paths_by_name('category', temp_vault)\n    print('All notes named `category`:\\n', all_notes_named_curve_in_vault, '\\n')\n    assert len(all_notes_named_curve_in_vault) == 2\n    for note_path in all_notes_named_curve_in_vault:\n        test_eq(path_name_no_ext(note_path), 'category')\n    \n    print('All notes named `category` in the subdirectory `topology`')\n    notes_named_topology_in_subdirectory = all_note_paths_by_name(\n        'category', temp_vault, 'topology')\n    print(notes_named_topology_in_subdirectory)\n    assert len(notes_named_topology_in_subdirectory) == 1\n    assert path_name_no_ext(notes_named_topology_in_subdirectory[0]) == 'category'\n\nAll notes named `category`:\n [Path('category_theory/category.md'), Path('topology/category.md')] \n\nAll notes named `category` in the subdirectory `topology`\n[Path('topology/category.md')]\n\n\n\nsource\n\n\nnote_path_by_name\n\n note_path_by_name (name:str, vault:os.PathLike,\n                    subdirectory:Optional[os.PathLike]=None,\n                    hints:Optional[list[os.PathLike]]=None)\n\n*Return the path, relative to a subdirectory in the vault, of the note of the specified name.\nRaises\n\nNoteNotUniqueError\n\nIf the note of the specified name is not unique in the subdirectory.\n\nNoteDoesNotExistError\n\nIf the note of the specified name does not exist in the subdirectory.\n\n\nSee Also\n\nThe constructor of the VaultNote class\n\npassing an argument to the name parameter of this constructor method essentially does the same thing as this function, except the constructor method uses a cache.*\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nname\nstr\n\nThe path to the Obsidian vault directory.\n\n\nvault\nPathLike\n\nThe path to a subdirectory in the Obsidian vault. If None, then denotes the root of the vault.\n\n\nsubdirectory\nOptional\nNone\nThe path to a subdirectory in the Obsidian vault. If None, then denotes the root of the vault.\n\n\nhints\nOptional\nNone\nHints of which directories, relative to subdirectory that the note may likely be in. This is for speedup. The directories will be searched in the order listed.\n\n\nReturns\nPath\n\nThe note of the specified name in the specified subdirectory of the vault.\n\n\n\nAssuming that there exists a unique note of a specified name in a vault, we can identify it.\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'test_vault_1'\n    shutil.copytree(_test_directory() / 'test_vault_1', temp_vault)\n\n    note_path = note_path_by_name('exponential_function', temp_vault)\n    print(note_path)\n    test_eq(path_name_no_ext(note_path), 'exponential_function')\n\nanalysis\\exponential_function.md\n\n\nIf there is more than one note in the vault of the specified name, then a NoteNotUniqueError is raised.\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'test_vault_1'\n    shutil.copytree(_test_directory() / 'test_vault_1', temp_vault)\n\n    print(f'The vault has more than one note named `category`:\\n',\n            all_note_paths_by_name('category', temp_vault))\n    with (ExceptionExpected(ex=NoteNotUniqueError, regex='not unique')):\n        note_path_by_name('category', temp_vault)\n\nThe vault has more than one note named `category`:\n [Path('category_theory/category.md'), Path('topology/category.md')]\n\n\nPassing an argument to the parameter subdirectory restricts the search to the subdirectory. A NoteNotUniqueError can be avoided if a subdirectory is specified and if the note of the specified name is unique in the subdirectory.\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'test_vault_1'\n    shutil.copytree(_test_directory() / 'test_vault_1', temp_vault)\n\n    note = note_path_by_name('category', temp_vault, subdirectory='topology')\n    print(note)\n    assert 'topology' in str(note) and path_name_no_ext(note) == 'category'\n\ntopology\\category.md\n\n\nIf there is no note in the vault of the specified name, then a NoteDoesNotExistError is raised.\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'test_vault_1'\n    shutil.copytree(_test_directory() / 'test_vault_1', temp_vault)\n\n    with (ExceptionExpected(ex=NoteDoesNotExistError, regex='does not exist')):\n        note_path_by_name('this_note_does_not_exit', temp_vault)\n\nThe hints parameter\n\nsource\n\n\nnote_name_unique\n\n note_name_unique (name:str, vault:os.PathLike)\n\nReturn True if a note of the specified name exists and is unique in the Obsidian vault.\n\n\n\n\nType\nDetails\n\n\n\n\nname\nstr\nName of the note.\n\n\nvault\nPathLike\nPath to the vault.\n\n\nReturns\nbool\n\n\n\n\nExample use:\n\n# Example demonstration of the note_name_unique function\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    # Create a temporary vault for testing\n    temp_vault = Path(temp_dir) / 'test_vault_1'\n    shutil.copytree(_test_directory() / 'test_vault_1', temp_vault)\n\n    # Check for a note that is known to exist and is unique\n    unique_note_name = 'exponential_function'\n    is_unique = note_name_unique(unique_note_name, temp_vault)\n    print(f\"Is the note '{unique_note_name}' unique in the vault? {is_unique}\")\n    assert is_unique, f\"Expected '{unique_note_name}' to be unique, but it was not.\"\n\n    # Check for a note that is known to exist but is not unique\n    non_unique_note_name = 'category'\n    print(f\"Checking uniqueness for the note '{non_unique_note_name}'...\")\n    is_unique = note_name_unique(non_unique_note_name, temp_vault)\n    print(f\"Is the note '{non_unique_note_name}' unique in the vault? {is_unique}\")\n    assert not is_unique, f\"Expected '{non_unique_note_name}' to not be unique, but it was.\"\n\n    # Check for a note that does not exist\n    nonexistent_note_name = 'this_note_does_not_exist'\n    print(f\"Checking uniqueness for the note '{nonexistent_note_name}'...\")\n    is_unique = note_name_unique(nonexistent_note_name, temp_vault)\n    print(f\"Is the note '{nonexistent_note_name}' unique in the vault? {is_unique}\")\n    assert not is_unique, f\"Expected '{nonexistent_note_name}' to not be unique, but it was.\"\n\nIs the note 'exponential_function' unique in the vault? True\nChecking uniqueness for the note 'category'...\nIs the note 'category' unique in the vault? False\nChecking uniqueness for the note 'this_note_does_not_exist'...\nIs the note 'this_note_does_not_exist' unique in the vault? False",
    "crumbs": [
      "markdown.obsidian.vault"
    ]
  },
  {
    "objectID": "markdown.obsidian.vault.html#getting-note-name-from-its-path",
    "href": "markdown.obsidian.vault.html#getting-note-name-from-its-path",
    "title": "markdown.obsidian.vault",
    "section": "Getting note name from its path",
    "text": "Getting note name from its path\n\nsource\n\nnote_name_from_path\n\n note_name_from_path (note_path:str)\n\nReturn the name of a note from its path.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nnote_path\nstr\nThe path of the note. The note does not need to exist.\n\n\nReturns\nstr\nThe name of the note.\n\n\n\n\nassert note_name_from_path('algebra/ring.md') == 'ring'",
    "crumbs": [
      "markdown.obsidian.vault"
    ]
  },
  {
    "objectID": "markdown.obsidian.vault.html#vaultnote-class",
    "href": "markdown.obsidian.vault.html#vaultnote-class",
    "title": "markdown.obsidian.vault",
    "section": "VaultNote class",
    "text": "VaultNote class\nJust as how paths in Python can be dealt either via strings of paths or via pathlib.Path objects, It is useful to have a class to encapsulate together the name of a note, and its path/Obsidian vault identifier.\n\nsource\n\nVaultNote\n\n VaultNote (vault:os.PathLike, rel_path:os.PathLike=None, name:str=None,\n            subdirectory:Optional[os.PathLike]='',\n            hints:list[os.PathLike]=[], update_cache:Optional[bool]=True)\n\n*Represents a note in an Obsidian vault, without regards to the contents.\nThe note does not have to exist, except in circumstances stating otherwise.\nTODO go through the methods of this class to see which methods assume that the note exists and which do not.\nTODO finish the sentence below. A VaultNote can be specified by either the rel_path or the name argument in its constructor. If name is specified, then the\nTODO implement subdirectory hint\nAttributes\n\nvault - Path\n\nThe (relative or absolute) path of the Obsidian vault that the note is located in.\n\nname - str\n\nThe name of the note in the vault.\n\nrel_path - str\n\nThe note’s path relative to the vault. If\n\ncache - dict[str, dict[str, list[str]]], class attribute\n\nThe keys are string, which are paths to vaults. The corresponding values are dict whose keys are string, which are names in the vault of the (unique) note of that name, and whose values are list of string, which are paths to the note relative to the vault. The cache is not automatically updated when notes are moved, unless the .move_to method or its derivatives are invoked.\n\n\nParameters\n\nvault - PathLike\nrel_path - PathLike\nname - str\n\nThe name of the note in the vault. Defaults to the empty str.\n\nIf None, then the rel_path parameter should be used to determine self.name instead.\nIf not None, then the note must uniquely exist in the vault.\n\n\nsubdirectory - Union[PathLike, None]\nhints - list[PathLike]\n\nRaises\n\nValueError\n\nif rel_path and name are both None.*\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nvault\nPathLike\n\nThe (relative or absolute) path of the Obsidian vault that the note is located in.\n\n\nrel_path\nPathLike\nNone\nThe note’s path relative to the vault. If None, then the name parameter is used to determine the note instead. Defaults to None.\n\n\nname\nstr\nNone\nThe name of the note. If None, then the rel_path parameter is used to determine the note instead. Defaults to None\n\n\nsubdirectory\nOptional\n\nThe relative path to a subdirectory in the Obsidian vault. If None, then denotes the root of the vault. Defaults to the empty str.\n\n\nhints\nlist\n[]\nPaths, relative to subdirectory, to directories where the note file may be found. This is for speedup. Defaults to the empty list, in which case the vault note is searched in all of subdirectory.\n\n\nupdate_cache\nOptional\nTrue\nIf True and if rel_path is not specified (and hence name is specified), update the cache",
    "crumbs": [
      "markdown.obsidian.vault"
    ]
  },
  {
    "objectID": "markdown.obsidian.vault.html#functionsmethods-of-the-vaultnote-class",
    "href": "markdown.obsidian.vault.html#functionsmethods-of-the-vaultnote-class",
    "title": "markdown.obsidian.vault",
    "section": "Functions/Methods of the VaultNote class",
    "text": "Functions/Methods of the VaultNote class\n\nsource\n\nVaultNote.rel_path_identified\n\n VaultNote.rel_path_identified ()\n\nReturn True if self.rel_path is identified, i.e. is a path that is not None.\n\nsource\n\n\nVaultNote.obsidian_identifier\n\n VaultNote.obsidian_identifier ()\n\n*Return the Obsidian identifier of the VaultNote object.\nThis is the note’s unqiue Obsidian id in the vault. This is like a path str with forward slashes / (as opposed to backwards \\ slashes) and without a file extension (.md).*\n\nsource\n\n\nVaultNote.identify_rel_path\n\n VaultNote.identify_rel_path (update_cache=False)\n\n*Sets self.rel_path to a path, if not already done so.\nIf self.rel_path is not already set as a path, then the cache is searched to find a note whose name is self.name (which is necessarily specified).*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nupdate_cache\nbool\nFalse\nIf True, if the cache is searched, and if a note of the specified name is not found in the cache, then the cache is updated and searched again. Defaults to False.\n\n\nReturns\nNone\n\n\n\n\n\n\nsource\n\n\nVaultNote.exists\n\n VaultNote.exists (update_cache=False)\n\n*Returns True if self.rel_path is identified and if the note exists in the vault.\nSetting update_cache to True updates the cache before verifying whether the VaultNote object exists if the VaultNote object is specified by name and not rel_path. Doing so guarantees that the output is correct at the possible cost of runtime.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nupdate_cache\nbool\nFalse\nIf True, then update the cache and try to identify self.rel_path before verifying whether the note exists in the vault.\n\n\nReturns\nbool\n\n\n\n\n\n\nsource\n\n\nVaultNote.path\n\n VaultNote.path (relative=False)\n\n*Returns the path to the note.\nRaises - NotePathIsNotIdentifiedError - If the relative path of self is not identified.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nrelative\nbool\nFalse\nIf True, then return the path relative to the vault. Otherwise, return the absolute path.\n\n\nReturns\nOptional\n\nPath to the note if self.rel_path is deterined. None otherwise.\n\n\n\n\nsource\n\n\nVaultNote.directory\n\n VaultNote.directory (relative=False)\n\nReturn the directory that the note is in.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nrelative\nbool\nFalse\nIf True, then return the path of the directory relative to the vault.\n\n\nReturns\nPath\n\nThe path of the directory that the note is in.\n\n\n\n\nsource\n\n\nVaultNote.create\n\n VaultNote.create ()\n\n*Create the note if it does not exist.\nThe directory of the file needs to be created separately beforehand.\nIf the file exists, then a FileExistsError is raised and the file modification time is not changed.\nRaises\n\nFileExistsError\n\nIf the file already exists.\n\nFileNotFoundError\n\nIf the directory of the file does not already exist.*\n\n\n\nsource\n\n\nVaultNote.delete\n\n VaultNote.delete ()\n\n*Delete the note if it exists.\nThis updates the cache if necessary*\n\nsource\n\n\nVaultNote.move_to\n\n VaultNote.move_to (rel_path:os.PathLike)\n\n*Move/rename the note to the specified location in the vault, assuming that it exists.\nNothing is done if the note does not exist.*\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nrel_path\nPathLike\nThe path in which to rename the path to self as, relative to self.vault.\n\n\nReturns\nNone\n\n\n\n\n\nsource\n\n\nVaultNote.move_to_folder\n\n VaultNote.move_to_folder (rel_dir:os.PathLike)\n\nMove the note to the specified folder in the vault, assuming that it exists.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nrel_dir\nPathLike\nThe path of the directory in which to move self to, relative to self.vault.\n\n\nReturns\nNone\n\n\n\n\n\nsource\n\n\nVaultNote.rename\n\n VaultNote.rename (new_name:str, replace_links_in_vault:bool=True)\n\n*Rename the file underlying self to new_name. The directory that the file is in remains unchanged.\nAssumes that\n\nthe name of self is unique among note names in self.vaults\nNo pre-existing note in vault has new_name as its name. Use the note_name_unique function to check whether or not this is the case.\nthe class’ .cache accurately reflects the files in vault*\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nnew_name\nstr\n\nThe new name to give the note(’s file). Should not include the .md extension.| | replace_links_in_vault | bool | True | IfTrue, then replace the links in the vault pointing tonote` to reflect the new name.\n\n\n\n\nsource\n\n\nVaultNote.text\n\n VaultNote.text ()\n\n*Returns the text contained in the note.\nRaises\n\nNoteDoesNotExistError\n\nIf self does not point to an existing note.*\n\n\n\nsource\n\n\nVaultNote.update_cache\n\n VaultNote.update_cache (vault:os.PathLike)\n\nClass method to update cache for vault by inspecting all files in subdirectories of vault.\n\n\n\n\nType\nDetails\n\n\n\n\nvault\nPathLike\nThe vault.\n\n\nReturns\nNone\n\n\n\n\n\nsource\n\n\nVaultNote.clear_cache\n\n VaultNote.clear_cache ()\n\nClass method to clear out the entire cache for all vaults.\n\nsource\n\n\nVaultNote.unique_name\n\n VaultNote.unique_name (name:str, vault:os.PathLike)\n\nA class method to return a name for a note that is unique in the vault based on a specified name.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nname\nstr\nThe base name for the note.\n\n\nvault\nPathLike\nThe vault\n\n\nReturns\nstr\nA str obtained by appending _{some number} to the end of name.",
    "crumbs": [
      "markdown.obsidian.vault"
    ]
  },
  {
    "objectID": "markdown.obsidian.vault.html#constructing-vaultnote-instances",
    "href": "markdown.obsidian.vault.html#constructing-vaultnote-instances",
    "title": "markdown.obsidian.vault",
    "section": "Constructing VaultNote instances",
    "text": "Constructing VaultNote instances\n\nBy name\nThe most convenient way to construct an existing VaultNote is to specify the vault in which it exists and the note’s name, assuming that the note of the specified name exists and is unique in the specified vault.\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'test_vault_1'\n    shutil.copytree(_test_directory() / 'test_vault_1', temp_vault)\n\n    vault_note = VaultNote(temp_vault, name='exponential_function')\n    assert vault_note.exists()\n    print(vault_note.name)\n    print(f'`vault_note` is located, relative to `vault`, at {vault_note.rel_path}.')\n\nexponential_function\n`vault_note` is located, relative to `vault`, at analysis\\exponential_function.md.\n\n\n\n\nBy relative path\nAlternatively, a VaultNote object can be created by passing an argument to the rel_path parameter. In this case, the note of the specified path does not need to exist.\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'test_vault_1'\n    shutil.copytree(_test_directory() / 'test_vault_1', temp_vault)\n\n    vault_note = VaultNote(temp_vault, rel_path='non_existent_folder/non_existent_note.md')\n    assert not vault_note.exists()\n    # Note that there is not a unique note of name `ring`.\n    vault_note = VaultNote(temp_vault, rel_path='algebra/ring.md')  \n    assert vault_note.exists()\n\nThe rel_path parameter takes precedence over the name parameter.\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'test_vault_1'\n    shutil.copytree(_test_directory() / 'test_vault_1', temp_vault)\n\n    vault_note = VaultNote(temp_vault, rel_path='non_existent_folder/non_existent_note.md', name='ring')\n    assert vault_note.name == 'non_existent_note'\n\nIf the arguments for both the name and the rel_path parameters are None, then a ValueError is raised:\n\ntest_vault = _test_directory() / 'test_vault_1'\nwith ExceptionExpected(ValueError):\n    vault_note = VaultNote(test_vault, rel_path=None, name=None)\n\n\n\nCache of the VaultNote class\nThe VaultNote class keeps a cache of the notes (files with extension .md) in the vault. In pracctice, this cache is updated when a note of the specified name is not found when constructing a VaultNote instance via the name parameter.\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'test_vault_1'\n    shutil.copytree(_test_directory() / 'test_vault_1', temp_vault)\n\n    VaultNote.update_cache(temp_vault)\n    \n    name_of_unique_note = 'exponential_function'\n    assert VaultNote._check_name_exists_and_unique_in_vault_cache(temp_vault, name_of_unique_note) is None\n\n    with ExceptionExpected(ex=NoteNotFoundInCacheError):\n        non_existent_note_name = 'this_note_does_not_exist'\n        VaultNote._check_name_exists_and_unique_in_vault_cache(temp_vault, non_existent_note_name)\n\n    with ExceptionExpected(ex=NoteNotFoundInCacheError):\n        # The following note file is created without using the `VaultNote.cretae` method.\n        # As such, the cache is not updated with this new note.\n        to_create_note_name = 'note_created_without_using_VaultNote_create'\n        open(temp_vault / f'{to_create_note_name}.md', 'w').close()\n        VaultNote._check_name_exists_and_unique_in_vault_cache(temp_vault, to_create_note_name)\n\n    with ExceptionExpected(ex=NoteDoesNotExistError):\n        # The following note file is deleted (without updating the cache).\n        # As such, while the cache indicates that\n        # the file may exist, The `VaultNote._check_name_exists_and_unique_in_vault_cache`\n        # actually checks whether the file exists and concludes that it does not.\n        to_delete_note_name = 'note_1'\n        to_delete_note_rel_path = f'topology/{to_delete_note_name}.md'\n        os.remove(temp_vault / to_delete_note_rel_path)\n        VaultNote._check_name_exists_and_unique_in_vault_cache(temp_vault, to_delete_note_name)\n\n    with ExceptionExpected(ex=NoteNotUniqueError):\n        existent_but_non_unique_note_name = 'ring'\n        VaultNote._check_name_exists_and_unique_in_vault_cache(temp_vault, existent_but_non_unique_note_name)\n\n    with ExceptionExpected(ex=NoteNotUniqueError):\n        # In this example, the note name is not unique. \n        # The note file is also deleted without updating the cache.\n        # Nevertheless, the `VaultNote._check_name_exists_and_unique_in_vault_cache`\n        # determines that the note name is not unique.\n        to_delete_note_name = 'category'\n        to_delete_note_rel_path = f'category_theory/{to_delete_note_name}.md'\n        os.remove(temp_vault / to_delete_note_rel_path)\n        VaultNote._check_name_exists_and_unique_in_vault_cache(temp_vault, to_delete_note_name)\n\n\nVaultNote.clear_cache()\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'test_vault_1'\n    shutil.copytree(_test_directory() / 'test_vault_1', temp_vault)\n\n    assert VaultNote._check_if_cache_needs_to_update(temp_vault, name='ring')\n    VaultNote.update_cache(temp_vault)\n    assert VaultNote._check_if_cache_needs_to_update(temp_vault, name='does_not_exist')\n\n\n\nIdentifying the VaultNote object\nWhen the name parameter (as opposed to the rel_path parameter) is specified in the constructor of a VaultNote object, the constructor looks into the cache of the VaultNote class to identify a note with the specified name in the specified vault. If the cache contains no such note, then the cache is updated and searched again. If the cache still contains no such note, then the rel_path attribute of the VaultNote object is left unidentified (i.e. is set to None).\nAssuming that a note of the specified name is created later, the relative path of the VaultNote object can be identified using the identify_rel_path(update_cache=True) method. Moreover, the rel_path_identified method returns True if the relative path is identified.\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'test_vault_1'\n    shutil.copytree(_test_directory() / 'test_vault_1', temp_vault)\n\n    vn = VaultNote(temp_vault, name='does_not_exist_at_first')\n    assert not vn.rel_path_identified()\n    # Create a note at the root of the vault.\n    open(temp_vault / 'does_not_exist_at_first.md', 'w').close()\n    vn.identify_rel_path(update_cache=True)\n    assert vn.rel_path_identified()\n    assert vn.exists()\n    test_eq(vn.rel_path, 'does_not_exist_at_first.md')",
    "crumbs": [
      "markdown.obsidian.vault"
    ]
  },
  {
    "objectID": "markdown.obsidian.vault.html#getting-information-about-the-note",
    "href": "markdown.obsidian.vault.html#getting-information-about-the-note",
    "title": "markdown.obsidian.vault",
    "section": "Getting information about the note",
    "text": "Getting information about the note\nHere are some convenient ways to get information about the VaultNote:\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'test_vault_1'\n    shutil.copytree(_test_directory() / 'test_vault_1', temp_vault)\n\n    vault_note = VaultNote(temp_vault, name='exponential_function')\n    print(f'Obsidian vault identifier:\\t{vault_note.obsidian_identifier()}')\n    print(f'relative path:\\t{vault_note.rel_path}')\n    print(f'Part of the absolute path of the note:\\t{str(vault_note.path(relative=False))[:7]}')\n    print(f'note name:\\t{vault_note.name}')\n    print(f'directory that the note is in relative to the vault:\\t{vault_note.directory(relative=True)}')\n\nObsidian vault identifier:  analysis/exponential_function\nrelative path:  analysis\\exponential_function.md\nPart of the absolute path of the note:  c:\\User\nnote name:  exponential_function\ndirectory that the note is in relative to the vault:    analysis\n\n\nThe VaultNote.path method raises a NotePathIsNotIdentifiedError if the VaultNote object’s relative path is not idetnfied:\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'test_vault_1'\n    shutil.copytree(_test_directory() / 'test_vault_1', temp_vault)\n\n    vn = VaultNote(temp_vault, name='does_not_exist')\n    with ExceptionExpected(NotePathIsNotIdentifiedError):\n        vn.path()",
    "crumbs": [
      "markdown.obsidian.vault"
    ]
  },
  {
    "objectID": "markdown.obsidian.vault.html#reading-the-contents-of-the-note",
    "href": "markdown.obsidian.vault.html#reading-the-contents-of-the-note",
    "title": "markdown.obsidian.vault",
    "section": "Reading the contents of the note",
    "text": "Reading the contents of the note\nThe VaultNote.text() function reads the contents of the file that the VaultNote object represents, assuming that this file exists. If the file does not exist, then a NoteDoesNotExistError is raised.\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'test_vault_1'\n    shutil.copytree(_test_directory() / 'test_vault_1', temp_vault)\n    vault_note = VaultNote(temp_vault, name='exponential_function')\n    print(vault_note.text())\n    assert len(vault_note.text()) &gt; 10\n\n    vault_note = VaultNote(temp_vault, rel_path='does_not_exist.md')\n    with ExceptionExpected(ex=NoteDoesNotExistError):\n        vault_note.text()\n\nThe **exponential function** is the function sending a complex number $z$ to **$$e^{z} = \\sum_{n=0}^\\infty \\frac{z^n}{n!}$$**. It converges for all $z \\in \\mathbb{C}$.",
    "crumbs": [
      "markdown.obsidian.vault"
    ]
  },
  {
    "objectID": "markdown.obsidian.vault.html#creatingdeletingmoving-the-note",
    "href": "markdown.obsidian.vault.html#creatingdeletingmoving-the-note",
    "title": "markdown.obsidian.vault",
    "section": "Creating/deleting/moving the note",
    "text": "Creating/deleting/moving the note\nIf a VaultNote object represents a non-existent file, then the file can be created with empty content. The cache is updated with this single new entry, but the rest of the cache remains the same.\nIf the file exists, then a FileExistsError is raised.\nIf the specified directory for the file does not exist, then a FileNotFoundError is raised.\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'test_vault_1'\n    shutil.copytree(_test_directory() / 'test_vault_1', temp_vault)\n    vault_note = VaultNote(temp_vault, rel_path='new_file.md')\n    vault_note.create()\n    assert vault_note.exists()\n    assert vault_note.rel_path in VaultNote.cache[str(temp_vault)]['new_file']\n\n    with ExceptionExpected(ex=FileExistsError):\n        vault_note.create() \n\n    vault_note = VaultNote(temp_vault, rel_path='none_existent_folder/new_file.md')\n    with ExceptionExpected(ex=FileNotFoundError):\n        vault_note.create()\n\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'test_vault_1'\n    shutil.copytree(_test_directory() / 'test_vault_1', temp_vault)\n    vault_note = VaultNote(temp_vault, name='exponential_function')\n    vault_note.delete()\n    assert not vault_note.exists()\n    assert vault_note.rel_path not in VaultNote.cache[str(temp_vault)]['exponential_function']\n\nIf a VaultNote object represents an existing file, then the file can be renamed or moved.\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'test_vault_1'\n    shutil.copytree(_test_directory() / 'test_vault_1', temp_vault)\n\n    VaultNote.clear_cache()\n    vault_note = VaultNote(temp_vault, name='exponential_function')\n    vault_note.move_to_folder('')\n    assert vault_note.rel_path == 'exponential_function.md'\n    assert 'exponential_function.md' in VaultNote.cache[str(temp_vault)]['exponential_function']\n\nThe VaultNote.rename function renames the file underlying an existing vault note.\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'test_vault_1'\n    shutil.copytree(_test_directory() / 'test_vault_1', temp_vault)\n    vault_note = VaultNote(temp_vault, name='exponential_function')\n    print(f\"Old path: {vault_note.rel_path}\")\n    vault_note.rename('exp_func')\n\n    expected_path = os.path.normpath('analysis/exp_func.md')\n    actual_path = os.path.normpath(vault_note.rel_path)\n    test_eq(actual_path, expected_path)\n\n    # test_eq(Path(vault_note.rel_path), Path(r'analysis\\exp_func.md'))\n    assert vault_note.exists()\n    print(f\"New path: {vault_note.rel_path}\")\n\nOld path: analysis\\exponential_function.md\nNew path: analysis\\exp_func.md\n\n\nBy default, the rename method replaces links in notes in the vault\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'test_vault_1'\n    shutil.copytree(_test_directory() / 'test_vault_1', temp_vault)\n    vault_note = VaultNote(temp_vault, name='note_1')\n    other_note = VaultNote(temp_vault, name='note_2_with_links_to_note_1')\n    print(f\"Old path: {vault_note.rel_path}\")\n    print(f\"`note_2_with_links_to_note_1` is a note with links to `note_1`. The following is its contents:\")\n    print(other_note.text())\n    vault_note.rename('renamed_note_1')\n\n    assert other_note.exists()\n    print(f\"\\nNew path: {vault_note.rel_path}\")\n    print(f\"After `note_1` is renamed, the following is the contents of `note_2_with_links_to_note_1`:\")\n\n    new_text_in_note_2 = other_note.text()\n    print(new_text_in_note_2)\n    assert '[[renamed_note_1]]' in new_text_in_note_2\n    assert '[[renamed_note_1|hi]]' in new_text_in_note_2\n    assert '[[renamed_note_1#blahblah|hi]]' in new_text_in_note_2\n    assert '![[renamed_note_1|embedded]]' in new_text_in_note_2\n    assert '[asdf](renamed_note_1)' in new_text_in_note_2\n    assert '[asdf](renamed_note_1.md)' in new_text_in_note_2\n\nOld path: topology\\note_1.md\n`note_2_with_links_to_note_1` is a note with links to `note_1`. The following is its contents:\n[[note_1]]\n\n[[note_1|hi]]\n[[note_1#blahblah|hi]]\n\n![[note_1|embedded]]\n\n[asdf](note_1)\n\n[asdf](note_1.md)\n\nNew path: topology\\renamed_note_1.md\nAfter `note_1` is renamed, the following is the contents of `note_2_with_links_to_note_1`:\n[[renamed_note_1]]\n\n[[renamed_note_1|hi]]\n[[renamed_note_1#blahblah|hi]]\n\n![[renamed_note_1|embedded]]\n\n[asdf](renamed_note_1)\n\n[asdf](renamed_note_1.md)\n\n\n\nGetting a unique note name\nIt is troublesome to create a note with a non-unique name. The unique_name method of the VaultNote class takes a tentative name for a note to be created and adds a number to the name so that the note name will be unique in the vault.\n\nwith tempfile.TemporaryDirectory(prefix='temp_dir', dir=os.getcwd()) as temp_dir:\n    temp_vault = Path(temp_dir) / 'test_vault_1'\n    shutil.copytree(_test_directory() / 'test_vault_1', temp_vault)\n    # There is a note named category in the test vault.\n    sample_name = VaultNote.unique_name('category', temp_vault)  \n    assert not VaultNote(temp_vault, name=sample_name).exists()\n\n    sample_name = VaultNote.unique_name('non_existent_note_name', temp_vault)\n    assert not VaultNote(temp_vault, name=sample_name).exists()\n    assert sample_name == 'non_existent_note_name'\n\n\n## Copying files in an `Obsidian.md` vault to and from a subvault\n\n\n# # TODO: use these methods during vault construction for a reference\n# def copy_vault_file_into_subvault(\n#         vault: PathLike, # The Path to the vault from which to copy the files.\n#         subvaults: Union[PathLike, list[PathLike]], # The Paths to the subvaults to which to copy the files.\n#         files: Union[PathLike, list[PathLike]], # The Path to the files, relative to `vault` to copy.\n#         replace: bool = True, # If `True`, replace existing files in `subvaults` if necessary. Defaults to `True`\n#         backup: bool = True, # If `True` and if `replace=True`, create a backup for any replaced files in a subvault in a folder named `.back` in the root directory of the subvault.\n#         ) -&gt; None: \n#     \"\"\"Copy the specified files in `vault` into subvaults.\n\n#     The files are copied within the subvaults to the same relative paths as\n#     they are found in `vault`.\n\n#     Here, \"files\" include directories. If a directory is copied, then all\n#     files and subdirectories of that directory are also copied.\n\n#     **Parameters**\n#     - vault - PathLike\n#         - The path to the Obsidian vault from which to copy files from.\n#     - subvaults - PathLike or list[PathLike]\n#         - The paths to the subvaults to which to copy the files.\n#     - files - PathLike or list[PathLike]\n#         - The files to copy.\n\n#     **Raises**\n#     - FileExistsError\n#         - If `replace` is `False` and some subvault already has a file at\n#           the path in which a file-copy is attempted. In this case, no\n#           files are copied.\n#     - FileNotFoundError\n#         - If a path specified in `files` does not exist in `vault`. In this\n#           case, no files are copied.\n\n#     \"\"\"\n#     vault = Path(vault)\n#     if isinstance(subvaults, PathLike):\n#         subvaults = [subvaults]\n#     if isinstance(files, PathLike):\n\n#         files = [files]\n\n\n#     # TODO: Implement this as a private function \n#     for file in files:\n#         if not os.path.exists(vault / file):\n#             raise FileNotFoundError(\n#                 f\"Attempted to copy files/folders from a vault into subvaults\"\n#                 f\", but there is at least one non-existent files\"\n#                 f\". No files have been copied.\"\n#                 f\"vault: {vault}\"\n#                 f\"file: {file}\")\n\n#     if not replace: \n#         for subvault, file in itertools.product(subvaults, files):\n#             if os.path.exists(subvault / file):\n#                 raise FileExistsError(\n#                     f\"Attempted to copy files/folders from a vault into subvaults\"\n#                     f\", but at least one subvault already has a file that is\"\n#                     f\" supposed to be copied from the vault\"\n#                     f\". No files have been copied.\"\n#                     f\"subvault: {subvault}\"\n#                     f\"file: {file}\")\n    \n#     # TODO: copy and backup files\n\n#     return",
    "crumbs": [
      "markdown.obsidian.vault"
    ]
  },
  {
    "objectID": "44_helper.alphabet.html",
    "href": "44_helper.alphabet.html",
    "title": "trouver",
    "section": "",
    "text": "from string import ascii_uppercase",
    "crumbs": [
      "Alphabet"
    ]
  },
  {
    "objectID": "44_helper.alphabet.html#alphabet",
    "href": "44_helper.alphabet.html#alphabet",
    "title": "trouver",
    "section": "Alphabet",
    "text": "Alphabet\nWith Greek letters typed in LaTeX, I sometimes need to interpret them like their English equivalents, e.g. \\alpha is like A, etc.\n\nsource\n\nalphabet_or_latex_command_to_alphabet_group\n\n alphabet_or_latex_command_to_alphabet_group (character)\n\n\nsource\n\n\nalphabet_or_latex_command_to_alphabet\n\n alphabet_or_latex_command_to_alphabet (character)\n\nReturns the alphabet that the character “corresponds to”.\n\nsource\n\n\nalphabet_to_alphabet_group\n\n alphabet_to_alphabet_group (character)\n\n*Returns the alphabet group\nIn my vaults, I often alphabetize things and also group the alphabet as follows: - A-E - F-J - K-O - P-T - U-V\nParameters - character - str\nReturns - str or None - Returns None if character is not an alphabet.*\n\ndicty = {}\nfor c in ascii_uppercase:\n    dicty[c] = alphabet_to_alphabet_group(c)\nprint(dicty)\n\n{'A': 'A-E', 'B': 'A-E', 'C': 'A-E', 'D': 'A-E', 'E': 'A-E', 'F': 'F-J', 'G': 'F-J', 'H': 'F-J', 'I': 'F-J', 'J': 'F-J', 'K': 'K-O', 'L': 'K-O', 'M': 'K-O', 'N': 'K-O', 'O': 'K-O', 'P': 'P-T', 'Q': 'P-T', 'R': 'P-T', 'S': 'P-T', 'T': 'P-T', 'U': 'U-Z', 'V': 'U-Z', 'W': 'U-Z', 'X': 'U-Z', 'Y': 'U-Z', 'Z': 'U-Z'}",
    "crumbs": [
      "Alphabet"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.notes.html",
    "href": "markdown.obsidian.personal.notes.html",
    "title": "markdown.obisidian.personal.notes",
    "section": "",
    "text": "from fastcore.test import *\nfrom trouver.helper.tests import _test_directory",
    "crumbs": [
      "markdown.obisidian.personal.notes"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.notes.html#get-notes-linked-in-notes",
    "href": "markdown.obsidian.personal.notes.html#get-notes-linked-in-notes",
    "title": "markdown.obisidian.personal.notes",
    "section": "Get notes linked in notes",
    "text": "Get notes linked in notes\n\nsource\n\nnotes_linked_in_notes_linked_in_note\n\n notes_linked_in_notes_linked_in_note\n                                       (list_note:trouver.markdown.obsidia\n                                       n.vault.VaultNote,\n                                       as_dict:bool=True)\n\nReturns a list or dict of VaultNotes of notes linked by notes which are linked by a specified note.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nlist_note\nVaultNote\n\nThe VaultNote with links to notes containing the links to obtain.\n\n\nas_dict\nbool\nTrue\nIf True, returns a dict. Returns a list otherwise.\n\n\nReturns\nUnion\n\nIf dict, the keys are the names of the vault notes and the values are the VaultNote objects. If list, then the entries are the VaultNote objects.\n\n\n\n\nsource\n\n\nnotes_linked_in_note\n\n notes_linked_in_note\n                       (list_note:trouver.markdown.obsidian.vault.VaultNot\n                       e, as_dict:bool=True)\n\nReturns a list or dict of VaultNotes of notes linked by a specified note.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nlist_note\nVaultNote\n\nThe VaultNote in which to find the links.\n\n\nas_dict\nbool\nTrue\nIf True, returns a dict. Returns a list otherwise.\n\n\nReturns\nUnion\n\nIf dict, the keys are the names of the vault notes and the values are the VaultNote objects. If list, then the entries are the VaultNote objects.\n\n\n\n\n# notes_linked_in_note(VaultNote(VAULT, name='ml_data_note_type_categorization'))\ntest_vault = _test_directory() / 'test_vault_3'\nindex_note = VaultNote(test_vault, name='_index_1_chapter_reference_1')\n\nnotes_as_dict = notes_linked_in_note(index_note)\nassert isinstance(notes_as_dict, dict)\ntest_eq(len(notes_as_dict), 12)\nfor name, note in notes_as_dict.items():\n    assert note.name == name\nprint(notes_as_dict)\n\nnotes_as_list = notes_linked_in_note(index_note)\ntest_eq(len(notes_as_list), 12)\nprint(notes_as_list)\n# print(notes)\n\n{'note_11': &lt;trouver.markdown.obsidian.vault.VaultNote object&gt;, 'note_12': &lt;trouver.markdown.obsidian.vault.VaultNote object&gt;, 'note_13': &lt;trouver.markdown.obsidian.vault.VaultNote object&gt;, 'note_14': &lt;trouver.markdown.obsidian.vault.VaultNote object&gt;, 'note_15': &lt;trouver.markdown.obsidian.vault.VaultNote object&gt;, 'note_16': &lt;trouver.markdown.obsidian.vault.VaultNote object&gt;, 'note_17': &lt;trouver.markdown.obsidian.vault.VaultNote object&gt;, 'note_18': &lt;trouver.markdown.obsidian.vault.VaultNote object&gt;, 'note_19': &lt;trouver.markdown.obsidian.vault.VaultNote object&gt;, 'note_110': &lt;trouver.markdown.obsidian.vault.VaultNote object&gt;, 'note_111': &lt;trouver.markdown.obsidian.vault.VaultNote object&gt;, 'note_112': &lt;trouver.markdown.obsidian.vault.VaultNote object&gt;}\n{'note_11': &lt;trouver.markdown.obsidian.vault.VaultNote object&gt;, 'note_12': &lt;trouver.markdown.obsidian.vault.VaultNote object&gt;, 'note_13': &lt;trouver.markdown.obsidian.vault.VaultNote object&gt;, 'note_14': &lt;trouver.markdown.obsidian.vault.VaultNote object&gt;, 'note_15': &lt;trouver.markdown.obsidian.vault.VaultNote object&gt;, 'note_16': &lt;trouver.markdown.obsidian.vault.VaultNote object&gt;, 'note_17': &lt;trouver.markdown.obsidian.vault.VaultNote object&gt;, 'note_18': &lt;trouver.markdown.obsidian.vault.VaultNote object&gt;, 'note_19': &lt;trouver.markdown.obsidian.vault.VaultNote object&gt;, 'note_110': &lt;trouver.markdown.obsidian.vault.VaultNote object&gt;, 'note_111': &lt;trouver.markdown.obsidian.vault.VaultNote object&gt;, 'note_112': &lt;trouver.markdown.obsidian.vault.VaultNote object&gt;}\n\n\n\ntest_vault = _test_directory() / 'test_vault_3'\nindex_note = VaultNote(test_vault, name='_index_reference_1')\n\n# This gets all the notes linked in the notes linked in `index_reference_1`.\n# In other words, this gets all the notes linked in \n# - `_index_1_chapter_reference_1`\n# - `_index_2_chapter_reference_1`, and\n# - `_index_3_chapter_reference_1`.\nnotes_as_dict = notes_linked_in_notes_linked_in_note(index_note)\nassert isinstance(notes_as_dict, dict)\ntest_eq(len(notes_as_dict), 17)\nfor name, note in notes_as_dict.items():\n    assert note.name == name\nassert 'note_without_a_section' in notes_as_dict\nassert \"note_titles don't really need much structure\" in notes_as_dict\n\n\nnotes_as_list = notes_linked_in_notes_linked_in_note(index_note)\ntest_eq(len(notes_as_list), 17)",
    "crumbs": [
      "markdown.obisidian.personal.notes"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.notes.html#tags-in-notes",
    "href": "markdown.obsidian.personal.notes.html#tags-in-notes",
    "title": "markdown.obisidian.personal.notes",
    "section": "Tags in notes",
    "text": "Tags in notes\n\nsource\n\nnote_has_tag\n\n note_has_tag (note:trouver.markdown.obsidian.vault.VaultNote, tag:str)\n\nReturns True if the note has the specified tag in its yaml frontmatter meta.\n\n\n\n\nType\nDetails\n\n\n\n\nnote\nVaultNote\n\n\n\ntag\nstr\nWithout the hashtag '#'.\n\n\nReturns\nbool\n\n\n\n\n\ntest_vault = _test_directory() / 'test_vault_3'\nnote = VaultNote(test_vault, name='i_am_an_independent_note_who_does_not_need_a_folder_and_that_is_okay_too')\n\nassert note_has_tag(note, \"this_is_a_tag\")\nassert not note_has_tag(note, \"this_is_also_a_tag\") # Although `#this_is_also_a_tag` is in the note, it is note in the yaml frontmatter meta.\nassert note_has_tag(note, \"this_is_a_tag/this_is_a_subtag\")\nassert not note_has_tag(note, \"this_tag_is_not_in_the_note\")",
    "crumbs": [
      "markdown.obisidian.personal.notes"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.notation.parse.html",
    "href": "markdown.obsidian.personal.notation.parse.html",
    "title": "markdown.obsidian.personal.notation.parse",
    "section": "",
    "text": "from fastcore.test import *\nfrom trouver.helper.tests import _test_directory\n\n\nParse notation note\nFor the purposes of trouver, a notation note most usually starts in the format &lt;Notation&gt; [[&lt;link_to_note&gt;|denotes]] &lt;explanation of what that notation denotes/is defined as&gt; &lt;optional paragraphs discussing aspects about the notation&gt;. For example, “\\(\\deg D\\) [[note_link|denotes]] the degree of the divisor \\(D\\)” would be an example of such a note.\nIf the word denotes is not given in a link to a note, then the note to which the first link points is considered the main note of the notation note. Alternatively, a notation note might also sometimes have a comment citing the source of the notation instead of links. Nevertheless, it is preferred that denotes is given in a link.\nA notation note may have YAML frontmatter meta as well.\n\ntest_eq(['hi'], ['hi'])\n\n\nsource\n\nparse_notation_note\n\n parse_notation_note\n                      (notation_note:Union[str,trouver.markdown.obsidian.v\n                      ault.VaultNote], vault:Optional[os.PathLike]=None)\n\n*Parse information from the notation note.\nReturns\n\ntuple[Union[dict, None], str, ObsidianLink, MarkdownFile, list[tuple[str, str]]]\n\nThe first entry is the YAML frontmatter meta, if available.\nThe second entry is the notation string\nThe third entry is the name of the “main note” of the notation note. This is usual the linked note in the link [[&lt;linked_note&gt;|denotes]]. If no such main note exists, then this is None.\nThe fourth entry is the MarkdownFile consisting of the “main” content of the note, which excludes the information given by all of the other entries.\nThe fifth entry is a list of tuples of two str’s representing a bulleted list of notation notes to which notation_note links to. Each tuple is of the form (latex_str, notation_note_name) and the corresponding entry in the bulleted list is of the form - [&lt;latex_str&gt;](&lt;notation_note_name).\n\n\nRaises\n\nUserWarning\n\nIf the (non-YAML frontmatter meta) contents of the note do not start inn the form &lt;Notation&gt; [[&lt;link_to_note&gt;|denotes]]; the name of the notation note is included in the warning message.\n\nValueError\n\nIf the notation note is not formatted correctly by starting with the notation with dollar signs $.\n\nAssertionError\n\nIf notation_note is not determined to be a notation note.*\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nnotation_note\nUnion\n\n\n\n\nvault\nOptional\nNone\nThe vault If None, then uses notation_note.vault\n\n\nReturns\ntuple\n\n\n\n\n\nparse_notation_note gets information about the notation note. Note that the MarkdownFile object main_mf that has the main content/description of the notation does not start with the pharse of the form &lt;notation&gt; [[&lt;link&gt;|denotes]].\n\nvault = _test_directory() / 'test_vault_7'\nnotation_note = VaultNote(vault, name='some_reference_name_notation_Spec_A')\nmetadata, notation_str, main_of_notation, main_mf, linked_notat_notes = parse_notation_note(notation_note, vault)\n\ntest_eq(metadata, {'detect_regex': [], 'latex_in_original': ['\\\\operatorname{Spec} A']})\ntest_eq(notation_str, '$\\\\operatorname{Spec} A$')\ntest_eq(main_of_notation, 'spectrum_of_a_ring')\ntest_eq(str(main_mf), 'the spectrum of the ring $A$.')\ntest_eq(linked_notat_notes, []) # There is not a bulleted list at the end, so the last output is `None`.\n\n\nvault = _test_directory() / 'test_vault_7'\nnotation_note = VaultNote(vault, name='poonen_curves_notation_zeta_X_s_zeta_function_of_variety')\nmetadata, notation_str, main_of_notation, main_mf, linked_notat_notes = parse_notation_note(notation_note, vault)\n\ntest_eq(metadata, None)\ntest_eq(notation_str, r'$\\zeta_{X}(s)$')\ntest_eq(main_of_notation, 'poonen_curves_3.4.1 DEFINITION')\ntest_eq(str(main_mf), 'the zeta function of the [[poonen_curves_1.0.2 DEFINITION|variety]] $X$ over $\\\\mathbb{F}_q$.\\n\\nIt is defined as\\n\\n$$\\\\zeta_X(s) = Z_X(q^{-s}).$$\\n\\nA priori, it is a formal series, but in fact [[poonen_curves_ 3.6_page_56|it converges]] for $\\\\operatorname{Re} s &gt; \\\\dim X$.')\ntest_eq(linked_notat_notes, [('$Z_X$', 'poonen_curves_notation_Z_X_T')]) # There is a bulleted list at the end, so the last output is `None`.\n\n\nsource\n\n\nnotation_in_note\n\n notation_in_note\n                   (notation_note:Union[str,trouver.markdown.obsidian.vaul\n                   t.VaultNote], vault:Optional[os.PathLike]=None)\n\n*Return the name of the note from which the notation comes from.\nParameters\n\nnotation_note - Union[str, VaultNote]\n\nEither\n\nThe name of the notation note or\nThe VaultNote object of the notation note.\n\n\nThe note name is expected to be unique inside the vault specified by vault. This is expected to contain 'notation' as a substring. Usually, this is expected to be formatted in one of the following forms: - '&lt;reference_name&gt;_notation_&lt;rest_of_note_name&gt;' - `‘notation.’\nvault - Pathlike or None\n\nDefaults to None\n\n\nReturns\n\nstr\n\nThe notation in LaTeX, including the dollar signs $.\n\n\nRaises*\nnotation_in_note identifies the notation LaTeX str that a notation note presents. Its output starts and ends with dollar signs.\n\nvault = _test_directory() / 'test_vault_7'\nnotation_note = VaultNote(vault, name='some_reference_name_notation_Spec_A')\nnotation = notation_in_note(notation_note)\nassert notation == r'$\\operatorname{Spec} A$'\n\n\nsource\n\n\nmain_of_notation\n\n main_of_notation\n                   (notation_note:trouver.markdown.obsidian.vault.VaultNot\n                   e, as_note:bool=False)\n\n*Return the name of the note from which the notation comes from.\nRaises\n\nValueError\n\nIf the notation note is not formatted correctly by starting with the notation with dollar signs $.*\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nnotation_note\nVaultNote\n\nThe VaultNote object representing the notation note.\n\n\nas_note\nbool\nFalse\nIf False, then returns the name of the note, and returns a VaultNote object with the same vault as notation_note otherwise. The vault used to get the VaultNote is the vault of notation_note.\n\n\nReturns\nUnion\n\nThe (name of the) main information note that notation_note comes from. Returns None if notation_note does not come from such a note.\n\n\n\nWe can identify the “main note” of a notation note with the main_of_notation method:\n\nvault = _test_directory() / 'test_vault_7'\nnotation_note = VaultNote(vault, name='some_reference_name_notation_Spec_A')\ntest_eq(main_of_notation(notation_note), 'spectrum_of_a_ring')\n\nWe can also return this main note as a VaultNote object:\n\nvault = _test_directory() / 'test_vault_7'\nnotation_note = VaultNote(vault, name='some_reference_name_notation_Spec_A')\nmain_note =  main_of_notation(notation_note, as_note=True)\nassert isinstance(main_note, VaultNote)\ntest_eq(main_note.name, 'spectrum_of_a_ring')\n\nIf the notation note has no links, then main_of_notation returns None:\n\nvault = _test_directory() / 'test_vault_7'\nnotation_note = VaultNote(vault, name='some_reference_name_notation_O_X_this_file_has_no_links')\nmain_note =  main_of_notation(notation_note)\nassert main_note is None\n\nmain_note = main_of_notation(notation_note, as_note=True)\nassert main_note is None",
    "crumbs": [
      "markdown.obsidian.personal.notation.parse"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.machine_learning.notation_identification.html",
    "href": "markdown.obsidian.personal.machine_learning.notation_identification.html",
    "title": "markdown.obisidian.personal.machine_learning.notation_identification",
    "section": "",
    "text": "from unittest import mock\nimport shutil\nimport tempfile\n\nfrom fastcore.test import *\nfrom pathvalidate import validate_filename \nfrom torch import Tensor\n\nfrom trouver.helper.tests import _test_directory",
    "crumbs": [
      "markdown.obisidian.personal.machine_learning.notation_identification"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.machine_learning.notation_identification.html#get-notation-data",
    "href": "markdown.obsidian.personal.machine_learning.notation_identification.html#get-notation-data",
    "title": "markdown.obisidian.personal.machine_learning.notation_identification",
    "section": "Get notation data",
    "text": "Get notation data\nGiven information notes with notations marked with double asterisks **, we extract the data of these double asterisks organize them for machine learning.\nUltimately, we would like to have a ML model that can find the locations where notations are newly introduced in a note. The approach here is to train a categorization model which takes an input a text with a single double asterisk pair surrounding a LaTeX math mode string and outputs whether the LaTeX math mode string contains a notation. We then use the categorization model to find all LaTeX math mode strings containing notations one by one.\n\nsource\n\nadd_one_double_asts_to_line\n\n add_one_double_asts_to_line (line:str, start:int, end:int)\n\n*Return line with only one double asterisks ** surrounded text.\nUsed in _definition_data_from_line*\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nline\nstr\nThe text to which to add the double asterisks **\n\n\nstart\nint\nThe first double asterisks are added in between line[start-1] and line[start].\n\n\nend\nint\nThe second double asterisks are added in between line[end-1] and line[end].\n\n\nReturns\nstr\nThe str obtained from line by surrounding the substring line[start:end] with double asterisks.\n\n\n\n\ntest_eq(add_one_double_asts_to_line(\"I will add just one double ast pair.\", 2,6), 'I **will** add just one double ast pair.')\n\n\nsource\n\n\nnotation_data_from_text\n\n notation_data_from_text (with_double_asts:str)\n\n*Extracts data on the locations of notations in a text with double asterisks.\nUsed in notation_data_from_note\nReturns\n\ntuple[str, list[tuple[int, int, bool]]]\n\nThe str is the str no_double_asts, which is the same as with_double_asts, except with the double asterisks removed.\nEach list represents a data point for a LaTeX math-mode string in no_double_astsand consists of\n\nThe indices start, end where the data point considers whether or not the LaTeX math-mode substring line_no_double_asts[start:end] is surrounded by double-asterisks (and hene is supposed to introduce a notation).\nA bool which is True, if the data-point represents a str with double-asterisks surrounding a notation and False otherwise.*\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nwith_double_asts\nstr\nMay or may not have double asterisks to signify definitions and notations\n\n\nReturns\ntuple\n\n\n\n\n\nsample_output = notation_data_from_text(\n    r'**here is a double ast text**. It is not a LaTeX math mode string,'\n    r'so it will not be included as a data point.'\n    r'On the other hand, **$\\operatorname{Gal}(L/K)$** and $\\mathbb{Z}/2\\mathbb{Z}$'\n    r'are both included LaTeX math mode strings and are included as data points.'\n    r'The bool for the former is `True`, whereas the bool for the latter is `False`.')\n\nassert '**' not in sample_output[0]\nstart, end, is_notation = sample_output[1][0]\ntest_eq(sample_output[0][start:end], r'$\\operatorname{Gal}(L/K)$')\nstart, end, is_notation = sample_output[1][1]\ntest_eq(sample_output[0][start:end], r'$\\mathbb{Z}/2\\mathbb{Z}$')\nprint(sample_output)\n\n('here is a double ast text. It is not a LaTeX math mode string,so it will not be included as a data point.On the other hand, $\\\\operatorname{Gal}(L/K)$ and $\\\\mathbb{Z}/2\\\\mathbb{Z}$are both included LaTeX math mode strings and are included as data points.The bool for the former is `True`, whereas the bool for the latter is `False`.', [(124, 149, True), (154, 178, False)])\n\n\n\nsource\n\n\nnotation_data_from_note\n\n notation_data_from_note (note:trouver.markdown.obsidian.vault.VaultNote,\n                          vault:os.PathLike)\n\n*Obtain notation data from a note.\nNote that the lists of str might not be in any particular order.\nReturns\n\nlist[tuple[str, str, bool]]\n\nEach list consists of\n\nThe name of note,\nThe processed str of note with only a single double asterisk surrounded LaTeX text. Note that the processed str merges display math mode text into single lines, cf. process_standard_information_note.\nA bool that is True if the LaTeX text contains notation.*\n\n\n\nWe first set up an example:\n\ntest_vault = _test_directory() / 'test_vault_6'\nvn = VaultNote(test_vault, name='reference_with_tag_labels_Definition 2')\nprint(vn.text())\n\n---\ncssclass: clean-embeds\naliases: []\ntags: [_meta/literature_note, _meta/definition, _meta/notation]\n---\n# Ring of integers modulo $n$[^1]\n\nLet $n \\geq 1$ be an integer. The **ring of integers modulo $n$**, denoted by **$\\mathbb{Z}/n\\mathbb{Z}$**, is, informally, the ring whose elements are represented by the integers with the understanding that $0$ and $n$ are equal.\n\nMore precisely, $\\mathbb{Z}/n\\mathbb{Z}$ has the elements $0,1,\\ldots,n-1$.\n\n...\n\n\n# See Also\n- [[reference_with_tag_labels_Exercise 1|reference_with_tag_labels_Z_nZ_is_a_ring]]\n# Meta\n## References\n\n## Citations and Footnotes\n[^1]: Kim, Definition 2\n\n\n\nsample_output = notation_data_from_note(vn, test_vault)\ntotal_count_for_is_notation = 0\nfor name, with_one_double_asts, is_notation in sample_output:\n    test_eq(name, vn.name)\n    test_eq(with_one_double_asts.count('**'), 2)\n    if is_notation:\n        total_count_for_is_notation += 1\ntest_eq(total_count_for_is_notation, 1)\nsample_output\n\nC:\\Users\\hyunj\\Documents\\Development\\Python\\trouver\\trouver\\helper\\html.py:81: MarkupResemblesLocatorWarning: The input looks more like a filename than markup. You may want to open this file and pass the filehandle into Beautiful Soup.\n  parsed_soup = BeautifulSoup(text, 'html.parser')\n\n\n[('reference_with_tag_labels_Definition 2',\n  'Let $n \\\\geq 1$ be an integer. The ring of integers modulo $n$, denoted by **$\\\\mathbb{Z}/n\\\\mathbb{Z}$**, is, informally, the ring whose elements are represented by the integers with the understanding that $0$ and $n$ are equal.\\n\\nMore precisely, $\\\\mathbb{Z}/n\\\\mathbb{Z}$ has the elements $0,1,\\\\ldots,n-1$.\\n\\n...\\n',\n  True),\n ('reference_with_tag_labels_Definition 2',\n  'Let **$n \\\\geq 1$** be an integer. The ring of integers modulo $n$, denoted by $\\\\mathbb{Z}/n\\\\mathbb{Z}$, is, informally, the ring whose elements are represented by the integers with the understanding that $0$ and $n$ are equal.\\n\\nMore precisely, $\\\\mathbb{Z}/n\\\\mathbb{Z}$ has the elements $0,1,\\\\ldots,n-1$.\\n\\n...\\n',\n  False),\n ('reference_with_tag_labels_Definition 2',\n  'Let $n \\\\geq 1$ be an integer. The ring of integers modulo **$n$**, denoted by $\\\\mathbb{Z}/n\\\\mathbb{Z}$, is, informally, the ring whose elements are represented by the integers with the understanding that $0$ and $n$ are equal.\\n\\nMore precisely, $\\\\mathbb{Z}/n\\\\mathbb{Z}$ has the elements $0,1,\\\\ldots,n-1$.\\n\\n...\\n',\n  False),\n ('reference_with_tag_labels_Definition 2',\n  'Let $n \\\\geq 1$ be an integer. The ring of integers modulo $n$, denoted by $\\\\mathbb{Z}/n\\\\mathbb{Z}$, is, informally, the ring whose elements are represented by the integers with the understanding that **$0$** and $n$ are equal.\\n\\nMore precisely, $\\\\mathbb{Z}/n\\\\mathbb{Z}$ has the elements $0,1,\\\\ldots,n-1$.\\n\\n...\\n',\n  False),\n ('reference_with_tag_labels_Definition 2',\n  'Let $n \\\\geq 1$ be an integer. The ring of integers modulo $n$, denoted by $\\\\mathbb{Z}/n\\\\mathbb{Z}$, is, informally, the ring whose elements are represented by the integers with the understanding that $0$ and **$n$** are equal.\\n\\nMore precisely, $\\\\mathbb{Z}/n\\\\mathbb{Z}$ has the elements $0,1,\\\\ldots,n-1$.\\n\\n...\\n',\n  False),\n ('reference_with_tag_labels_Definition 2',\n  'Let $n \\\\geq 1$ be an integer. The ring of integers modulo $n$, denoted by $\\\\mathbb{Z}/n\\\\mathbb{Z}$, is, informally, the ring whose elements are represented by the integers with the understanding that $0$ and $n$ are equal.\\n\\nMore precisely, **$\\\\mathbb{Z}/n\\\\mathbb{Z}$** has the elements $0,1,\\\\ldots,n-1$.\\n\\n...\\n',\n  False),\n ('reference_with_tag_labels_Definition 2',\n  'Let $n \\\\geq 1$ be an integer. The ring of integers modulo $n$, denoted by $\\\\mathbb{Z}/n\\\\mathbb{Z}$, is, informally, the ring whose elements are represented by the integers with the understanding that $0$ and $n$ are equal.\\n\\nMore precisely, $\\\\mathbb{Z}/n\\\\mathbb{Z}$ has the elements **$0,1,\\\\ldots,n-1$**.\\n\\n...\\n',\n  False)]",
    "crumbs": [
      "markdown.obisidian.personal.machine_learning.notation_identification"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.machine_learning.notation_identification.html#make-database-of-notation-data",
    "href": "markdown.obsidian.personal.machine_learning.notation_identification.html#make-database-of-notation-data",
    "title": "markdown.obisidian.personal.machine_learning.notation_identification",
    "section": "Make database of notation data",
    "text": "Make database of notation data\n\nsource\n\nappend_notation_data_to_database\n\n append_notation_data_to_database (vault:os.PathLike, file:os.PathLike,\n                                   notes:list[trouver.markdown.obsidian.va\n                                   ult.VaultNote], backup:bool=True)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nvault\nPathLike\n\nThe vault from which the data is drawn\n\n\nfile\nPathLike\n\nThe path to a CSV file\n\n\nnotes\nlist\n\nThe notes to add to the database\n\n\nbackup\nbool\nTrue\nIf True, makes a copy of file in the same directoy and with the same name, except with an added extension of .bak.\n\n\nReturns\nNone\n\n\n\n\n\n\n# TODO: example",
    "crumbs": [
      "markdown.obisidian.personal.machine_learning.notation_identification"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.machine_learning.notation_identification.html#use-ml-categorization-model-to-find-and-mark-notations-in-notes",
    "href": "markdown.obsidian.personal.machine_learning.notation_identification.html#use-ml-categorization-model-to-find-and-mark-notations-in-notes",
    "title": "markdown.obisidian.personal.machine_learning.notation_identification",
    "section": "Use ML categorization model to find and mark notations in notes",
    "text": "Use ML categorization model to find and mark notations in notes\n\nsource\n\nautomatically_mark_notations\n\n automatically_mark_notations\n                               (vn:trouver.markdown.obsidian.vault.VaultNo\n                               te, learn:fastai.text.learner.TextLearner,\n                               create_notation_notes:bool=False,\n                               reference_name:str='')\n\n*Predict and mark where notations occur in a note, and optionally create a notation note, and add the notation note to the See Also section of the note.\nAssumes that no double asterisks are already in the contents of vn.\nThis function Removes links, headings, footnotes, etc. from the original note and merges multi-line display math mode LaTeX text into single lines. Use with caution.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nvn\nVaultNote\n\nThe information note to which to mark notations.\n\n\nlearn\nTextLearner\n\nThe ML model which predicts where notation notes should occur. This is a classifier which takes as input a str with double asterisks surrounding LaTeX text. The model outputs whether or not the single double asterisk pair surrounds a LaTeX text with notation.\n\n\ncreate_notation_notes\nbool\nFalse\nIf True, creates the notations notes for the predicted notations and links them to the ‘See Also’ sections of the information notes.\n\n\nreference_name\nstr\n\nThe name of the reference that vn belongs to; this is only relevant when create_notation_notes=True so that the created notation notes have file names starting with the reference name.\n\n\nReturns\nNone\n\n\n\n\n\n\n# TODO: Test\n\n\nwith tempfile.TemporaryDirectory(prefix='tmp_dir_', dir=os.getcwd()) as tmp_dir:\n    tmp_dir = Path(tmp_dir)\n    temp_vault = tmp_dir / 'test_vault_6'\n    shutil.copytree('_tests/test_vault_6', temp_vault)\n\n    note = VaultNote(temp_vault, name='number_theory_reference_1_Definition 15')\n\n    with mock.patch('__main__.TextLearner') as mock_textlearner_class:\n        mock_textlearner = mock_textlearner_class.return_value\n        mock_textlearner.predict.side_effect = [\n            ('False', Tensor([0]), Tensor([1, 0])),\n            ('True', Tensor([0]), Tensor([0, 1])),\n            ('False', Tensor([0]), Tensor([1, 0])),\n            ('False', Tensor([0]), Tensor([1, 0])),\n            ]\n        automatically_mark_notations(note, mock_textlearner)\n        print('The following is the note after the double asterisks are added, '\n              'assuming that the ML model predictions are as above:')\n        print(note.text())\n        assert r'**$\\operatorname{Gal}(L/K)$**' in note.text()\n\nThe following is the note after the double asterisks are added, assuming that the ML model predictions are as above:\n---\ncssclass: clean-embeds\naliases: []\ntags: [_meta/literature_note, _meta/definition, _meta/notation]\n---\n# Topic[^1]\n%%This is an example file to which  `automatcally_mark_notations` will be applied.%%\n\nLet $L/K$ be a Galois field extension. Its Galois group **$\\operatorname{Gal}(L/K)$** is defined as the group of automorphisms of $L$ fixing $K$ pointwise.\n\n# See Also\n\n# Meta\n## References\n\n## Citations and Footnotes\n[^1]: Kim, \n\n\n\n# TODO: test 'w' after implementing `overwrite.`\n\n\n# TODO: test 'a' after implementing `overwrite.`\n\n\n# TODO: test `None` after implementing `overwrite.`",
    "crumbs": [
      "markdown.obisidian.personal.machine_learning.notation_identification"
    ]
  },
  {
    "objectID": "markdown.obsidian.tags.html",
    "href": "markdown.obsidian.tags.html",
    "title": "markdown.obsidian.tags",
    "section": "",
    "text": "# TODO: add examples, dog strings\n\n\nsource\n\nto_tag_str\n\n to_tag_str (tag_name)\n\n\nsource\n\n\ntag_without_hashtag\n\n tag_without_hashtag (tag)\n\n\nsource\n\n\ntag_is_auto_tag\n\n tag_is_auto_tag (tag)\n\n\nsource\n\n\nstrip_auto_from_tag\n\n strip_auto_from_tag (tag, with_hash_tag:bool=True)\n\n*Returns the tag without the '_auto/' prefix.\nThis will essentially return the same tag if the tag does not have the '_auto/' prefix to begin with.\nParameters - tag - str - with_has_tag - bool - If True, returns a str with a hash tag '#' in front. Defaults to True.*\n\nstrip_auto_from_tag('#_auto/definition', False)\n\n'definition'",
    "crumbs": [
      "markdown.obsidian.tags"
    ]
  },
  {
    "objectID": "helper.path_accepted_string.html",
    "href": "helper.path_accepted_string.html",
    "title": "helper.path_accepted_string",
    "section": "",
    "text": "from pathvalidate import validate_filename\n\n\nsource\n\nlatex_to_path_accepted_string\n\n latex_to_path_accepted_string (latex:str)\n\nConvert a latex string to a path accepted string\nThe latex_to_path_accepted_string function “cleans” a latex str into a path-valid string for the purposes of making files.\n\nsample_1 = r'\\mathcal{O}_X'\noutput_1 = latex_to_path_accepted_string(sample_1)\nprint(output_1)\nassert 'O' in output_1 and 'X' in output_1\nvalidate_filename(output_1)\n\nsample_2 = r'\\operatorname{Gal}(L/K)'\noutput_2 = latex_to_path_accepted_string(sample_2)\nprint(output_2)\nassert 'Gal' in output_2 and 'L' in output_2 and 'K' in output_2\nvalidate_filename(output_2)\n\n# Example found in https://arxiv.org/abs/1607.04471\nsample_3 = r'\\begin{equation} \\label{escape rate}   G_{F_t}(z,w) = \\lim_{n\\to\\infty} \\frac{1}{d^n} \\log \\| F_t^n(z,w) \\|, \\end{equation}'\noutput_3 = latex_to_path_accepted_string(sample_3)\nprint(output_3)\nvalidate_filename(output_3)\n\nO_X\nGal_L_K\nlabel_escape_rate_G_F_t_z_w_lim_n_to_infty_frac_1_d_n_log_F_t_n_z_w",
    "crumbs": [
      "helper.path_accepted_string"
    ]
  },
  {
    "objectID": "latex.preamble.html",
    "href": "latex.preamble.html",
    "title": "latex.preamble",
    "section": "",
    "text": "from trouver.helper.files_and_folders import text_from_file\nfrom trouver.helper.tests import _test_directory",
    "crumbs": [
      "latex.preamble"
    ]
  },
  {
    "objectID": "latex.preamble.html#divide-the-preamble-from-the-rest-of-the-document",
    "href": "latex.preamble.html#divide-the-preamble-from-the-rest-of-the-document",
    "title": "latex.preamble",
    "section": "Divide the preamble from the rest of the document",
    "text": "Divide the preamble from the rest of the document\nSome macros and commands defined in the preamble seem to prevent the pylatexenc methods from properly identifying the document environment/node in a LaTeX document. To circumvent this, we define a function to divide the preamble from the rest of the document\n\nsource\n\ndivide_preamble\n\n divide_preamble (text:str, document_environment_name:str='document')\n\nDivide the preamble from the rest of a LaTeX document.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ntext\nstr\n\nLaTeX document\n\n\ndocument_environment_name\nstr\ndocument\n\n\n\nReturns\ntuple\n\n\n\n\n\n\nlatex_file_path = _test_directory() / 'latex_examples' / 'example_with_a_command_with_begin.tex'\ntext = text_from_file(latex_file_path)\n\npreamble, document = divide_preamble(text)\nassert r'\\begin{displaymath}' in preamble\nassert r'Hyun Jong Kim' in preamble\n\nassert r'Hyun Jong Kim' not in document\nassert document.startswith(r'\\begin{document}')\nassert document.endswith('\\\\end{document}')",
    "crumbs": [
      "latex.preamble"
    ]
  },
  {
    "objectID": "latex.preamble.html#include-.sty-files-content-into-preamble",
    "href": "latex.preamble.html#include-.sty-files-content-into-preamble",
    "title": "latex.preamble",
    "section": "Include .sty file’s content into preamble",
    "text": "Include .sty file’s content into preamble\nWriters often define custom commands in .sty files\n\nsource\n\nreplace_inclusion_of_style_file_with_code\n\n replace_inclusion_of_style_file_with_code (document:str, dir:os.PathLike)\n\n*Replace style file inclusions in document with the code of the style files.\nThis function searches for occurrences of \\usepackage{...}, \\input{...}, \\import{...}{...}, \\includefrom{...}{...}, and \\subincludefrom{...}{...} and replaces them with the actual contents of the corresponding .sty files, if available.*\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ndocument\nstr\n\n\n\ndir\nPathLike\nThe directory containing the style file.\n\n\nReturns\nstr\nThe modified document with style file inclusions replaced by their contents.\n\n\n\nThe replace_inclusion_of_style_file_with_code function substitutes the code in style files into the appropriate locations in a latex document.\n\nlatex_folder = _test_directory() / 'latex_examples' / 'latex_example_with_style_file'\nmain_file = latex_folder / 'main.tex'\nwith open(main_file, 'r', encoding='utf-8') as file:\n    document = file.read()\noutput = replace_inclusion_of_style_file_with_code(document, latex_folder)\n# preamble, body = divide_preamble(document)\n# commands = custom_commands(preamble)\nprint(output)\n\n\\documentclass{article}\n\n% Include a style file\n% Start of included style file: mystyle.sty\n% My custom style definitions\n\\newcommand{\\mystylecommand}[1]{\\textbf{#1}}\n\n% End of included style file: mystyle.sty\n\n\\begin{document}\n\n% Include a non-style file\n\\input{nonstylefile}\n\n\nHello, world! This document uses styles defined in mystyle.sty.\n\n\\end{document}\n\n\n\nC:\\Users\\hyunj\\AppData\\Local\\Temp\\ipykernel_2016\\2190002304.py:40: UserWarning: Style file c:\\Users\\hyunj\\Documents\\Development\\Python\\trouver\\nbs\\_tests\\latex_examples\\latex_example_with_style_file\\nonstylefile.sty not found. Keeping original command.\n  warnings.warn(f\"Style file {file_path} not found. Keeping original command.\", UserWarning)\n\n\nIt may be best practice to apply replace_inclusion_of_styl_file_with_code to the preamble of the document assuming that the latex document only includes style files in the preamble.\n\nlatex_folder = _test_directory() / 'latex_examples' / 'latex_example_with_style_file'\nmain_file = latex_folder / 'main.tex'\nwith open(main_file, 'r', encoding='utf-8') as file:\n    document = file.read()\npreamble, body = divide_preamble(document)\noutput = replace_inclusion_of_style_file_with_code(preamble, latex_folder)\n# commands = custom_commands(preamble)\nprint(output)\n\n\\documentclass{article}\n\n% Include a style file\n% Start of included style file: mystyle.sty\n% My custom style definitions\n\\newcommand{\\mystylecommand}[1]{\\textbf{#1}}\n\n% End of included style file: mystyle.sty",
    "crumbs": [
      "latex.preamble"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.information_notes.html",
    "href": "markdown.obsidian.personal.information_notes.html",
    "title": "markdown.obsidian.personal.information_notes",
    "section": "",
    "text": "from fastcore.test import *\n\nfrom trouver.helper.tests import _test_directory",
    "crumbs": [
      "markdown.obsidian.personal.information_notes"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.information_notes.html#get-the-main-content-of-the-standard-information-note",
    "href": "markdown.obsidian.personal.information_notes.html#get-the-main-content-of-the-standard-information-note",
    "title": "markdown.obsidian.personal.information_notes",
    "section": "Get the main content of the Standard information note",
    "text": "Get the main content of the Standard information note\n\nsource\n\nmain_content\n\n main_content (note:trouver.markdown.obsidian.vault.VaultNote)\n\n*The main content of the standard information note.\nThis is the text not in the yaml frontmatter and not the '#See Aslo' section and below.\nParameters - note: VaultNote - A standard information note.\nReturns - str*\n\n\nIdentify reference that the information note belongs to\nEach information note tends to “come from” a reference. The following is a function to identify which reference the information note comes from.\n\nsource\n\n\nreference_of_information_note\n\n reference_of_information_note\n                                (note:trouver.markdown.obsidian.vault.Vaul\n                                tNote)\n\n*Returns the reference note that the information note probably comes from.\nTODO\nParameters - note - VaultNote - A standard information note\nReturns - VaultNote*\n\nsource\n\n\nreference_notes_in_references_section_of_information_note\n\n reference_notes_in_references_section_of_information_note\n                                                            (note:trouver.\n                                                            markdown.obsid\n                                                            ian.vault.Vaul\n                                                            tNote)\n\n*Returns a list of [ObsidianLink](https://hyunjongkimmath.github.io/trouver/markdown.obsidian.links.html#obsidianlink) objects corresponding to reference notes in the “References” section of the information note.\nParameters - note - VaultNote - A standard information note\nReturns - list of [ObsidianLink](https://hyunjongkimmath.github.io/trouver/markdown.obsidian.links.html#obsidianlink)*\n\n# TODO: examples",
    "crumbs": [
      "markdown.obsidian.personal.information_notes"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.information_notes.html#note-creation",
    "href": "markdown.obsidian.personal.information_notes.html#note-creation",
    "title": "markdown.obsidian.personal.information_notes",
    "section": "Note creation",
    "text": "Note creation\nI think that one of the things that takes me a lot of time while making my math vault is the following process: 1. Creating notes 2. Inserting the template 3. Filling in the note 4. Renaming the note and its title 5. Linking the note to the appropriate index note.\n\nCreating notes and linking them to the index note\nHere, I will address 1, 2, and 5; 1 can be done with the [VaultNote](https://hyunjongkimmath.github.io/trouver/markdown.obsidian.vault.html#vaultnote) class. Then, fill in the blank notes with a template and then link them to the appropriate index note\nWhen creating/filling in the note, it can be useful to add tags. For example, I can add a tag to indicate that the note was autogenerated.\n\nsource\n\n\ncitation_location_string\n\n citation_location_string (citation_location:tuple[str,int])\n\n*Formats a pair specifying the Numbering label and page\nParameters - citation_location - 2-tuple or empty tuple - Consists of a label str and a page number indicating where in the note’s reference text the note’s information originates from, e.g. the label might be the str ‘Theorem 1.2.3’ and the page number might be the int 85.*\n\nsource\n\n\nfill_info_note_with_template\n\n fill_info_note_with_template\n                               (vn:trouver.markdown.obsidian.vault.VaultNo\n                               te, template:trouver.markdown.obsidian.vaul\n                               t.VaultNote,\n                               citation_location:tuple[str,int]=(),\n                               content:str='', tags_to_add:Union[str,list[\n                               str],tuple[str],NoneType]=None)\n\n*Fills in the note with a template with optionally tags.\nCurrent implementation adds content to line 5 of the note.\nParameters - vn - [VaultNote](https://hyunjongkimmath.github.io/trouver/markdown.obsidian.vault.html#vaultnote) - template - [VaultNote](https://hyunjongkimmath.github.io/trouver/markdown.obsidian.vault.html#vaultnote) - citation_location - 2-tuple or empty tuple - Consists of a label str and a page number indicating where in the note’s reference text the note’s information originates from, e.g. the label might be the str ‘Theorem 1.2.3’ and the page number might be the int 85. - content - str - Content to add to the note. Defaults to the empty str. - tags_to_add - str or list of str or tuple of str or None - Each str is just the name of the tag without the leading hashtag. Defaults to None, in which case no tags are added.*\n\nsource\n\n\nlink_info_notes_to_index\n\n link_info_notes_to_index (info_notes,\n                           index_note:trouver.markdown.obsidian.vault.Vaul\n                           tNote, citation_locations:tuple=(),\n                           insert_blank_line=False)\n\n*Links notes to an index_note.\nFor now, just adds to the bottom of the thing # TODO Make it possible to add in specific sections\nParameters - info_notes - [VaultNote](https://hyunjongkimmath.github.io/trouver/markdown.obsidian.vault.html#vaultnote) or list of [VaultNote](https://hyunjongkimmath.github.io/trouver/markdown.obsidian.vault.html#vaultnote) - index_note - [VaultNote](https://hyunjongkimmath.github.io/trouver/markdown.obsidian.vault.html#vaultnote) - insert_blank_line - bool - If True, then insert a blank line at the end of the index note before adding the links to the info notes.*\n\nsource\n\n\ncreate_info_notes_and_link_to_index\n\n create_info_notes_and_link_to_index\n                                      (to_create:list[trouver.markdown.obs\n                                      idian.vault.VaultNote], template:tro\n                                      uver.markdown.obsidian.vault.VaultNo\n                                      te, index_note:trouver.markdown.obsi\n                                      dian.vault.VaultNote,\n                                      citation_locations:list=[],\n                                      content_to_add:list=[], tags_to_add:\n                                      Union[str,list[str],tuple[str],NoneT\n                                      ype]=None)\n\n*Creates multiple notes, fills them in with a template, and links them to the appropriate index note.\nCurrent implementation adds content from content_to_add to line 5 of the VaultNotes.\nParameters - to_create - list of [VaultNote](https://hyunjongkimmath.github.io/trouver/markdown.obsidian.vault.html#vaultnote). - template - [VaultNote](https://hyunjongkimmath.github.io/trouver/markdown.obsidian.vault.html#vaultnote) - index_note - [VaultNote](https://hyunjongkimmath.github.io/trouver/markdown.obsidian.vault.html#vaultnote) - citation_locations - list of 2-tuples or empty tuples - Each tuple consists of a label str and a page number indicating where in the note’s reference text the note’s information originates from, e.g. the label might be the str ‘Theorem 1.2.3’ and the page number might be the int 85. This list must be of the same length as to_create. - content_to_add - list of str - Each str is the content to be added for each note in to_create. Defaults to the empty list, in which case no content is added. - tags_to_add - str or list of str or tuple of str or None - Each str is just the name of the tag without the leading hashtag. Defaults to None, in which case no tags are added.*\n\nsource\n\n\ncreate_generic_info_notes_and_link_to_index\n\n create_generic_info_notes_and_link_to_index (reference:str, count:int,\n                                              vault, subdirectory, templat\n                                              e:trouver.markdown.obsidian.\n                                              vault.VaultNote, index_note:\n                                              trouver.markdown.obsidian.va\n                                              ult.VaultNote,\n                                              tags_to_add=None)\n\n*Creates generically named notes, fills them in with a template, and links them to the appropriate index note.\nThe note will be named in the form f'{reference}_{number}', where number starts with 0.\nParameters - reference - str - The name of the reference. This will be part of the generic note names. - count - int - The number of generic info notes to create. - vault - Pathlike - subdirectory - Pathlike - The subdirectory in vault to create the notes in. - template - VaultNote - index_note - VaultNote - tags_to_add - str or list of str or tuple of str or None - Each str is just the name of the tag without the leading hashtag. Defaults to None, in which case no tags are added.*",
    "crumbs": [
      "markdown.obsidian.personal.information_notes"
    ]
  },
  {
    "objectID": "markdown.obsidian.personal.information_notes.html#getting-an-index-note",
    "href": "markdown.obsidian.personal.information_notes.html#getting-an-index-note",
    "title": "markdown.obsidian.personal.information_notes",
    "section": "Getting an index note",
    "text": "Getting an index note\n\nsource\n\nindex_note_of_a_directory\n\n index_note_of_a_directory (vault:os.PathLike, directory:os.PathLike)\n\n*Return the index note in a directory in an Obsidian.md vault, if it exists.\nAssumes that the directory has at most one index note.\nRaises\n\nRuntimeError\n\nIf more than one index note exists in the directory.*\n\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nvault\nPathLike\n\n\n\ndirectory\nPathLike\nRelative to vault\n\n\nReturns\nOptional\nEither the index note in the directory if it exists or None\n\n\n\n\n# TODO: examples\nvault = _test_directory() / 'test_vault_5'\n\nsample_output = index_note_of_a_directory(vault, directory='algebra')\nassert sample_output is not None\ntest_eq(sample_output.name, '_index_algebra')\n\nsample_output = index_note_of_a_directory(vault, directory='')\nassert sample_output is not None\ntest_eq(sample_output.name, '_index')\n\nIf there is more than one index note in a directory, then a RuntimeError is raised:\n\nvault = _test_directory() / 'test_vault_5'\n\nwith ExceptionExpected(RuntimeError):\n    sample_output = index_note_of_a_directory(vault, directory='folder_with_more_than_one_index_note')\n\n\nsource\n\n\nindex_note_of_note\n\n index_note_of_note (note:trouver.markdown.obsidian.vault.VaultNote)\n\n*Return the index note indexing the specified note.\nnote is assumed to either be an information note or itself an index note.\nAssumes that a note in indexed in at most one index note and that this index note is either in the same directory as the note or in the immediate parent directory of the note.\nRaises\n\nUserWarning\n\nIf an index note that is supposed to index note exists, but does not actually index note.*\n\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nnote\nVaultNote\nAn information note or an index note\n\n\nReturns\nOptional\nThe index note which indexes note. If no such index note exists (in either the same directory as or the immediate parent directory of the note), then None is returned. In particular, None is returned if note is the root index note of the vault.\n\n\n\n\n# TODO: examples\nvault = _test_directory() / 'test_vault_5'\n\n# The index note is in the parent directory of the directory that `info_note` is in.\ninfo_note = VaultNote(vault, name='number_theory_reference_1_Definition 1.1')\nsample_output = index_note_of_note(info_note)\nassert sample_output is not None\ntest_eq(sample_output.name, '_index_1_chapter_number_theory_reference_1')\n\n\n# Here, we have an `index_note` and we are trying to find its index note, which is \n# in the parent directory of the directory that `index_note` is in.\nindex_note = VaultNote(vault, name='_index_1_chapter_number_theory_reference_1')\nsample_output = index_note_of_note(index_note)\nassert sample_output is not None\ntest_eq(sample_output.name, '_index_number_theory_reference_1')\n\n# Here, we have the `root_index_note` of the vault, which is in the root directory\n# of the vault. This root index note does not have an index note.\nroot_index_note = VaultNote(vault, name='_index')\nsample_output = index_note_of_note(root_index_note)\nassert sample_output is None\n\n# Here, we have `info_note` that is in the same directory as its index note.\ninfo_note = VaultNote(vault, name='number_theory_reference_1_note_in_same_directory_as_index_note')\nsample_output = index_note_of_note(info_note)\nassert sample_output is not None\ntest_eq(sample_output.name, '_index_2_chapter_number_theory_reference_2')",
    "crumbs": [
      "markdown.obsidian.personal.information_notes"
    ]
  }
]